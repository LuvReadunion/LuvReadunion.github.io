
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <title>
    惊变42天: Week 3 君子终日乾乾 |
    
    Luv Read Union
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
<link rel="stylesheet" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/regular.min.css">
<link rel="stylesheet" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/solid.min.css">

  <link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/brands.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;"><link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/v5-font-face.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;"><link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/v4-font-face.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
<link rel="stylesheet" href="/css/loader.css">

  <meta name="description" content="开场白 一想到这期的封面能放我的早苗，还是尽快赶出来了。 第三周的内容堪比前两周的总和，记录了三个章节的内容，类是 C++ 学习很重要的一个part，所以篇幅的开销是巨大的(不过后面的章节也不会太少啦)。 从进度看来，42天完成整本书的任务应是太难，需要更多的时间。 最近一直在单曲循环一首写王安石王相公的歌曲，感动至极，也在这里分享。 《诗出有名·王安石荆公篇》 世之奇伟、瑰怪，非常之观，常在于">
<meta property="og:type" content="article">
<meta property="og:title" content="惊变42天: Week 3 君子终日乾乾">
<meta property="og:url" content="https://luvreadunion.com/2024/03/20/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E5%90%9B%E5%AD%90%E7%BB%88%E6%97%A5%E4%B9%BE%E4%B9%BE/index.html">
<meta property="og:site_name" content="Luv Read Union">
<meta property="og:description" content="开场白 一想到这期的封面能放我的早苗，还是尽快赶出来了。 第三周的内容堪比前两周的总和，记录了三个章节的内容，类是 C++ 学习很重要的一个part，所以篇幅的开销是巨大的(不过后面的章节也不会太少啦)。 从进度看来，42天完成整本书的任务应是太难，需要更多的时间。 最近一直在单曲循环一首写王安石王相公的歌曲，感动至极，也在这里分享。 《诗出有名·王安石荆公篇》 世之奇伟、瑰怪，非常之观，常在于">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-20T06:06:28.000Z">
<meta property="article:modified_time" content="2024-03-20T06:51:57.582Z">
<meta property="article:author" content="Luv">
<meta property="article:tag" content="惊变42天:C++">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Luv Read Union" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/typeface-source-code-pro@1.1.13/index.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css">

  
  
  
  
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script>

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/wowjs@1.1.3/css/libs/animate.css">

    
<script src="https://npm.webcache.cn/wowjs@1.1.3/dist/wow.min.js"></script>

    <script>
      new WOW({
        offset: 0,
        mobile: true,
        live: false
      }).init();
    </script>
  
  
    <script src="/sw.js"></script>
  
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg"></div>
    <div class="loading-right-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
          <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
          <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
          <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
        </svg>
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    const startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    const endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('load', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/">首页</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/archives">归档</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/about">关于</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/friend">友链</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
    
    
      <a id="nav-search-btn" class="nav-icon popup-trigger" title="搜索"></a>
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="/images/66458540.avif" alt="惊变42天: Week 3 君子终日乾乾">
  
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div id="logo-wrap">
        
          
          
            <a href="/" id="logo">
              <h1>惊变42天: Week 3 君子终日乾乾</h1>
            </a>
          
        
      </div>
      
        
        <h2 id="subtitle-wrap">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="outer">
          
          <section id="main"><article id="post-惊变42天-C++-君子终日乾乾" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    <div class="article-meta">
      <div class="article-date wow slideInLeft">
  <a href="/2024/03/20/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E5%90%9B%E5%AD%90%E7%BB%88%E6%97%A5%E4%B9%BE%E4%B9%BE/" class="article-date-link">
    <time datetime="2024-03-20T06:06:28.000Z" itemprop="datePublished">2024-03-20</time>
  </a>
</div>

      
  <div class="article-category wow slideInLeft">
    <a class="article-category-link" href="/categories/C/">C++</a><a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="开场白"><a class="markdownIt-Anchor" href="#开场白"></a> 开场白</h1>
<p>一想到这期的<strong>封面</strong>能放我的<strong>早苗</strong>，还是尽快赶出来了。</p>
<p>第三周的内容堪比前两周的总和，记录了三个章节的内容，<strong>类</strong>是 C++ 学习很重要的一个<code>part</code>，所以篇幅的开销是<strong>巨大</strong>的(不过后面的章节也不会太少啦)。</p>
<p>从进度看来，<strong>42</strong>天完成整本书的任务应是太难，需要更多的时间。</p>
<p>最近一直在单曲循环一首写<strong>王安石王相公的歌曲</strong>，<strong>感动至极</strong>，也在这里分享。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XJ4m1s7Mp">《诗出有名·王安石荆公篇》</a></p>
<p><strong>世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。</strong></p>
<p>(👉 ^ v ^ )👉</p>
<p><strong>继续加油吧~</strong></p>
<h1 id="week-1-潜龙勿用"><a class="markdownIt-Anchor" href="#week-1-潜龙勿用"></a> Week 1: 潜龙勿用</h1>
<p>点击跳转<a href="/2024/03/02/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8/">第一期内容：潜龙勿用</a></p>
<h1 id="week-2-见龙在田"><a class="markdownIt-Anchor" href="#week-2-见龙在田"></a> Week 2: 见龙在田</h1>
<p>点击跳转<a href="/2024/03/10/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0/">第二期内容：见龙在田</a></p>
<h1 id="week-3-君子终日乾乾"><a class="markdownIt-Anchor" href="#week-3-君子终日乾乾"></a> Week 3: 君子终日乾乾</h1>
<h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2>
<p>类的基本思想是<strong>数据抽象</strong>(data abstraction)和<strong>封装</strong>(encapsulation)。数据抽象是一种依赖于<strong>接口</strong>(interface)和<strong>实现</strong>(implementation)分离的编程(以及设计)技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<h3 id="定义抽象数据类型"><a class="markdownIt-Anchor" href="#定义抽象数据类型"></a> 定义抽象数据类型</h3>
<blockquote>
<p>这里以Sales_data类为例。</p>
</blockquote>
<h4 id="设计sales_data"><a class="markdownIt-Anchor" href="#设计sales_data"></a> 设计Sales_data</h4>
<p><strong>Sales_data</strong>的接口应该包含以下操作:</p>
<ul>
<li>一个<code>isbn</code>成员函数，用于返回对象的<code>ISBN</code>编号。</li>
<li>一个<code>combine</code>成员函数，用于将一个<code>Sales_data</code>对象加到另一个对象上。</li>
<li>一个名为<code>add</code>的函数，执行两个<code>Sales_data</code>对象的加法。</li>
<li>一个<code>read</code> 函数，将数据从<code>istream</code>读入到<code>Sales_data</code>对象中。</li>
<li>一个<code>print</code>函数，将<code>Sales_data</code>对象的值输出到<code>ostream</code>。</li>
</ul>
<p>预期使用这些接口函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sales_data total;								<span class="comment">//保存当前求和结果和变量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">read</span>(cin, total)) &#123;							<span class="comment">//读入第一笔交易</span></span><br><span class="line">    Sales_data trans;							<span class="comment">//保存下一条交易数据的变量</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(cin, trans)) &#123;					<span class="comment">//读入剩余的交易</span></span><br><span class="line">        <span class="keyword">if</span> (total.<span class="built_in">isbn</span>() == trans.<span class="built_in">isbn</span>())		<span class="comment">//检查isbn</span></span><br><span class="line">            total.<span class="built_in">combine</span>(trans);				<span class="comment">//更新变量total当前的值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(cout, total) &lt;&lt; endl;			<span class="comment">//输出结果</span></span><br><span class="line">            total = trans;						<span class="comment">//处理下一本书</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(cout, total) &lt;&lt; endl;					<span class="comment">//输出最后一笔交易</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;										<span class="comment">//没有任何输入信息</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;No data?!&quot;</span> &lt;&lt; endl;				<span class="comment">//通知用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义改进的sales_data类"><a class="markdownIt-Anchor" href="#定义改进的sales_data类"></a> 定义改进的Sales_data类</h4>
<p>定义和声明成员函数的方式与普通函数差不多。成员函数的<strong>声明</strong>必须在类的<strong>内部</strong>，它的<strong>定义</strong>则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如 <code>add</code>、<code>read</code>和 <code>print</code>等，它们的定义和声明都在类的外部。</p>
<p><code>avg_price</code>函数用于求出售书籍的平均价格，目的并非通用，所以属于类的实现的一部分，而非接口的一部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line">    <span class="comment">//关于Sales_data对象的操作</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;			<span class="comment">//这个const保证不改变类的成员</span></span><br><span class="line">    <span class="comment">//数据成员</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Sales_data的非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip:</strong> 定义在类内部的函数是隐式的inline函数。</p>
</blockquote>
<h5 id="定义成员函数"><a class="markdownIt-Anchor" href="#定义成员函数"></a> 定义成员函数</h5>
<p>尽管所有成员必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。</p>
<h5 id="引入this"><a class="markdownIt-Anchor" href="#引入this"></a> 引入this</h5>
<p>成员函数通过一个名为<strong>this</strong>的额外的隐式参数来访问调用它的对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化<code>this</code>。例如，如果调用<code>total.isbn()</code>，则编译器负责把<code>total</code>的地址传给<code>isbn</code>的隐式形参<code>this</code>。</p>
<p>在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为<code>this</code>所指的正是这个对象。任何对类成员的直接访问都被看作<code>this</code> 的隐式引用，也就是说，当<code>isbn</code>使用<code>bookNo</code>时，它隐式地使用<code>this</code>指向的成员，就像我们书写了 <code>this-&gt;bookNo</code> 一样。</p>
<p>对于我们来说，<code>this</code>形参是隐式定义的。实际上，任何自定义名为<code>this</code>的参数或变量的行为都是非法的。我们可以在成员函数体内部使用<code>this</code>，因此尽管没有必要，但我们还是能把<code>isbn</code>定义成如下的形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</span><br></pre></td></tr></table></figure>
<h5 id="引入const成员函数"><a class="markdownIt-Anchor" href="#引入const成员函数"></a> 引入const成员函数</h5>
<p><code>isbn</code>函数的另一个关键之处是紧随参数列表之后的 <code>const</code> 关键字，这里，<code>const</code>的作用是修改隐式<code>this</code>指针的类型。</p>
<p>默认情况下，<code>this</code>的类型是<strong>指向类类型非常量对象的常量指针</strong>。尽管<code>this</code>是隐式的，仍遵循初始化规则，意味着我们不能把一个指向非常量的指针<code>this</code>绑定到一个常量对象上。也即不能再一个常量对象上调用普通的成员函数。</p>
<p>然而，<code>this</code>是隐式的并且不会出现在参数列表中，所以在哪儿将<code>this</code>声明成指向常量的指针就成为我们必须面对的问题。C++ 语言的做法是允许把<code>const</code>关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的<code>const</code>表示 <code>this</code>是一个指向常量的指针。像这样使用<code>const</code>的成员函数被称作<strong>常量成员函数</strong>(const member function)。</p>
<blockquote>
<p>因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。</p>
</blockquote>
<blockquote>
<p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
</blockquote>
<h5 id="类作用域和成员函数"><a class="markdownIt-Anchor" href="#类作用域和成员函数"></a> 类作用域和成员函数</h5>
<p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体(如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<h5 id="在类的外部定义成员函数"><a class="markdownIt-Anchor" href="#在类的外部定义成员函数"></a> 在类的外部定义成员函数</h5>
<p>像其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，<strong>返回类型</strong>、<strong>参数列表</strong>和<strong>函数名</strong>都得与类内部的声明保持一致。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定<code>const</code>属性。同时，类外部定义的成员的名字必须包含它所属的类名:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数名<code>Sales data::avg price</code>使用作用域运算符来说明如下的事实：</p>
<p>我们定义了一个名为<code>avg_price</code>的函数，并且该函数被声明在类<code>Sales_data</code>的作用域内。一旦编译器看到这个函数名，就能理解剩余的代码是位于类的作用域内的。因此，当<code>avg_price</code>使用 <code>revenue</code> 和 units <code>_sold</code> 时，实际上它隐式地使用了<code>Sales_data</code>的成员。</p>
<h5 id="定义一个返回this对象的函数"><a class="markdownIt-Anchor" href="#定义一个返回this对象的函数"></a> 定义一个返回this对象的函数</h5>
<p>函数<code>combine</code>的设计初衷类似于复合赋值运算符 += ，调用该函数的对象代表左侧的运算对象，右侧的运算对象则通过显式的实参被传入函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;	<span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;					<span class="comment">//返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们的交易处理程序调用如下的函数时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total.<span class="built_in">combine</span>(trans);		<span class="comment">//更新变量total当前的值</span></span><br></pre></td></tr></table></figure>
<p><code>total</code>的地址被绑定到隐式的<code>this</code>参数上，而<code>rhs</code>绑定到<code>trans</code>上。</p>
<p>该函数一个值得关注的部分是它的返回类型和返回语句。一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量<strong>模仿</strong>这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回，因此为了与它保持一致，<code>combine</code>函数必须返回引用类型。因为此时的左侧运算对象是一个<code>Sales_data</code>的对象，所以返回类型应该是 <code>Sales_data&amp;</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;			<span class="comment">//返回调用该函数的对象</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>return</code>语句解引用<code>this</code>指针以获得执行该函数的对象，也即返回<code>total</code>的引用。</p>
<h4 id="定义类相关的非成员函数"><a class="markdownIt-Anchor" href="#定义类相关的非成员函数"></a> 定义类相关的非成员函数</h4>
<p>类的作者常常需要定义一些辅助函数，比如<code>add</code>、<code>read</code>和<code>print</code>等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。</p>
<p>我们定义非成员函数的方式与定义其他函数一样,通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明(而非定义)在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。</p>
<blockquote>
<p><strong>Tip:</strong> 如果非成员函数是类接口的组成部分，应该把这些函数的声明与类放在同一个头文件内。</p>
</blockquote>
<h5 id="定义read和print函数"><a class="markdownIt-Anchor" href="#定义read和print函数"></a> 定义read和print函数</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入的交易信息包括ISBN、售出总数和售出价格</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">	os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>read</code>函数从给定流中将数据读到给定的对象里，<code>print</code>函数则负责将给定对象的内容打印到给定的流中。</p>
<p>除此之外，关于上面的函数还有两点是非常重要的：</p>
<p>第一点，<code>read</code> 和 <code>print</code> 分别接受一个各自<strong>IO</strong>类型的引用作为其参数，这是因为<strong>IO</strong>类属于不能被拷贝的类型，因此我们只能通过引用来传递它们。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。</p>
<p>第二点，<code>print</code>函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。</p>
<h5 id="定义add函数"><a class="markdownIt-Anchor" href="#定义add函数"></a> 定义add函数</h5>
<p><code>add</code>函数接受两个<code>Sales_data</code>对象作为其参数，返回值是一个新的<code>Sales_data</code>，用于表示前两个对象的和:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    Sales_data sum = lhs;	<span class="comment">//把lhs的数据成员拷贝给sum</span></span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);		<span class="comment">//把rhs的数据成员加到sum当中</span></span><br><span class="line">    <span class="keyword">return</span> sum;				<span class="comment">//返回sum的副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，拷贝类的对象其实拷贝的是对象的数据成员。</p>
</blockquote>
<h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4>
<p>每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>(constructor)。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</p>
<p>构造函数的名字和类名相同。和其他函数不一样的是，构造函数<strong>没有返回类型</strong>；除此之外类似于其他的函数，构造函数也有一个(可能为空的)参数列表和一个(可能为空的)函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。</p>
<p>不同于其他成员函数，构造函数不能被声明成<code>const</code>的，当我们创建类的一个<code>const</code>对象时，直到构造函数完成初始化过程，对象才能真正取其“常量”属性。因此，构造函数在<code>const</code>对象的构造过程中可以向其写值。</p>
<h5 id="合成的默认构造函数"><a class="markdownIt-Anchor" href="#合成的默认构造函数"></a> 合成的默认构造函数</h5>
<p>类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做<strong>默认构造函数</strong>(default constructor)。默认构造函数无须任何实参。</p>
<p>默认构造函数在很多方面都有其特殊性。其中之一是，如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。</p>
<p>编译器创建的构造函数又被称为<strong>合成的默认构造函数</strong>(synthesized default constructor)。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员:</p>
<ul>
<li>如果存在类内的初始值，用它来初始化成员。</li>
<li>否则，默认初始化该成员。</li>
</ul>
<p>因为<code>Sales_data</code>为<code>units_sold</code>和<code>revenue</code>提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把 <code>bookNo</code>默认初始化成一个空字符串。</p>
<blockquote>
<p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</p>
</blockquote>
<blockquote>
<p>有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。</p>
</blockquote>
<h5 id="定义sales_data的构造函数"><a class="markdownIt-Anchor" href="#定义sales_data的构造函数"></a> 定义Sales_data的构造函数</h5>
<p>对于我们的<code>Sales_data</code>类来说，我们将使用下面的参数定义<strong>4</strong>个不同的构造函数：</p>
<ul>
<li>一个<code>istream&amp;</code>，从中读取一条交易信息。</li>
<li>一个<code>const string&amp;</code>，表示<strong>ISBN</strong>编号；一个<code>unsigned</code>，表示售出的图书数量；以及一个<code>double</code>，表示图书的售出价格。</li>
<li>一个<code>const string&amp;</code>，表示<strong>ISBN</strong>编号；编译器将赋予其他成员默认值。</li>
<li>一个空参数列表（即默认构造函数)，正如刚刚介绍的，既然我们已经定义了其他构造函数，那么也必须定义一个默认构造函数。</li>
</ul>
<p>给类添加了这些成员之后，将得到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line">    <span class="comment">//新增的构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):<span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="comment">//之前已有的其他成员</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="default-的含义"><a class="markdownIt-Anchor" href="#default-的含义"></a> = default 的含义</h5>
<p>以上的默认构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。</p>
<p>在 C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 <code>= default</code> 来要求编译器生成构造函数。其中，<code>= default</code> 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果 <code>= default</code> 在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。</p>
<blockquote>
<p><strong>Warning:</strong> 上面的默认构造函数之所以对Sales_data有效，是因为我们为内置类型的数据成员提供了初始值。如果你的编译器不支持类内初始值，那么你的默认构造函数就应该使用构造函数初始值列表(下面介绍)来初始化类的每个成员。</p>
</blockquote>
<h5 id="构造函数初始值列表"><a class="markdownIt-Anchor" href="#构造函数初始值列表"></a> 构造函数初始值列表</h5>
<p>接下来我们介绍类中定义的另外两个构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这两个定义中出现了新的部分，即冒号以及冒号和花括号之间的代码，其中花括号定义了(空的)函数体。我们把新出现的部分称为<strong>构造函数初始值列表</strong>(constructor initialize list)，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初始化通过逗号分隔开来。</p>
<p>含有三个参数的构造函数分别使用它的前两个参数初始化成员<code>bookNo</code>和<code>units_sold</code>，<code>revenue</code>的初始值则通过将售出图书总数和每本书单价相乘计算得到。</p>
<p>只有一个<code>string</code>类型参数的构造函数使用这个<code>string</code>对象初始化<code>bookNo</code>，对于<code>units_sold</code>和<code>revenue</code>则没有显式地初始化。当某个数据成员被构造函数初始值列表忽略时，它将以<strong>与合成默认构造函数相同</strong>的方式隐式初始化。在此例中，这样的成员<strong>使用类内初始值初始化</strong>，因此只接受一个<code>string</code>参数的构造函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与上面定义的那个构造函数效果相同</span></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(<span class="number">0</span>), <span class="built_in">revenue</span>(<span class="number">0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。</p>
<blockquote>
<p>不过，如果使用的编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p>
</blockquote>
<p>有一点需要注意，在上面的两个构造函数中函数体都是空的。这是因为这些构造函数的唯一目的就是为数据成员赋初值，一旦没有其他任务需要执行，函数体也就为空了。</p>
<h5 id="在类的外部定义函数"><a class="markdownIt-Anchor" href="#在类的外部定义函数"></a> 在类的外部定义函数</h5>
<p>与其他几个构造函数不同，以<code>istream</code>为参数的构造函数需要执行一些实际的操作在它的函数体内，调用了<code>read</code>函数以给数据成员赋以初值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sale_data::<span class="built_in">Sales_data</span> (std::istream &amp;is)&#123;</span><br><span class="line">	<span class="built_in">read</span>(is, *<span class="keyword">this</span>);	<span class="comment">//read函数的作用是从is中读取一条交易信息并存入this对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数没有构造函数初始值列表，或者讲得更准确一点，它的构造函数初始值列表是空的。尽管构造函数初始值列表是空的，但是由于执行了构造函数体，所以对象的成员仍然能被初始化。</p>
<h3 id="访问控制与封装"><a class="markdownIt-Anchor" href="#访问控制与封装"></a> 访问控制与封装</h3>
<p>到目前为止，我们已经为类定义了接口，但并没有任何机制强制用户使用这些接口。我们的类还没有封装，也就是说，用户可以直达<code>Sales_data</code>对象的内部并且控制它的具体实现细节。在 C++ 语言中，我们使用<strong>访问说明符</strong>(access specifiers)加强类的封装性：</p>
<ul>
<li>定义在<strong>public</strong>说明符之后的成员在整个程序内可被访问，<strong>public</strong>成员定义类的接口。</li>
<li>定义在<strong>private</strong>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，<strong>private</strong>部分封装了(即隐藏了)类的实现细节。</li>
</ul>
<p>再一次定义<code>Sales_data</code>类，其新形式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:				<span class="comment">//添加了访问说明符</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):<span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"><span class="keyword">private</span>:			<span class="comment">//添加了访问说明符</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>作为接口的一部分，构造函数和部分成员函数(即<code>isbn</code>和<code>combine</code>)紧跟在<code>public</code>说明符之后;而数据成员和作为实现部分的函数则跟在<code>private</code>说明符后面。</p>
<p>一个类可以包含<strong>0</strong>个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下个访问说明符或者到达类的结尾处为止。</p>
<p><strong>使用class或struct关键字</strong></p>
<p>在上面的定义中我们还做了一个微妙的变化：我们使用了<code>class</code>关键字而非<code>struct</code>开始类的定义。这种变化仅仅是形式上有所不同，实际上我们可以使用这两个关键字中的任何一个定义类。唯一的区别是，<code>struct</code>和<code>class</code> 的默认访问权限不太一样。</p>
<p>类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用<code>struct</code>关键字，则定义在第一个访问说明符之前的成员是<code>public</code>的；相反，如果我们使用<code>class</code>关键字，则这些成员是<code>private</code>的。</p>
<blockquote>
<p>使用class和struct定义类唯一的区别就是默认的访问权限。</p>
</blockquote>
<h4 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h4>
<p>既然<code>Sales_data</code>的数据成员是<code>private</code>的，我们的<code>read</code>、<code>print</code>和<code>add</code>函数也就无法正常编译了，这是因为尽管这几个函数是类的接口的一部分，但它们不是类的成员。</p>
<p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它<strong>友元</strong>(friend)。如果类想把一个函数作为它的友元，只需要增加一条以<code>friend</code>关键字开始的函数声明语句即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="comment">//为Sales_data的非成员函数所做的友元声明 </span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="comment">//其他成员及访问说明符不变</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):<span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Sales_data接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。</p>
<p><strong>类调用友元</strong></p>
<p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>
<blockquote>
<p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中(类的外部)。因此，我们的Sales_data头文件应该为read、print和add提供额外独立的声明(除了类内部的友元声明之外)。</p>
</blockquote>
<h3 id="类的其他特性"><a class="markdownIt-Anchor" href="#类的其他特性"></a> 类的其他特性</h3>
<p>以下是<code>Sales_data</code>没有体现出来的一些类的特性。为了展示这些新的特性，我们需要定义一对相互关联的类，它们分别是<code>Screen</code>和<code>Window_mgr</code>。</p>
<h4 id="定义类型成员"><a class="markdownIt-Anchor" href="#定义类型成员"></a> 定义类型成员</h4>
<p><code>Screen</code>表示显示器中的一个窗口。每个<code>Screen</code>包含一个用于保存<code>Screen</code>内容的<code>string</code>成员和三个<code>string::size_type</code>类型的成员，它们分别表示光标的位置以及屏幕的高和宽。</p>
<p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是<code>public</code>或者<code>private</code>中的一种:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    std::string contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在<code>Screen</code>的<code>public</code>部分定义了<code>pos</code>，这样用户就可以使用这个名字。<code>Screen</code>的用户不应该知道<code>Screen</code>使用了一个<code>string</code>对象来存放它的数据，因此通过把<code>pos</code>定义成<code>public</code>成员可以隐藏<code>Screen</code> 实现的细节。</p>
<p>关于<code>pos</code>的声明有两点需要注意。首先，我们使用了<code>typedef</code>，也可以等价地使用类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用类型别名等价地声明一个类型名字</span></span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">	<span class="comment">//其他成员与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其次，用来定义类型的成员必须先定义后使用。因此，类型成员通常出现在类开始的地方。</p>
<h4 id="令成员作为内联函数"><a class="markdownIt-Anchor" href="#令成员作为内联函数"></a> 令成员作为内联函数</h4>
<p>在类中，常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的，定义在类内部的成员函数是自动<strong>inline</strong>的。因此，<code>Screen</code>的构造函数和返回光标所指字符的<code>get</code>函数默认是<code>inline</code>函数。</p>
<p>我们可以在类的内部把<code>inline</code>作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用<code>inline</code>关键字修饰函数的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="built_in">Screen</span>() = <span class="keyword">default</span>;		<span class="comment">//因为有另一个构造函数，所以需要写此函数</span></span><br><span class="line">    <span class="comment">//cursor被其类内初始值初始化为0</span></span><br><span class="line">    <span class="built_in">Screen</span>(pos ht, pos wd, <span class="type">char</span> c) : <span class="built_in">height</span>(ht), <span class="built_in">width</span>(wd), <span class="built_in">contents</span>(ht * wd, c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> contents[cursor]; &#125;	<span class="comment">//隐式内联，读取光标处的字符</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>;			<span class="comment">//显式内联</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">move</span><span class="params">(pos r, pos c)</span></span>;						<span class="comment">//在外部被设为内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    std::string contents;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> Screen:<span class="built_in">get</span>(pos r, pos c) <span class="type">const</span>			<span class="comment">//在类的内部声明成内联</span></span><br><span class="line">&#123;</span><br><span class="line">	pos row = r * width;				<span class="comment">//计算行的位置</span></span><br><span class="line">    <span class="keyword">return</span> contents[row + c];			<span class="comment">//返回给定列的字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span>	<span class="comment">//在函数的定义处指定inline</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pos row = r * width;				<span class="comment">//计算行的位置</span></span><br><span class="line">    cursor = row + c;					<span class="comment">//在行内将光标移动到指定的列</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;						<span class="comment">//以左值形式返回对象</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>在声明和定义处同时使用inline是合法的，但最好只在类的外部定义处说明inline，方便理解。</p>
</blockquote>
<blockquote>
<p>和我们在头文件中定义inline函数的原因一样，inline成员函数也应该与相应的类定义在同一个头文件中。</p>
</blockquote>
<h4 id="可变数据成员"><a class="markdownIt-Anchor" href="#可变数据成员"></a> 可变数据成员</h4>
<p>有时(但并不频繁)会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。</p>
<p>一个<strong>可变数据成员</strong>(mutable data member）永远不会是<code>const</code>，即使它是<code>const</code>对象的成员。因此，一个<code>const</code>成员函数可以改变一个可变成员的值。举个例子，我们将给<code>Screen</code>添加一个名为 <code>access_ctr</code>的可变成员，通过它我们可以追踪每个<code>Screen</code>的成员函数被调用了多少次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr;	<span class="comment">//即使在一个const对象内也能被修改</span></span><br><span class="line">    <span class="comment">//其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++access_ctr;		<span class="comment">//保存一个计数值，用于记录成员函数被调用的次数</span></span><br><span class="line">    <span class="comment">//该成员需要完成的其他工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管<code>some_member</code>是一个<code>const</code>成员函数，它仍然能够改变<code>access_ctr</code>的值。该成员是个可变成员，因此任何成员函数，包括<code>const</code>函数在内都能改变它的值。</p>
<h4 id="类数据成员的初始值"><a class="markdownIt-Anchor" href="#类数据成员的初始值"></a> 类数据成员的初始值</h4>
<p>在定义好<code>Screen</code>类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一组<code>Screen</code>。这个类将包含一个<code>Screen</code>类型的<code>vector</code>，每个元素表示一个特定的<code>Screen</code>。默认情况下，我们希望<code>window_mgr</code>类开始时总是拥有一个默认初始化的<code>Screen</code>。在 C++11 新标准中，最好的方式就是把这个默认值声明成一个类内初始值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//这个window_mgr追踪的Screen</span></span><br><span class="line">    <span class="comment">//默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen</span></span><br><span class="line">    std::vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>, <span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在此例中，我们使用一个单独的元素值对<code>vector</code>成员执行了列表初始化，这个<code>Screen</code>的值被传递给<code>vector&lt;Screen&gt;</code>的构造函数，从而创建了一个单元素的<code>vector</code>对象。具体地说，<code>Screen</code>的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。</p>
<p>如我们之前所知的，类内初始值必须使用 = 的初始化形式(初始化<code>Screen</code>的数据成员时所用的)或者花括号括起来的直接初始化形式(初始化<code>Screens</code>所用的)。</p>
<h4 id="连续执行的操作"><a class="markdownIt-Anchor" href="#连续执行的操作"></a> 连续执行的操作</h4>
<p>可以通过返回<code>*this</code>(返回引用)，把一系列操作连接在一条表达式中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">set</span><span class="params">(pos, pos, <span class="type">char</span>)</span></span>;</span><br><span class="line">    <span class="comment">//其他成员和之前版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    contents[cursor] = c;		<span class="comment">//设置当前光标所在位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;				<span class="comment">//将this对象作为左值返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(pos r, pos col, <span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">	contents[ r * width + col ] = ch;	<span class="comment">//设置给定位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;						<span class="comment">//将this对象作为左值返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给光标移动到一个指定的位置，然后设置该位置的字符值</span></span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="基于const的重载"><a class="markdownIt-Anchor" href="#基于const的重载"></a> 基于const的重载</h4>
<p>接下来，我们继续添加一个名为<code>display</code>的操作，它负责打印<code>Screen</code>的内容。我们希望这个函数能和<code>move</code>以及<code>set</code>出现在同一序列中，因此类似于<code>move</code>和<code>set</code>，<code>display</code>函数也应该返回执行它的对象的引用。</p>
<p>从逻辑上来说，显示一个<code>Screen</code>并不需要改变它的内容，因此我们令<code>display</code>为一个<code>const</code>成员，此时，<code>this</code>将是一个指向<code>const</code>的指针而<code>*this</code>是<code>const</code>对象。由此推断，<code>display</code>的返回类型应该是<code>const Sales_data&amp;</code>。然而，如果真的令<code>display</code>返回一个<code>const</code>的引用，则我们将不能把<code>display</code>嵌入到一组动作的序列中去:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen;</span><br><span class="line"><span class="comment">//如果display返回常量引用，则调用set将引发错误</span></span><br><span class="line">myScreen.<span class="built_in">display</span>(cout).<span class="built_in">set</span>(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>即使<code>myScreen</code>是个非常量对象，对<code>set</code>的调用也无法通过编译。问题在于<code>display</code>的<code>const</code>版本返回的是常量引用，而我们显然无权<code>set</code>一个常量对象。</p>
<p>通过区分成员函数是否是<code>const</code>的，我们可以对其进行<strong>重载</strong>，其原因与我们之前根据指针参数是否指向<code>const</code>而重载函数的原因差不多。<strong>因为非常量版本的函数对于常量对象是不可用的</strong>，所以我们只能在一一个常量对象上调用<code>const</code>成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。</p>
<p>在下面的这个例子中，我们将定义一个名为<code>do_display</code>的私有成员，由它负责打印<code>Screen</code>的实际工作。所有的<code>display</code>操作都将调用这个函数，然后返回执行操作的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//根据对象是否是const重载了display函数</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">    	</span>&#123; <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    	</span>&#123; <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//该函数负责显示Screen的内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span> </span>&#123; os &lt;&lt; contents; &#125;</span><br><span class="line">    <span class="comment">//其他函数与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和我们之前所学的一样，当一个成员调用另外一个成员时，<code>this</code>指针在其中隐式地传递。因此，当<code>display</code>调用<code>do_display</code> 时，它的<code>this</code>指针隐式地传递给<code>do_display</code>。而当<code>display</code>的非常量版本调用<code>do_display</code> 时，它的<code>this</code>指针将隐式地从指向非常量的指针转换成指向常量的指针。</p>
<p>当<code>do_display</code> 完成后，<code>display</code>函数各自返回解引用<code>this</code>所得的对象。在非常量版本中，<code>this</code>指向一个非常量对象，因此<code>display</code>返回一个普通的(非常量)引用；而<code>const</code>成员则返回一个常量引用。</p>
<p>当我们在某个对象上调用<code>display</code>时，该对象是否是<code>const</code>决定了应该调用<code>display</code>的哪个版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Screen <span class="title">myScreen</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Screen <span class="title">blank</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>).<span class="built_in">display</span>(cout);	<span class="comment">//调用非常量版本</span></span><br><span class="line">blank.<span class="built_in">display</span>(cout);				<span class="comment">//调用常量版本</span></span><br></pre></td></tr></table></figure>
<h4 id="类的声明不完全类型"><a class="markdownIt-Anchor" href="#类的声明不完全类型"></a> 类的声明(不完全类型)</h4>
<p>就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;				<span class="comment">//Screen类的声明</span></span><br></pre></td></tr></table></figure>
<p>这种声明有时被称作<strong>前向声明</strong>(forward declaration)，它向程序中引入了名字<code>Screen</code>并且指明<code>Screen</code>是一种类类型。对于类型<code>Screen</code>来说，在它声明之后定义之前是一个<strong>不完全类型</strong>(incomplete type)，也就是说，此时我们已知<code>Screen</code>是一个类类型，但是不清楚它到底包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用：<strong>可以定义指向这种类型的指针或引用，也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。</strong></p>
<p>对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员。</p>
<blockquote>
<p>一种例外的情况：直到类被定义之后数据成员才能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以<strong>一个类的成员类型不能是该类自己</strong>。</p>
</blockquote>
<p>然而，一旦一个类的名字出现后，它就被认为是声明过了(但尚未定义)，因此类允许包含指向它自身类型的引用或指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link_screen</span> &#123;</span><br><span class="line">	Screen window;</span><br><span class="line">    Link_screen *next;</span><br><span class="line">    Link_screen *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="友元再探"><a class="markdownIt-Anchor" href="#友元再探"></a> 友元再探</h3>
<p>我们的<code>Sales_data</code>类把三个普通的非成员函数定义成了友元。类还可以把其他的类定义成友元，也可以把其他类(之前已定义过的)的成员函数定义成友元。</p>
<blockquote>
<p>此外，友元函数能定义在类的内部，这样的函数是隐式内联的。但这里的水很深，别这么干。</p>
</blockquote>
<h4 id="类之间的友元关系"><a class="markdownIt-Anchor" href="#类之间的友元关系"></a> 类之间的友元关系</h4>
<p>举个友元类的例子，我们的<code>Window_mgr</code>的某些成员可能需要访问它管理的<code>Screen</code>类的内部数据。例如，假设我们需要为<code>Window_mgr</code>添加一个名为<code>clear</code>的成员，它负责把一个指定的<code>Screen</code>的内容都设为空白。为了完成这一任务，<code>clear</code>需要访问<code>Screen</code>的私有成员；而要想令这种访问合法，<code>Screen</code>需要把<code>Window_mgr</code>指定成它的友元：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="comment">//Window_mgr的成员可以访问Screen类的私有部分</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    <span class="comment">//Screen类的剩余部分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//窗口中每个屏幕的编号</span></span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="comment">//按照编号将指定的Screen重置为空白</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>, <span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//s是一个Screen的引用，指向我们想清空的那个屏幕</span></span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    <span class="comment">//计算出一个新的string对象，将选定的屏幕重置为空白</span></span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p>
<blockquote>
<p>友元关系不具有传递性。每个类负责控制自己的友元类或友元函数。</p>
</blockquote>
<h4 id="令成员函数作为友元"><a class="markdownIt-Anchor" href="#令成员函数作为友元"></a> 令成员函数作为友元</h4>
<p>除了令整个<code>Window_mgr</code>作为友元之外，<code>Screen</code>还可以只为<code>clear</code>提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="comment">//Window_mgr::clear必须在Screen类之前被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">//Screen类的剩余部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：</p>
<ul>
<li>首先定义<code>Window_mgr</code>类，其中声明<code>clear</code>函数，但是不能定义它。在<code>clear</code>使用<code>Screen</code>的成员之前必须先声明<code>Screen</code>。</li>
<li>接下来定义<code>Screen</code>，包括对于<code>clear</code>的友元声明。</li>
<li>最后定义<code>clear</code>，此时它才可以使用<code>Screen</code>的成员。</li>
</ul>
<blockquote>
<p>类和非成员函数的声明不是必须在它们的友元声明之前，当一个名字的第一次出现是在友元声明中时，我们假定其在当前作用域可见。但是，友元声明不是声明，当出现了需要事先声明时却仅采用了友元声明的情况，程序可能出错(由编译器决定)。</p>
</blockquote>
<h3 id="类的作用域"><a class="markdownIt-Anchor" href="#类的作用域"></a> 类的作用域</h3>
<h4 id="指明返回类型的归属"><a class="markdownIt-Anchor" href="#指明返回类型的归属"></a> 指明返回类型的归属</h4>
<p>一个类就是一个作用域的事实能够很好地解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名。在类的外部，成员的名字被隐藏起来了。</p>
<p>一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。</p>
<p>而<strong>函数的返回类型通常出现在函数名之前</strong>。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。例如，我们可能向<code>Window_mgr</code>类添加一个新的名为<code>addScreen</code>的函数，它负责向显示器添加一个新的屏幕。这个成员的返回类型将是<code>ScreenIndex</code>，用户可以通过它定位到指定的<code>Screen</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//向窗口添加一个Screen，返回它的编号</span></span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="type">const</span> Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">//其他成员与之前一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//首先处理返回类型，之后我们才进入Window_mgr的作用域</span></span><br><span class="line"><span class="function">Window_mgr::ScreenIndex</span></span><br><span class="line"><span class="function"><span class="title">Window_mgr::addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span>&#123;</span><br><span class="line">	screens.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为返回类型出现在类名之前，所以事实上它是位于 <code>Window_mgr</code>类的作用域之外的。在这种情况下，要想使用<code>ScreenIndex</code>作为返回类型，我们必须明确指定哪个类定义了它。</p>
<h4 id="类型名的特殊处理"><a class="markdownIt-Anchor" href="#类型名的特殊处理"></a> 类型名的特殊处理</h4>
<p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p>
<p>但是，这种两阶段的处理方式只适用于成员函数中使用的名字。<strong>声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见</strong>。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当编译器看到<code>balance</code>函数的声明语句时，它将在<code>Account</code>类的范围内寻找对<code>Money</code>的声明。编译器只考虑<code>Account</code>中在使用<code>Money</code>前出现的声明，因为没找到匹配的成员，所以编译器会接着到<code>Account</code>的外层作用域中查找。在这个例子中，编译器会找到<code>Money</code>的<code>typedef</code>语句，该类型被用作<code>balance</code>函数的返回类型以及数据成员<code>bal</code>的类型。另一方面，<code>balance</code>函数体在整个类可见后才被处理，因此，该函数的<code>return</code>语句返回名为<code>bal</code>的成员，而非外层作用域的<code>string</code>对象。</p>
<p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表种类型，则类不能在之后重新定义该名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;		<span class="comment">//使用外层作用域的Money</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> Money;				<span class="comment">//错误，不能重新定义Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip:</strong> 类型名的定义应该放在类的开始处，确保所有使用该类型的成员都出现在这之后。</p>
</blockquote>
<h4 id="区分成员名字和参数名字"><a class="markdownIt-Anchor" href="#区分成员名字和参数名字"></a> 区分成员名字和参数名字</h4>
<p>不建议使用其他成员的名字作为某个成员函数的参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;								<span class="comment">//定义了一个名字，在本小节末尾用到</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy_fcn</span><span class="params">(pos height)</span> </span>&#123;</span><br><span class="line">		cursor = width * height;		<span class="comment">//对应哪个height? 其实是参数height</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当编译器处理<code>dummy_fcn</code>中的乘法表达式时，它首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此<code>dummy_fcn</code>函数体内用到的名字<code>height</code>指的是参数声明。</p>
<p>在此例中，<code>height</code>参数隐藏了同名的成员。如果想绕开上面的查找规则，应该将代码变为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy_fcn</span><span class="params">(pos height)</span> </span>&#123;</span><br><span class="line">		cursor = width * <span class="keyword">this</span>-&gt;height;		<span class="comment">//对应成员height</span></span><br><span class="line">        <span class="comment">//另一种表示该成员方式</span></span><br><span class="line">        curosr = width * Screen::height;	<span class="comment">//对应成员height</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显式地使用this指针来强制访问成员。</p>
<p>但尽量规避这种情况，成员函数中的名字不要隐藏同名的成员。</p>
</blockquote>
<blockquote>
<p>如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。在我们的例子中，名字height定义在外层作用域中，且位于screen的定义之前。然而，外层作用域中的对象被名为height的成员隐藏掉了。因此，如果我们需要的是外层作用域中的名字，可以显式地通过作用域运算符来进行请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span> </span>&#123;</span><br><span class="line">	cursor = width * ::height;			<span class="comment">//对应全局的height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但尽量规避这种情况，不要隐藏外层作用域可能用到的名字。</p>
</blockquote>
<h4 id="考虑成员函数定义之前的全局作用域"><a class="markdownIt-Anchor" href="#考虑成员函数定义之前的全局作用域"></a> 考虑成员函数定义之前的全局作用域</h4>
<p>当成员定义在类的外部时，名字查找不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(pos)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Screen::pos <span class="title">verify</span><span class="params">(Screen::pos)</span></span>;		<span class="comment">//这是个全局函数的声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::setHeight</span><span class="params">(pos var)</span> </span>&#123;</span><br><span class="line">    height = <span class="built_in">verify</span>(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，全局函数<code>verify</code>的声明在<code>Screen</code>类的定义之前是不可见的。然而，名字查找包括了成员函数出现之前的全局作用域。在此例中，<code>verify</code>的声明位于<code>setHeight</code>的定义之前，因此可以被正常使用。</p>
<h3 id="构造函数再探"><a class="markdownIt-Anchor" href="#构造函数再探"></a> 构造函数再探</h3>
<h4 id="初始值列表"><a class="markdownIt-Anchor" href="#初始值列表"></a> 初始值列表</h4>
<p>如果成员是<code>const</code>、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。</p>
<p><strong>成员初始化顺序</strong></p>
<p>构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。</p>
<p>成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p>
<p>一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//未定义的：i在j之前被初始化</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最好令构造函数初始值与成员声明顺序保持一致。</p>
</blockquote>
<p><strong>默认实参</strong></p>
<p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义默认构造函数，令其与只接受一个string实参的构造函数功能相同</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s = <span class="string">&quot;&quot;</span>) : <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="委托构造函数"><a class="markdownIt-Anchor" href="#委托构造函数"></a> 委托构造函数</h4>
<p>C++11 新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的<strong>委托构造函数</strong>(delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。</p>
<p>和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个<strong>唯一的入口</strong>，就是<strong>类名本身</strong>。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。</p>
<p>举个例子，我们使用委托构造函数重写<code>Sales_data</code>类，重写后的形式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price) : </span><br><span class="line">    	<span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt*price) &#123; &#125;</span><br><span class="line">    <span class="comment">//其余构造函数全都委托给另一个构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() : <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s) : <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) : <span class="built_in">Sales_data</span>() &#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">//其他成员与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个<code>Sales_data</code>类中，除了一个构造函数外其他的都委托了它们的工作。第一个构造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。</p>
<p>我们定义默认构造函数，其委托三参数的构造函数完成初始化过程，它也无须执行其他任务，这一点从空的构造函数体能看得出来。</p>
<p>接受一个<code>string</code>的构造函数同样委托给了三参数的版本。</p>
<p>接受<code>istream&amp;</code>的构造函数也是委托构造函数，它委托给了默认构造函数，默认构造函数又接着委托给三参数构造函数。当这些受委托的构造函数执行完后，接着执行<code>istream&amp;</code>构造函数体的内容。它的构造函数体调用<code>read</code>函数读取给定的<code>istream</code>。</p>
<blockquote>
<p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在Sales_data类中，受委托的构造函数体恰好是空的。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。</p>
</blockquote>
<h4 id="使用默认构造函数"><a class="markdownIt-Anchor" href="#使用默认构造函数"></a> 使用默认构造函数</h4>
<p>下面的<code>obj</code>的声明可以正常编译通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>;							<span class="comment">//正确，定义了一个函数而非对象</span></span><br><span class="line"><span class="keyword">if</span> (obj.<span class="built_in">isbn</span>() == Primer_5th_ed.<span class="built_in">isbn</span>() )	<span class="comment">//错误，obj是一个函数</span></span><br></pre></td></tr></table></figure>
<p>但当我们试图使用<code>obj</code>时，编译器将报错，提示我们不能对函数使用成员访问运算符问题在于，尽管我们想声明一个默认初始化的对象，<code>obj</code>实际的含义却是一个不接受任何参数的函数并且其返回值是<code>Sales_data</code>类型的对象。</p>
<p>如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空的括号对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data obj;					<span class="comment">//正确，obj是个默认初始化的对象</span></span><br></pre></td></tr></table></figure>
<h4 id="隐式的类型转换"><a class="markdownIt-Anchor" href="#隐式的类型转换"></a> 隐式的类型转换</h4>
<p>之前曾经介绍过 C++ 语言在内置类型之间定义了几种自动转换规则。同样的，我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作<strong>转换构造函数</strong>(converting constructor)。</p>
<blockquote>
<p>即能通过一个实参调用的构造函数定义一条从该参数类型向类类型隐式转换的规则。</p>
</blockquote>
<p>在<code>Sales_data</code>类中，接受<code>string</code>的构造函数和接受<code>istream</code>的构造函数分别定义了从这两种类型向<code>Sales_data</code>隐式转换的规则。也就是说，在需要使用<code>Sales_data</code>的地方，我们可以使用<code>string</code>或者<code>istream</code>作为替代：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;</span><br><span class="line"><span class="comment">//构造一个临时的Sales_data对象</span></span><br><span class="line"><span class="comment">//该对象的units_sold和revenue等于0,bookNo等于null_book</span></span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br></pre></td></tr></table></figure>
<p>在这里我们用一个<code>string</code>实参调用了<code>Sales_data</code>的<code>combine</code>成员。该调用是合法的，编译器用给定的<code>string</code>自动创建了一个<code>Sales_data</code>对象。新生成的这个(临时)<code>Sales_data</code>对象被传递给<code>combine</code>。因为<code>combine</code>的参数是一个常量引用，所以我们可以给该参数传递一个临时量。</p>
<blockquote>
<p><strong>Note:</strong> <strong>Luv</strong>实测，类似combine函数，如果使用的参数是引用，则必须指定为const，否则报错。</p>
</blockquote>
<h5 id="只允许一步类类型转换"><a class="markdownIt-Anchor" href="#只允许一步类类型转换"></a> 只允许一步类类型转换</h5>
<blockquote>
<p>因为历史原因以及为了与C语言兼容，字符串字面值与标准库string类型不是同一种类型。</p>
</blockquote>
<p>编译器只会自动地执行一步类型转换。例如，因为下面的代码隐式地使用了两种转换规则，所以它是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：需要用户定义的两种转换</span></span><br><span class="line"><span class="comment">//(1)把&quot;9-999-99999-9&quot;转换成string</span></span><br><span class="line"><span class="comment">//(2)再把这个(临时的)string转换成Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999-99999-9&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们想完成上述调用，可以显式地把字符串转换成<code>string</code>或者<code>Sales_data</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，显式地转换成string，隐式地转换成Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br><span class="line"><span class="comment">//正确，隐式地转换成string，显式地转换成Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br></pre></td></tr></table></figure>
<h5 id="抑制构造函数定义的隐式转换"><a class="markdownIt-Anchor" href="#抑制构造函数定义的隐式转换"></a> 抑制构造函数定义的隐式转换</h5>
<p>在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为<strong>explicit</strong>加以阻止：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> : bookNo(s) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">//其他成员与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时，没有任何构造函数能用于隐式地创建<code>Sales_data</code>对象，之前的用法都无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.<span class="built_in">combine</span>(null_book);		<span class="comment">//错误，string构造函数是explicit的</span></span><br><span class="line">item.<span class="built_in">combine</span>(cin);				<span class="comment">//错误，istream构造函数是explicit的</span></span><br></pre></td></tr></table></figure>
<p>关键字<code>explicit</code>只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为<code>explicit</code>的。只能在类内声明构造函数时使用<code>explicit</code>关键字，在类外部定义时不应重复：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误，explicit关键字只允许出现在类内的构造函数声明处</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data::Sales_data</span><span class="params">(istream&amp; is)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>explicit构造函数只能用于直接初始化</strong></p>
<p>发生隐式转换的一种情况是执行拷贝形式的初始化(使用 = 初始化)。此时，我们只能使用直接初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>;	<span class="comment">//正确，直接初始化</span></span><br><span class="line"><span class="comment">//错误，不能将explicit构造函数用于拷贝形式的初始化过程</span></span><br><span class="line">Sales_data item2 = null_book;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="显式地使用构造函数进行转换"><a class="markdownIt-Anchor" href="#显式地使用构造函数进行转换"></a> 显式地使用构造函数进行转换</h5>
<p>尽管编译器不会将<code>explicit</code>的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制进行转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，实参是一个显式构造的Sales_data对象</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line"><span class="comment">//正确，static_cast可以使用explicit的构造函数</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></figure>
<p>在第一个调用中，我们直接使用<code>Sales_data</code>的构造函数，该调用通过接受<code>string</code>的构造函数创建了一个临时的<code>Sales_data</code>对象。在第二个调用中，我们使用<code>static_cast</code>执行了显式的而非隐式的转换。其中<code>static_cast</code>使用<code>istream</code>构造函数创建了一个临时的<code>Sales_data</code>对象。</p>
<blockquote>
<p><strong>标准库中含有显式构造函数的类</strong></p>
<p>我们用过的一些标准库中的类含有单参数的构造函数：</p>
<ul>
<li>接受一个单参数的const char*的string构造函数不是explicit的。</li>
<li>接受一个容量参数的vector构造函数是explicit的。</li>
</ul>
</blockquote>
<h4 id="聚合类"><a class="markdownIt-Anchor" href="#聚合类"></a> 聚合类</h4>
<p><strong>聚合类</strong>(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：</p>
<ul>
<li>所有成员都是<strong>public</strong>的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值。</li>
<li>没有基类，也没有<strong>virtual</strong>函数(在很后面介绍)。</li>
</ul>
<p>例如，下面的类是一个聚合类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vall.ival = 0; vall.s = string(&quot;Anna&quot;)</span></span><br><span class="line">Data val1 = &#123; <span class="number">0</span>, <span class="string">&quot;Anna&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。下面的例子是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误，不能使用&quot;anna&quot;初始化ival，也不能使用1024初始化s</span></span><br><span class="line">Data val2 = &#123; <span class="string">&quot;Anna&quot;</span>, <span class="number">1024</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。</p>
<blockquote>
<p>值得注意的是，显式地初始化类的对象的成员存在三个明显的缺点：</p>
<ul>
<li>要求类的所有成员都是public的。</li>
<li>将正确初始化每个对象的每个成员的重任交给了类的用户(而非类的作者)。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。</li>
<li>添加或删除一个成员之后，所有的初始化语句都需要更新。</li>
</ul>
</blockquote>
<h4 id="字面值常量类"><a class="markdownIt-Anchor" href="#字面值常量类"></a> 字面值常量类</h4>
<p>我们提到过<code>constexpr</code>函数的参数和返回值必须是字面值类型。除了算术类型、引用和指针外，某些类也是字面值类型。和其他类不同，字面值类型的类可能含有<code>constexpr</code>函数成员。这样的成员必须符合<code>constexpr</code>函数的所有要求，它们是隐式<code>const</code>的。</p>
<p>数据成员都是字面值类型的聚合类是字面值常量类。</p>
<p>而如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类:</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个<code>constexpr</code>构造函数。</li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li>
</ul>
<p><strong>constexpr构造函数</strong></p>
<p>尽管构造函数不能是<code>const</code>的，但是字面值常量类的构造函数可以是<code>constexpr</code>函数。事实上，一个字面值常量类必须至少提供一个<code>constexpr</code>构造函数。</p>
<p><code>constexpr</code>构造函数可以声明成 <code>= default</code> 的形式或者是<strong>删除函数</strong>的形式(这个后面讲)。否则，<code>constexpr</code>构造函数就必须既符合构造函数的要求(意味着不能包含返回语句)，又符合<code>constexpr</code>函数的要求(意味着它能拥有的唯一可执行语句就是返回语句)。综合这两点可知，<code>constexpr</code>构造函数体一般来说应该是空的。我们通过前置关键字<code>constexpr</code>就可以声明一个<code>constexpr</code>构造函数了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b = <span class="literal">true</span>)</span> : hw(b), io(b), other(b) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> h, <span class="type">bool</span> i, <span class="type">bool</span> o)</span> : </span></span><br><span class="line"><span class="function">    	hw(h), io(i), other(o) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">any</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hw || io || other; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_io</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; io = b; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_hw</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; hw = b; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_other</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; other = b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> hw;				<span class="comment">//硬件错误，而非IO错误</span></span><br><span class="line">    <span class="type">bool</span> io;				<span class="comment">//IO错误</span></span><br><span class="line">    <span class="type">bool</span> other;				<span class="comment">//其他错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>constexpr</code>构造函数必须初始化所有数据成员，初始值或者使用<code>constexpr</code>构造函数，或者是一条常量表达式。</p>
<p><code>constexpr</code>构造函数用于生成<code>constexpr</code>对象以及<code>constexpr</code>函数的参数或返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span></span>;			<span class="comment">//调试IO</span></span><br><span class="line"><span class="keyword">if</span> (io_sub.<span class="built_in">any</span>())									<span class="comment">//等价于if(true)</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;print appropriate error messages&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>;						<span class="comment">//无调试</span></span><br><span class="line"><span class="keyword">if</span> (io_sub.<span class="built_in">any</span>())									<span class="comment">//等价于if(false)</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;print an error message&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="类的静态成员"><a class="markdownIt-Anchor" href="#类的静态成员"></a> 类的静态成员</h3>
<p>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。</p>
<h4 id="声明静态成员"><a class="markdownIt-Anchor" href="#声明静态成员"></a> 声明静态成员</h4>
<p>我们通过在成员的声明之前加上关键字<code>static</code>使得其与类关联在一起。和其他成员一样，静态成员可以是<code>public</code>的或<code>private</code>的。静态数据成员的类型可以是常量、引用、指针、类类型等。</p>
<p>举个例子，我们定义一个类，用它表示银行的账户记录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个<code>Account</code>对象将包含两个数据成员:<code>owner</code>和<code>amount</code>。只存在一个<code>interestRate</code>对象而且它被所有<code>Account</code>对象共享。</p>
<p>类似的，静态成员函数也不与任何对象绑定在一起，它们不包含<code>this</code>指针。作为结果，<strong>静态成员函数</strong>不能声明成<code>const</code>的，而且我们也不能在<code>static</code>函数体内使用<code>this</code>指针。这一限制既适用于<code>this</code>的显式使用，也对调用<strong>非静态成员的隐式使用</strong>有效。</p>
<h4 id="使用类的静态成员"><a class="markdownIt-Anchor" href="#使用类的静态成员"></a> 使用类的静态成员</h4>
<p>我们使用作用域运算符直接访问静态成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>();			<span class="comment">//使用作用域运算符访问静态成员</span></span><br></pre></td></tr></table></figure>
<p>虽然静态成员不属于类的某个对象，但是我们仍然能够使用类的对象、引用或指针来访问静态成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">//调用静态成员函数rate的等价形式</span></span><br><span class="line">r = ac1.<span class="built_in">rate</span>();				<span class="comment">//通过Account的对象或引用</span></span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>();			<span class="comment">//通过指向Account对象的指针</span></span><br></pre></td></tr></table></figure>
<p>成员函数使用静态成员不需要通过作用域运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount == amount * interestRate; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="comment">//其他成员与之前一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义静态成员"><a class="markdownIt-Anchor" href="#定义静态成员"></a> 定义静态成员</h4>
<p>和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复<code>static</code>关键字，该关键字只出现在类内部的声明语句:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Account::rate</span><span class="params">(<span class="type">double</span> newRate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    interestRate = newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。</p>
</blockquote>
<p>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。<strong>这意味着它们不是由类的构造函数初始化的</strong>。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须<strong>在类的外部定义和初始化每个静态成员</strong>。和其他对象一样，一个静态数据成员只能定义一次。</p>
<p>类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。</p>
<p>我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义并初始化一个静态成员</span></span><br><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></table></figure>
<p>这条语句定义了名为 <code>interestRate</code>的对象，该对象是类<code>Account</code>的静态成员，其类型是<code>double</code>。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以直接使用<code>initRate</code>函数。注意，虽然<code>initRate</code>是私有的，我们也能用它初始化<code>interestRate</code>。和其他成员的定义一样，<code>interestRate</code>的定义也可以访问类的私有成员。</p>
<blockquote>
<p>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。</p>
</blockquote>
<h4 id="静态成员的类内初始化"><a class="markdownIt-Anchor" href="#静态成员的类内初始化"></a> 静态成员的类内初始化</h4>
<p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供<code>const</code>整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的<code>constexpr</code>(或<code>const</code>)。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员指定数组成员的维度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interstRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>;		<span class="comment">//period是常量表达式</span></span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> <strong>LUV</strong>测试，如果此时period改为在外部定义、内部声明，编译会出错。</p>
</blockquote>
<p>如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的<code>const</code>和<code>constexpr static</code>不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。</p>
<p>例如，如果<code>period</code>的唯一用途就是定义<code>daily_tbl</code>的维度，则不需要在<code>Account</code>外面专门定义<code>period</code>。此时，如果我们忽略了这个限制，那么对程序非常微小的改动也可能造成编译错误，因为程序找不到该成员的定义语句。举个例子，当需要把<code>Account::period</code>传递给一个接受<code>const int&amp;</code>的函数时，必须定义<code>period</code>。</p>
<p>如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Acocunt::period;			<span class="comment">//初始值在类的定义内提供</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip:</strong> 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p>
</blockquote>
<h4 id="静态成员的运用场景"><a class="markdownIt-Anchor" href="#静态成员的运用场景"></a> 静态成员的运用场景</h4>
<p>如我们所见，静态成员独立于任何对象。因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常地使用。举个例子，静态数据成员可以是<strong>不完全类型</strong>。特别的，静态数据成员的类型可以就是<strong>它所属的类类型</strong>。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Bar mem1;			<span class="comment">//正确，静态成员可以是不完全类型</span></span><br><span class="line">    Bar *mem2;					<span class="comment">//正确，指针成员可以是不完全类型</span></span><br><span class="line">    Bar mem3;					<span class="comment">//错误，数据成员必须是完全类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bkground表示一个稍后定义(可以在类内也可以在类外)的静态成员</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="type">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> bkground;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Screen::bkground = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。</p>
<h2 id="io库"><a class="markdownIt-Anchor" href="#io库"></a> IO库</h2>
<h3 id="io类"><a class="markdownIt-Anchor" href="#io类"></a> IO类</h3>
<p>到目前为止，我们已经使用过的<strong>IO</strong>类型和对象都是操纵<code>char</code>数据的。默认情况下这些对象都是关联到用户的控制台窗口的。当然，我们不能限制实际应用程序仅从控制窗口进行<strong>IO</strong>操作，应用程序常常需要读写命名文件。而且，使用<strong>IO</strong>操作处理<code>string</code>的字符会很方便。此外，应用程序还可能读写需要宽字符支持的语言。</p>
<p>为了支持这些不同种类的<strong>IO</strong>处理操作，在<code>istream</code>和<code>ostream</code>之外，标准库还定义了其他一些<strong>IO</strong>类型，我们之前都已经使用过了。下表列出了这些类型，分别定义三个独立的头文件中：<code>iostream</code>定义了用于读写流的基本类型，<code>fstream</code>定义了读命名文件的类型，<code>sstream</code>定义了读写内存<code>string</code>对象的类型。</p>
<table>
<thead>
<tr>
<th style="text-align:center">头文件</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iostream</td>
<td style="text-align:center">istream, wistream</td>
<td style="text-align:center">从流读取数据</td>
</tr>
<tr>
<td style="text-align:center">iostream</td>
<td style="text-align:center">ostream, wostream</td>
<td style="text-align:center">向流写入数据</td>
</tr>
<tr>
<td style="text-align:center">iostream</td>
<td style="text-align:center">iostream, wiostream</td>
<td style="text-align:center">读写流</td>
</tr>
<tr>
<td style="text-align:center">fstream</td>
<td style="text-align:center">ifstream, wifstream</td>
<td style="text-align:center">从文件读取数据</td>
</tr>
<tr>
<td style="text-align:center">fstream</td>
<td style="text-align:center">ofstream, wofstream</td>
<td style="text-align:center">向文件写入数据</td>
</tr>
<tr>
<td style="text-align:center">fstream</td>
<td style="text-align:center">fstream, wfstream</td>
<td style="text-align:center">读写文件</td>
</tr>
<tr>
<td style="text-align:center">sstream</td>
<td style="text-align:center">istringstream, wistringstream</td>
<td style="text-align:center">从<code>string</code>读取数据</td>
</tr>
<tr>
<td style="text-align:center">sstream</td>
<td style="text-align:center">ostringstream, wostringstream</td>
<td style="text-align:center">向<code>string</code>写入数据</td>
</tr>
<tr>
<td style="text-align:center">sstream</td>
<td style="text-align:center">stringstream, wstringstream</td>
<td style="text-align:center">读写<code>string</code></td>
</tr>
</tbody>
</table>
<p><strong>IO类型间的关系</strong></p>
<p>概念上，设备类型和字符大小都不会影响我们要执行的<strong>IO</strong>操作。例如，我们可以用 &gt;&gt; 读取数据，而不用管是从一个控制台窗口，一个磁盘文件，还是一个<code>string</code>读取。类似的，我们也不用管读取的字符能否存入一个<code>char</code>对象内，还是需要一个<code>wchar_t</code>对象来存储。</p>
<p>标准库使我们能忽略这些不同类型的流之间的差异，这是通过<strong>继承机制</strong>(inheritance)实现的。利用模板，我们可以使用具有继承关系的类，而不必解继承机制如何工作的细节。</p>
<p>简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以<strong>将一个派生类(继承类)对象当作其基类(所继承的类)对象来使用</strong>。</p>
<p>类型<code>ifstream</code>和 <code>istringstream</code>都继承自<code>istream</code>。因此，我们可以像使用<code>istream</code>对象一样来使用<code>ifstream</code>和<code>istringstream</code>对象。也就是说，我们是如何使用<code>cin</code>的，就可以同样地使用这些类型的对象。例如，可以对一个<code>ifstream</code>和<code>istringstream</code>对象调用<code>getline</code>，也可以使用 &gt;&gt; 从一个<code>ifstream</code>或<code>istringstream</code>对象中读取数据。类似的，类型<code>ofstream</code>和<code>ostringstream</code>都继承自<code>ostream</code>。因此，我们是如何使用<code>cout</code>的，就可以同样地使用这些类型的对象。</p>
<blockquote>
<p>以下的标准库流特性都可以无差别地应用于普通流、文件流和string流，以及char或宽字符流版本。</p>
</blockquote>
<h4 id="io对象无拷贝和赋值"><a class="markdownIt-Anchor" href="#io对象无拷贝和赋值"></a> IO对象无拷贝和赋值</h4>
<p>不能拷贝或对<strong>IO</strong>对象赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;					<span class="comment">//错误，不能对流对象赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;		<span class="comment">//错误，不能将流直接设为函数的返回类型或参数(引用可以)</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);				<span class="comment">//错误，不能拷贝流对象</span></span><br></pre></td></tr></table></figure>
<p>由于不能拷贝<strong>IO</strong>对象，因此我们也不能将形参或返回类型设置为流类型。进行<strong>IO</strong>操作的函数通常以引用方式传递和返回流。读写一个<strong>IO</strong>对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</p>
<h4 id="条件状态"><a class="markdownIt-Anchor" href="#条件状态"></a> 条件状态</h4>
<p><strong>IO</strong>操作一个与生俱来的问题就是可能发生错误。一些错误是可恢复的，而其他错误则发生在系统深处，已经超出了应用程序可以修正的范围。下表列出了<strong>IO</strong>类所定义的一些函数和标志，可以帮助我们访问和操纵流的<strong>条件状态</strong>(condition state)。</p>
<blockquote>
<p><code>strm</code>是前一个表格中的某种<strong>IO</strong>类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>IO库条件状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">strm :: iostate</td>
<td>iostate是一种机器相关的类型，提供了表达条件状态的完整功能</td>
</tr>
<tr>
<td style="text-align:center">strm :: badbit</td>
<td>用来指出流已崩溃</td>
</tr>
<tr>
<td style="text-align:center">strm :: failbit</td>
<td>用来指出一个IO操作失败了</td>
</tr>
<tr>
<td style="text-align:center">strm :: eofbit</td>
<td>用来指出流到达了文件结束</td>
</tr>
<tr>
<td style="text-align:center">strm :: goodbit</td>
<td>用来指出流未处于错误状态(此时为0)</td>
</tr>
<tr>
<td style="text-align:center">s.eof()</td>
<td>若流s的eofbit置位(置为1)，则返回true</td>
</tr>
<tr>
<td style="text-align:center">s.fail()</td>
<td>若流s的failbit或badbit置位，则返回true</td>
</tr>
<tr>
<td style="text-align:center">s.bad()</td>
<td>若流s的badbit置位，则返回true</td>
</tr>
<tr>
<td style="text-align:center">s.good()</td>
<td>若流处于有效状态，则返回true</td>
</tr>
<tr>
<td style="text-align:center">s.clear()</td>
<td>将流中所有条件状态位复位，将流的状态设置为有效。返回void</td>
</tr>
<tr>
<td style="text-align:center">s.clear(flags)</td>
<td>根据给定的flags标志位，将流s中对应的条件状态位复位。flags的类型为strm::iostate。返回void</td>
</tr>
<tr>
<td style="text-align:center">s.setstate(flags)</td>
<td>根据给定的flags标志位，将流s中对应的条件状态位置位。flags的类型为strm::iostate。返回void</td>
</tr>
<tr>
<td style="text-align:center">s.rdstate()</td>
<td>返回流s的当前条件状态，返回值类型为strm::iostate</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一个流一旦发生错误，其后续的<strong>IO</strong>操作都会失败。</p>
</blockquote>
<h5 id="查询流的状态"><a class="markdownIt-Anchor" href="#查询流的状态"></a> 查询流的状态</h5>
<p><strong>IO</strong>库定义了一个与机器无关的<code>iostate</code>类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用。<strong>IO</strong>库定义了<strong>4</strong>个<code>iostate</code>类型的<code>constexpr</code>值表示特定的位模式。这些值用来表示特定类型的<strong>IO</strong>条件，可以与位运算符一起使用来一次性检测或设置多个标志位。</p>
<p><code>badbit</code>表示系统级错误，如不可恢复的读写错误。通常情况下，一旦<code>badbit</code>被置位，流就无法再使用了。</p>
<p>在发生可恢复错误后，<code>failbit</code>被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。</p>
<p>如果到达文件结束位置，<code>eofbit</code>和<code>failbit</code>都会被置位。<code>goodbit</code>的值为<strong>0</strong>，表示流未发生错误。</p>
<p>如果<code>badbit</code>、<code>failbit</code>和 <code>eofbit</code>任一个被置位，则检测流状态的条件会失败。</p>
<p>标准库还定义了一组函数来查询这些标志位的状态。操作<code>good</code>在所有错误位均未置位的情况下返回<code>true</code>，而<code>bad</code>、<code>fail</code>和<code>eof</code>则在对应错误位被置位时返回<code>true</code>。此外，在 <code>badbit</code>被置位时，<code>fail</code>也会返回<code>true</code>。这意味着，使用<code>good</code>或<code>fail</code>是<strong>确定流的总体状态</strong>的正确方法。实际上，我们将流当作条件使用的代码就等价于 <code>!fail()</code> 。而<code>eof</code>和<code>bad</code>操作只能表示特定的错误。</p>
<h5 id="管理流的状态"><a class="markdownIt-Anchor" href="#管理流的状态"></a> 管理流的状态</h5>
<p>流对象的<code>rdstate</code>成员返回一个<code>iostate</code>值，对应流的当前状态。<code>setstate</code>操作将给定条件位置位，表示发生了对应错误。<code>clear</code>成员是一个重载的成员：它有一个不接受参数的版本，而另一个版本接受一个<code>iostate</code>类型的参数。</p>
<p><code>clear</code>不接受参数的版本清除(复位)所有错误标志位。执行<code>clear()</code>后，调用<code>good</code>会返回<code>true</code>。我们可以这样使用这些成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记住cin的当前状态</span></span><br><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();		<span class="comment">//记住cin的当前状态</span></span><br><span class="line">cin.<span class="built_in">clear</span>();						<span class="comment">//使cin有效</span></span><br><span class="line"><span class="built_in">process_input</span>(cin);					<span class="comment">//使用cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);			<span class="comment">//将cin置为原有状态</span></span><br></pre></td></tr></table></figure>
<p>带参数的<code>clear</code>版本接受一个<code>iostate</code>值，表示流的新状态。为了复位单一的条件状态位，我们首先用<code>rdstate</code>读出当前条件状态，然后用位操作将所需位复位来生成新的状态。例如，下面的代码将<code>failbit</code>和 <code>badbit</code>复位，但保持<code>eofbit</code>不变:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复位failbit和badbit，保持其他标志位不变</span></span><br><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Luv的补充：</strong></p>
<p>看完书中这一段，并没有完全明白这一块的具体实现原理。再详细补充一些内容：</p>
<p>第一，是<code>failbit</code>，<code>badbit</code>，<code>eofbit</code>三个标记位组成了流状态，而非<code>failbit</code>、<code>badbit</code>、<code>eofbit</code>、<code>goodbit</code>这四个标记位。</p>
<p>第二，<code>strm::failbit</code>、<code>strm::badbit</code>、<code>strm::eofbit</code>、<code>strm::goodbit</code> (<em>strm</em>表示某个<strong>IO</strong>类，可以用<code>ios</code>替代)均为常量，各自表示一种流状态，称为“<strong>状态标记位常量</strong>”。</p>
<p>以上两点可结合为下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">failbit标记位的值</th>
<th style="text-align:center">eofbit标记位的值</th>
<th style="text-align:center">badbit标记位的值</th>
<th style="text-align:center">转化为10进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">strm::failbit</td>
<td style="text-align:center">输入（输出）流出现非致命错误，可挽回</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">strm::eofbit</td>
<td style="text-align:center">已经到达文件尾</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">strm::badbit</td>
<td style="text-align:center">输入（输出）流出现致命错误，不可挽回</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">strm::goodbit</td>
<td style="text-align:center">流状态完全正常</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p><code>clear()</code>函数作用是将流状态设置成括号内参数所代表的状态，强制覆盖掉流的原状态。</p>
<p><code>setstate()</code>函数并不强制覆盖流的原状态，而是将括号内参数所代表的状态叠加到原始状态上。</p>
</blockquote>
<h4 id="管理输出缓冲"><a class="markdownIt-Anchor" href="#管理输出缓冲"></a> 管理输出缓冲</h4>
<p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">&quot;please enter a value: &quot;</span>;</span><br></pre></td></tr></table></figure>
<p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。</p>
<p>导致缓冲刷新(即数据真正写到输出设备或文件)的原因有很多：</p>
<ul>
<li>程序正常结束，作为<code>main</code>函数的<code>return</code>操作的一部分，缓冲刷新被执行。</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如<code>endl</code>来显式刷新缓冲区。</li>
<li>在每个输出操作之后，我们可以用操纵符<code>unitbuf</code>设置流的内部状态，来清空缓冲区。默认情况下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此写到<code>cerr</code>的内容都是立即刷新的。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>。因此，读<code>cin</code>或写<code>cerr</code>都会导致<code>cout</code>的缓冲区被刷新。</li>
</ul>
<h5 id="刷新输出缓冲区"><a class="markdownIt-Anchor" href="#刷新输出缓冲区"></a> 刷新输出缓冲区</h5>
<p>我们已经使用过操纵符<code>endl</code>，它完成换行并刷新缓冲区的工作。<strong>IO</strong>库中还有两个类似的操纵符：<code>flush</code>和<code>ends</code>。<code>flush</code>刷新缓冲区，但不输出任何额外的字符；<code>ends</code>向缓冲区插入一个空字符，然后刷新缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; endl;			<span class="comment">//输出hi和一个换行，然后刷新缓冲区</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; flush;			<span class="comment">//输出hi，然后刷新缓冲区，不附加任何额外字符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; ends;			<span class="comment">//输出hi和一个空字符，然后刷新缓冲区</span></span><br></pre></td></tr></table></figure>
<h5 id="unitbuf操纵符"><a class="markdownIt-Anchor" href="#unitbuf操纵符"></a> unitbuf操纵符</h5>
<p>如果想在每次输出操作后都刷新缓冲区，我们可以使用<code>unitbuf</code>操纵符。它告诉流在接下来的每次写操作之后都进行一次<code>flush</code>操作。而<code>nounitbuf</code>操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;				<span class="comment">//所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line"><span class="comment">//任何输出都立即刷新，无缓冲</span></span><br><span class="line">cout &lt;&lt; nonunitbuf;				<span class="comment">//回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果程序崩溃，输出缓冲区不会被刷新。</p>
</blockquote>
<h5 id="关联输入流和输出流"><a class="markdownIt-Anchor" href="#关联输入流和输出流"></a> 关联输入流和输出流</h5>
<p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将<code>cout</code>和<code>cin</code>关联在一起，因此下面语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; ival;</span><br></pre></td></tr></table></figure>
<p>导致<code>cout</code>缓冲区被刷新。</p>
<p>一个流对象使用成员函数<code>tie</code>，可以用来为其绑定输出流，有两个重载的版本：</p>
<ul>
<li>不带参数，返回指向输出流的指针(当该对象未关联到流，返回空指针)。</li>
<li>接受一个指向<code>ostream</code>的指针，将自己关联到此<code>ostream</code>。即，<code>x.tie(&amp;o)</code>将流<code>x</code>关联到输出流<code>o</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//old_tie指向当前关联到cin的流(如果有的话)</span></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);	<span class="comment">//cin不再与其他流关联</span></span><br><span class="line"><span class="comment">//将cin与cerr关联</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);				<span class="comment">//读取cin会刷新cerr而不是cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie);			<span class="comment">//重建cin和cout间的正常关联</span></span><br></pre></td></tr></table></figure>
<h3 id="文件输入输出"><a class="markdownIt-Anchor" href="#文件输入输出"></a> 文件输入输出</h3>
<p>除了继承自<code>iostream</code>类型的行为之外，<code>fstream</code>中定义的类型还增加了一些新成员来管理与流关联的文件。在下表中列出了这些操作，我们可以对<code>fstream</code>，<code>ifstream</code>和<code>ofstream</code>对象调用这些操作，但不能对其他<strong>IO</strong>类型调用这些操作。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>fstream特有的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>fstream</em> fstrm;</td>
<td>创建一个未绑定的文件流。<em>fstream</em>是头文件<code>fstream</code>中定义的一个类型</td>
</tr>
<tr>
<td style="text-align:center"><em>fstream</em> fstrm(s);</td>
<td>创建一个<em>fstream</em>，并打开名为<code>s</code>的文件。<code>s</code>可以是<code>string</code>类型,或者是一个指向C风格字符串的指针。这些构造函数都是<code>explicit</code>的。默认的文件模式<code>mode</code>依赖于 <code>fstream</code>的类型</td>
</tr>
<tr>
<td style="text-align:center"><em>fstream</em> fstrm(s, mode);</td>
<td>与前一个构造函数类似，但按指定的<code>mode</code>打开文件</td>
</tr>
<tr>
<td style="text-align:center">fstrm.open(s)</td>
<td>打开名为<code>s</code>的文件，并将文件与<code>fstrm</code>绑定。<code>s</code>可以是一个<code>string</code>或一个指向C风格字符串的指针。默认的文件<code>mode</code>依赖于<em>fstream</em>的类型。返回<code>void</code></td>
</tr>
<tr>
<td style="text-align:center">fstrm.close()</td>
<td>关闭与<code>fstrm</code>绑定的文件。返回<code>void</code></td>
</tr>
<tr>
<td style="text-align:center">fstrm.is_open()</td>
<td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody>
</table>
<h4 id="使用文件流对象"><a class="markdownIt-Anchor" href="#使用文件流对象"></a> 使用文件流对象</h4>
<p>当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。每个文件流类都定义了一个名为<code>open</code>的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。</p>
<p>创建文件流对象时，我们可以提供文件名(可选的)。如果提供了一个文件名，则<code>open</code>会自动被调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;				<span class="comment">//构造一个</span></span><br><span class="line">ostream out;					<span class="comment">//输出文件流未关联到任何文件</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个输入流<code>in</code>，它被初始化为从文件读取数据，文件名由<code>string</code>类型的参数<code>ifile</code>指定。第二条语句定义了一个输出流<code>out</code>，未与任何文件关联。在新 C++ 标准中，文件名既可以是库类型<code>string</code>对象，也可以是C风格字符数组。旧版本的标准库只允许C风格字符数组。</p>
<h5 id="用fstream代替iostream"><a class="markdownIt-Anchor" href="#用fstream代替iostream"></a> 用fstream代替iostream&amp;</h5>
<p>在要求使用基类型对象的地方，我们可以用继承类型的对象来替代。这意味着，接受一个<code>iostream</code>类型引用(或指针)参数的函数，可以用一个对应的<code>fstream</code>(或<code>sstream</code>)类型来调用。也就是说，如果有一个函数接受一个<code>ostream&amp;</code>参数，我们在调用这个函数时，可以传递给它一个<code>ofstream</code>对象，对<code>istream&amp;</code>和<code>ifstream</code>也是类似的。</p>
<p>例如，我们可以用前面定义的的<code>read</code>和<code>print</code>函数来读写命名文件。在本例中，我们假定输入和输出文件的名字是通过传递给<code>main</code>函数的参数来指定的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>])</span></span>;			<span class="comment">//打开销售记录文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">output</span><span class="params">(argv[<span class="number">2</span>])</span></span>;			<span class="comment">//打开输出文件</span></span><br><span class="line">Sales_data total;					<span class="comment">//保存销售总额的变量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">read</span>(input, total)) &#123;			<span class="comment">//读取第一条销售记录</span></span><br><span class="line">    Sales_data trans;				<span class="comment">//保存下一条销售记录的变量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(input, trans)) &#123;				<span class="comment">//读取剩余记录</span></span><br><span class="line">        <span class="keyword">if</span> (total.<span class="built_in">isbn</span>() == trans.<span class="built_in">isbn</span>())	<span class="comment">//检查isbn</span></span><br><span class="line">            total.<span class="built_in">combine</span>(trans);			<span class="comment">//更新销售总额</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(output, total) &lt;&lt; endl;	<span class="comment">//打印结果</span></span><br><span class="line">            total = trans;					<span class="comment">//处理下一本书</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(output, total) &lt;&lt; endl;			<span class="comment">//打印最后一本书的销售额</span></span><br><span class="line">&#125; <span class="keyword">else</span>										<span class="comment">//文件中无输入数据</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;No data?!&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>重要的部分是对<code>read</code>和<code>print</code>的调用。虽然两个函数定义时指定的形参分别是<code>istream&amp;</code>和<code>ostream&amp;</code>，但我们可以向它们传递<code>fstream</code>对象。</p>
<h5 id="成员函数open和close"><a class="markdownIt-Anchor" href="#成员函数open和close"></a> 成员函数open和close</h5>
<p>如果我们定义了一个空文件流对象，可以随后调用<code>open</code>来将它与文件关联起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;				<span class="comment">//构筑一个ifstream并打开给定文件</span></span><br><span class="line">ofstream out;					<span class="comment">//输出文件流未与任何文件相关联</span></span><br><span class="line">out.<span class="built_in">open</span>(ifile + <span class="string">&quot;.copy&quot;</span>);		<span class="comment">//打开指定文件</span></span><br></pre></td></tr></table></figure>
<p>如果调用<code>open</code>失败，<code>failbit</code>会被置位。因为调用<code>open</code>可能失败，进行<code>open</code>是否成功的检测通常是一个好习惯：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (out)			<span class="comment">//检查open是否成功</span></span><br><span class="line">    				<span class="comment">//open成功，则可以使用文件了</span></span><br></pre></td></tr></table></figure>
<p>这个条件判断与我们之前将<code>cin</code>用作条件相似。</p>
<p>一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用<code>open</code>会失败，并会导致<code>failbit</code>被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成功关闭，我们可以打开新的文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in.<span class="built_in">close</span>();				<span class="comment">//关闭文件</span></span><br><span class="line">in.<span class="built_in">open</span>(ifile + <span class="string">&quot;2&quot;</span>);	<span class="comment">//打开另一个文件</span></span><br></pre></td></tr></table></figure>
<p>如果<code>open</code>成功，则<code>open</code>会设置流的状态，使得<code>good()</code>为<code>true</code>。</p>
<h5 id="自动构造和析构"><a class="markdownIt-Anchor" href="#自动构造和析构"></a> 自动构造和析构</h5>
<p>考虑这样一个程序，它的<code>main</code>函数接受一个要处理的文件列表。这种程序可能会有如下的循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对每个传递给程序的文件执行循环操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = argv + <span class="number">1</span>; p != argv + argc; ++p ) &#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">inout</span><span class="params">(*p)</span></span>;		<span class="comment">//创建输出流并打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (input) &#123;			<span class="comment">//如果文件打开成功，“处理”此文件</span></span><br><span class="line">        <span class="built_in">process</span>(input);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;couldn&#x27;t open: &quot;</span> + <span class="built_in">string</span>(*p);</span><br><span class="line">&#125;	<span class="comment">//每个循环步input都会离开作用域，因此会被销毁</span></span><br></pre></td></tr></table></figure>
<p>每个循环步构造一个新的名为<code>input</code>的<code>ifstream</code>对象，并打开它来读取给定的文件。像之前一样，我们检查<code>open</code>是否成功。如果成功，将文件传递给一个函数，该函数负责读取并处理输入数据。如果<code>open</code>失败，打印一条错误信息并继续处理下一个文件。</p>
<p>因为<code>input</code>是<code>while</code>循环的局部变量，它在每个循环步中都要创建和销毁一次。当一个<code>fstream</code>对象离开其作用域时，与之关联的文件会自动关闭。在下一步循环中，<code>input</code>会再次被创建。</p>
<blockquote>
<p>当一个fstream对象被销毁时，close会被自动调用。</p>
</blockquote>
<h4 id="文件模式"><a class="markdownIt-Anchor" href="#文件模式"></a> 文件模式</h4>
<p>每个流都有一个关联的<strong>文件模式</strong>(file mode)，用来指出如何使用文件。下表列出文件模式和它们的含义：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">文件模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">in</td>
<td style="text-align:center">以读方式打开</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center">以写方式打开</td>
</tr>
<tr>
<td style="text-align:center">app</td>
<td style="text-align:center">每次写操作前均定位到文件末尾</td>
</tr>
<tr>
<td style="text-align:center">ate</td>
<td style="text-align:center">打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td style="text-align:center">trunc</td>
<td style="text-align:center">截断文件</td>
</tr>
<tr>
<td style="text-align:center">binary</td>
<td style="text-align:center">以二进制方式进行<strong>IO</strong></td>
</tr>
</tbody>
</table>
<p>无论用哪种方式打开文件，我们都可以指定文件模式，调用<code>open</code>打开文件时可用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制：</p>
<ul>
<li>只可以对<code>ofstream</code>或<code>fstream</code>对象设定<code>out</code>模式。</li>
<li>只可以对<code>ifstream</code>或<code>fstream</code>对象设定<code>in</code>模式。</li>
<li>只有当<code>out</code>也被设定时才可设定<code>trunc</code>模式。</li>
<li>只要<code>trunc</code>没被设定，就可以设定<code>app</code>模式。在<code>app</code>模式下，即使没有显式指定<code>out</code>模式，文件也总是以输出方式被打开。</li>
<li>默认情况下，即使我们没有指定<code>trunc</code>，以<code>out</code>模式打开的文件也会被截断。为了保留以<code>out</code>模式打开的文件的内容，我们必须同时指定<code>app</code>模式，这样只会将数据追加写到文件末尾；或者同时指定<code>in</code>模式，即打开文件同时进行读写操作(很后面将介绍对同一个文件既进行输入又进行输出的方法)。</li>
<li><code>ate</code>和<code>binary</code>模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。</li>
</ul>
<p>每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与<code>ifstream</code>关联的文件默认以<code>in</code>模式打开；与<code>ofstream</code>关联的文件默认以<code>out</code>模式打开；与<code>fstream</code>关联的文件默认以<code>in</code>和<code>out</code>模式打开。</p>
<h5 id="以out模式打开文件会丢失已有数据"><a class="markdownIt-Anchor" href="#以out模式打开文件会丢失已有数据"></a> 以out模式打开文件会丢失已有数据</h5>
<p>默认情况下，当我们打开一个<code>ofstream</code>时，文件的内容会被丢弃。阻止一个<code>ofstream</code>清空给定文件内容的方法是同时指定<code>app</code>模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在如下语句中，file1都被截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;file1&quot;</span>)</span></span>;		<span class="comment">//隐含以输出模式打开文件并截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out)</span></span>;	<span class="comment">//隐含地截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">//为了保留文件内容，我们必须显式指定app模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::app)</span></span>;	<span class="comment">//隐含为输出模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app2</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式。</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> 每次想要更改文件模式时，先关闭文件，再以目标文件模式打开。</p>
</blockquote>
<h3 id="string流"><a class="markdownIt-Anchor" href="#string流"></a> string流</h3>
<p>除了继承得来的操作，<code>sstream</code>中定义的类型还增加了一些成员来管理与流相关联的<code>string</code>。下表列出了这些操作，可以对<code>stringstream</code>对象调用这些操作，但不能对其他<strong>IO</strong>类型调用这些操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>stringstream特有的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>sstream</em> strm;</td>
<td><code>strm</code>是一个未绑定的<code>stringstream</code>对象。<em>sstream</em>是头文件<code>sstream</code>中定义的一个类型</td>
</tr>
<tr>
<td><em>sstream</em> strm(s);</td>
<td><code>strm</code>是一个<code>sstream</code>对象，保存<code>string s</code>的一个拷贝。此构造函数是<code>explicit</code>的</td>
</tr>
<tr>
<td>strm.str()</td>
<td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td>
</tr>
<tr>
<td>strm.str(s)</td>
<td>将<code>string s</code>拷贝到<code>strm</code>中。返回<code>void</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>可以用<code>ostringstream</code>的对象(假设命名为<code>formatted</code>)暂时存储要输出的字符串，然后在使用 <code>os &lt;&lt; formatted.str() &lt;&lt; endl</code> 一次性输出结果。</p>
</blockquote>
<h2 id="顺序容器"><a class="markdownIt-Anchor" href="#顺序容器"></a> 顺序容器</h2>
<p>一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>(sequential container)为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</p>
<p>标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。我们将在本章末尾介绍适配器。</p>
<h3 id="顺序容器概述"><a class="markdownIt-Anchor" href="#顺序容器概述"></a> 顺序容器概述</h3>
<p>下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li>非顺序访问容器中元素的代价</li>
<li>向容器添加或从容器中删除元素的代价</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">顺序容器类型</th>
<th style="text-align:center">代价一</th>
<th style="text-align:center">代价二</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">vector</td>
<td style="text-align:center">可变大小数组</td>
<td style="text-align:center">支持快速随机访问</td>
<td style="text-align:center">在尾部之外的位置插入或删除元素可能很慢</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td style="text-align:center">双端队列</td>
<td style="text-align:center">支持快速随机访问</td>
<td style="text-align:center">在头尾位置插入/删除速度很快</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">双向链表</td>
<td style="text-align:center">只支持双向顺序访问</td>
<td style="text-align:center">在list中任何位置进行插入/删除操作速度都很快</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td style="text-align:center">单向链表</td>
<td style="text-align:center">只支持单向顺序访问</td>
<td style="text-align:center">在链表任何位置进行插入/删除操作速度都很快</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">固定大小数组。</td>
<td style="text-align:center">支持快速随机访问</td>
<td style="text-align:center">不能添加或删除元素</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">与vector相似的容器，但专门用于保存字符</td>
<td style="text-align:center">随机访问快</td>
<td style="text-align:center">在尾部插入/删除速度快</td>
</tr>
</tbody>
</table>
<p>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素,扩张和收缩容器的大小。</p>
<p><code>string</code>和<code>vector</code>将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且，添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。</p>
<p><code>list</code>和<code>forward_list</code>两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与<code>vector</code>、<code>deque</code>和<code>array</code>相比，这两个容器的额外内存开销也很大。</p>
<p><code>deque</code>是一个更为复杂的数据结构。与<code>string</code>和<code>vector</code>类似，<code>deque</code>支持快速的随机访问，且在<code>deque</code>的中间位置添加或删除元素的代价(可能)很高。但是，在<code>deque</code>的两端添加或删除元素都是很快的，与<code>list</code>或<code>forward_list</code>添加删除元素的速度相当。</p>
<p><code>forward_list</code>和<code>array</code>是新C++标准增加的类型。与内置数组相比，<code>array</code>是一种更安全、更容易使用的数组类型。与内置数组类似，<code>array</code>对象的大小是固定的。因此，<code>array</code>不支持添加和删除元素以及改变容器大小的操作。<code>forward_list</code>的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，<code>forward_list</code>没有<code>size</code>操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，<code>size</code>保证是一个快速的常量时间的操作。</p>
<blockquote>
<p>如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或list都很方便。</p>
</blockquote>
<h3 id="容器库共有的操作概述"><a class="markdownIt-Anchor" href="#容器库共有的操作概述"></a> 容器库共有的操作概述</h3>
<p>在本节中将介绍所有容器(顺序容器、关联容器、无序容器)都适用的操作。</p>
<p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，<code>deque</code>定义在头文件 <code>deque</code>中，<code>list</code>定义在头文件<code>list</code>中，以此类推。容器均定义为模板类。例如对<code>vector</code>，我们必须提供额外信息来生成特定的容器类型。对大多数，但不是所有容器，我们还需要额外提供元素类型信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;Sales_data&gt;;			<span class="comment">//保存Sales_data对象的list</span></span><br><span class="line">deque&lt;<span class="type">double</span>&gt;;				<span class="comment">//保存double的deque</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>对容器可以保存的元素类型的限制</strong></p>
<p>虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。</p>
<p>例如，顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假定noDefault是一个没有默认构造函数的类型</span></span><br><span class="line"><span class="function">vector&lt;noDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, init)</span></span>;		<span class="comment">//正确，提供了元素初始化条件</span></span><br><span class="line"><span class="function">vector&lt;noDefault&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;			<span class="comment">//错误，必须提供一个元素初始化条件</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>以下是通用的容器操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型别名</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">iterator</td>
<td style="text-align:left">此容器类型的迭代器类型</td>
</tr>
<tr>
<td style="text-align:left">const_iterator</td>
<td style="text-align:left">可以读取元素，但不能修改元素的迭代器类型</td>
</tr>
<tr>
<td style="text-align:left">size_type</td>
<td style="text-align:left">无符号整数类型，足够保存此种容器类型最大可能容器的大小</td>
</tr>
<tr>
<td style="text-align:left">difference_type</td>
<td style="text-align:left">带符号整数类型，足够保存两个迭代器之间的距离</td>
</tr>
<tr>
<td style="text-align:left">value_type</td>
<td style="text-align:left">元素类型</td>
</tr>
<tr>
<td style="text-align:left">reference</td>
<td style="text-align:left">元素的左值类型；与<code>value_type&amp;</code>含义相同</td>
</tr>
<tr>
<td style="text-align:left">const_reference</td>
<td style="text-align:left">元素的<code>const</code>左值类型(即<code>const value_type&amp;</code>)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>构造函数</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>C c;</td>
<td>默认构造函数，构造空容器(<code>array</code>需要特殊处理)</td>
</tr>
<tr>
<td>C c1(c2);<br />C c1 = c2;</td>
<td>构造<code>c2</code>的拷贝<code>c1</code></td>
</tr>
<tr>
<td>C c(b, e);</td>
<td>构造<code>c</code>，将迭代器b和e指定的范围内的元素拷贝到<code>c</code>(<code>array</code>不支持)</td>
</tr>
<tr>
<td>C c{a, b, c…}<br />C c = {a, b, c…}</td>
<td>列表初始化<code>c</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>赋值与swap</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>c1 = c2</td>
<td>将<code>c1</code>中的元素替换为<code>c2</code>中元素</td>
</tr>
<tr>
<td>c1 = {a, b, c…}</td>
<td>将<code>c1</code>中的元素替换为列表中元素(不适用于<code>array</code>)</td>
</tr>
<tr>
<td>a.swap(b)</td>
<td>交换<code>a</code>和<code>b</code>的元素</td>
</tr>
<tr>
<td>swap(a, b)</td>
<td>与<code>a.swap(b)</code>等价</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>大小</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>c.size()</td>
<td><code>c</code>中元素的数目(不支持<code>forward_list</code>)</td>
</tr>
<tr>
<td>c.max_size()</td>
<td><code>c</code>可保存的最大元素数目</td>
</tr>
<tr>
<td>c.empty()</td>
<td>若<code>c</code>中存储了元素，返回<code>false</code>，否则返回<code>true</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>添加/删除元素(不适用与array)</th>
<th>注：这些操作的接口在不同容器中不同</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.insert(<em>args</em>)</td>
<td>将<em>args</em>中的元素拷贝进<code>c</code></td>
</tr>
<tr>
<td>c.emplace(<em>inits</em>)</td>
<td>使用<em>inits</em>构造<code>c</code>中的一个元素</td>
</tr>
<tr>
<td>c.erase(<em>args</em>)</td>
<td>删除<em>args</em>指定的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除<code>c</code>中的所有元素，返回<code>void</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>关系运算符</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>==, !=</td>
<td>所有容器都支持相等(不等)</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>运算符关系运算符(无序、关联容器不支持)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>获取迭代器</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>c.begin(), c.end()</td>
<td>返回指向<code>c</code>的首元素以及尾后元素位置的迭代器</td>
</tr>
<tr>
<td>c.cbegin(), c.cend()</td>
<td>返回<code>const_iterator</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>反向容器的额外成员(不支持forward_list)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>reverse_iterator</td>
<td>按逆序寻址元素的迭代器</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>不能修改元素的逆序迭代器</td>
</tr>
<tr>
<td>c.rbegin(), c.rend()</td>
<td>返回指向<code>c</code>的尾元素和首元素之前位置的迭代器</td>
</tr>
<tr>
<td>c.crbegin(), c,crend()</td>
<td>返回<code>const_reverse_iterator</code></td>
</tr>
</tbody>
</table>
<h4 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h4>
<p>与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。例如，标准容器类型上的所有迭代器都允许我们访问容器中的元素，而所有迭代器都是通过解引用运算符来实现这个操作的。类似的，标准库容器的所有迭代器都定义了递增运算符，从当前元素移动到下一个元素。</p>
<blockquote>
<p>有个例外，forward_list迭代器不支持递减运算符(–)。</p>
</blockquote>
<p>迭代器支持算术运算(<code>+n、-n、+=n、-=n、iter1 - iter2</code>)，这些运算只能应用于<code>string</code>、<code>vector</code>、<code>deque</code>和<code>array</code>的迭代器。我们不能将它们用于其他任何容器类型的迭代器。</p>
<p><strong>迭代器范围</strong></p>
<p>一个<strong>迭代器范围</strong>(iterator range)由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置(one past the last element)。这两个迭代器通常被称为<code>begin</code>和<code>end</code>，或者是<code>first</code>和<code>last</code>，它们标记了容器中元素的一个范围。</p>
<p>这种元素范围被称为<strong>左闭合区间</strong>(left-inclusive interval)，其标准数学描述为<code>[begin, end)</code>。</p>
<p>表示范围自<code>begin</code>开始，于<code>end</code>之前结束。迭代器<code>begin</code>和<code>end</code>必须指向相同的容器。<code>end</code>可以与<code>begin</code>指向相同的位置，但不能指向<code>begin</code>之前的位置。</p>
<h4 id="容器类型成员"><a class="markdownIt-Anchor" href="#容器类型成员"></a> 容器类型成员</h4>
<p>除了已经使用过的迭代器类型，大多数容器还提供反向迭代器。简单地说，反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比,各种操作的含义也都发生了颠例。例如，对一个反向迭代器执行 ++ 操作，会得到上一个元素。</p>
<p>剩下的就是类型别名了，通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的<code>value_type</code>。如果需要元素类型的一个引用，可以使用<code>reference</code>或<code>const_reference</code>。这些元素相关的类型别名在泛型编程中非常有用。</p>
<p>为了使用这些类型，我们必须显式使用其类名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iter是通过list&lt;string&gt;定义的一个迭代器类型</span></span><br><span class="line">list&lt;string&gt;::iterator iter;</span><br><span class="line"><span class="comment">//count是通过vector&lt;int&gt;定义的一个difference_type类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::difference_type count;</span><br></pre></td></tr></table></figure>
<p>这些声明语句使用了作用域运算符来说明我们希望使用<code>list&lt;string&gt;</code>类的<code>iterator</code>成员及<code>vector&lt;int&gt;</code>类定义的<code>difference_type</code>。</p>
<h4 id="重载过的begin和end"><a class="markdownIt-Anchor" href="#重载过的begin和end"></a> 重载过的begin和end</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; a = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.<span class="built_in">begin</span>();		<span class="comment">//list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span>();		<span class="comment">//list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span>();		<span class="comment">//list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>();		<span class="comment">//list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure>
<p>不以<code>c</code>开头的函数都是被重载过的。也就是说，实际上有两个名为<code>begin</code>的成员函数。一是<code>const</code>成员，返回容器的<code>const_iterator</code>类型。另一个是非常量成员，返回容器的<code>iterator</code>类型。<code>rbegin</code>、<code>end</code>和<code>rend</code>的情况类似。当我们对一个非常量对象调用这些成员时，得到的是返回 <code>iterator</code>的版本。只有在对个别<code>const</code>对象调用这些函数时，才会得到一个<code>const</code>版本。与<code>const</code>指针和引用类似，可以将一个普通的<code>iterator</code>转换为对应的<code>const_iterator</code>，但反之不行。</p>
<p>以<code>c</code>开头的版本是 C++ 新标准引入的，用以支持<code>auto</code>与<code>begin</code>和<code>end</code>函数结合使用。</p>
<h4 id="容器定义和初始化"><a class="markdownIt-Anchor" href="#容器定义和初始化"></a> 容器定义和初始化</h4>
<p>只有顺序容器(不包括<code>array</code>)的构造函数才能接受大小参数：</p>
<table>
<thead>
<tr>
<th>接受大小参数的初始化</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>C seq(n)</td>
<td><code>seq</code>包含<code>n</code>个元素，这些元素进行了值初始化；此构造函数是<code>explicit</code>的(不适用于<code>string</code>)</td>
</tr>
<tr>
<td>C seq(n, t)</td>
<td><code>seq</code>包含<code>n</code>个初始化为值<code>t</code>的元素</td>
</tr>
</tbody>
</table>
<h5 id="将一个容器初始化为另一个容器的拷贝"><a class="markdownIt-Anchor" href="#将一个容器初始化为另一个容器的拷贝"></a> 将一个容器初始化为另一个容器的拷贝</h5>
<p>将一个新容器创建为另一个容器的考贝的方法有两种：可以直接拷贝整个容器，或者(<code>array</code>除外)拷贝由一个迭代器对指定的元素范围。</p>
<p>为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个容器有三个元素，用给定的初始化器进行初始化</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;		<span class="comment">//正确，类型匹配</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors)</span></span>;	<span class="comment">//错误，容器类型必须匹配</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">words</span><span class="params">(articles)</span></span>;		<span class="comment">//错误，容器的元素类型必须匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确，可以将const char*元素转换为string</span></span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="标准库array具有固定大小"><a class="markdownIt-Anchor" href="#标准库array具有固定大小"></a> 标准库array具有固定大小</h5>
<p>与内置数组一样，标准库<code>array</code>的大小也是类型的一部分。当定义一个<code>array</code>时，除了指定元素类型，还要指定容器大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 10&gt; s;				<span class="comment">//类型为保存10个string的数组</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;::size_type i;		<span class="comment">//数组类型包括元素类型和大小</span></span><br><span class="line">array&lt;<span class="type">int</span>&gt;::size_type j;			<span class="comment">//错误，array&lt;int&gt;不是一个类型</span></span><br></pre></td></tr></table></figure>
<p><code>array</code>大小固定的特性也影响了它所定义的构造函数的行为。与其他容器不同，一个默认构造的<code>array</code>是非空的：它包含了与其大小一样多的元素，而这些元素都被默认初始化，就像一个内置数组中的元素那样。如果我们对<code>array</code>进行列表初始化，初始值的数目必须等于或小于<code>array</code>的大小。如果初始值数目小于<code>array</code>的大小，则它们被用来初始化<code>array</code>中靠前的元素，所有剩余元素都会进行值初始化。在这两种情况下，如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt;ia1;							<span class="comment">//10个默认初始化的int</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;	<span class="comment">//列表初始化</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;ia3 = &#123;<span class="number">42</span>&#125;;					<span class="comment">//ia3[0]为42，其余元素为0</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但<code>array</code>并无此限制:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digs[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> cpy[<span class="number">10</span>] = digs;				<span class="comment">//错误，内置数组不支持拷贝或赋值</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt; digits = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt; copy = digits;	<span class="comment">//正确，只要数组类型匹配即合法</span></span><br></pre></td></tr></table></figure>
<p>与其他容器一样，<code>array</code>也要求初始值的类型必须与要创建的容器类型相同。此外，<code>array</code>还要求元素类型和大小也都一样，因为大小是<code>array</code>类型的一部分。</p>
<h5 id="使用assign仅顺序容器"><a class="markdownIt-Anchor" href="#使用assign仅顺序容器"></a> 使用assign(仅顺序容器)</h5>
<table>
<thead>
<tr>
<th>assign操作</th>
<th>不适用于关联容器和array</th>
</tr>
</thead>
<tbody>
<tr>
<td>seq.assign(b, e)</td>
<td>将<code>seq</code>中的元素替换为迭代器<code>b</code>和<code>e</code>所表示的范围中的元素。迭代器<code>b</code>和<code>e</code>不能指向<code>seq</code>中的元素</td>
</tr>
<tr>
<td>seq.assign(il)</td>
<td>将<code>seq</code>中的元素替换为初始化列表<code>il</code>中的元素</td>
</tr>
<tr>
<td>seq.assign(n, t)</td>
<td>将<code>seq</code>中的元素替换为<code>n</code>个值为<code>t</code>的元素</td>
</tr>
</tbody>
</table>
<p>赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器(<code>array</code>除外)还定义了一个名为<code>assign</code>的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。<code>assign</code>操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。例如，我们可以用<code>assgin</code>实现将一个<code>vector</code>中的一段<code>char*</code>值赋予一个<code>list</code>中的<code>string</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle;		<span class="comment">//错误，容器类型不匹配</span></span><br><span class="line"><span class="comment">//正确，可以将const char*转换为string</span></span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(), oldstyle.<span class="built_in">cend</span>());</span><br></pre></td></tr></table></figure>
<h5 id="使用swap"><a class="markdownIt-Anchor" href="#使用swap"></a> 使用swap</h5>
<p><code>swap</code>操作交换两个相同类型容器的内容。调用<code>swap</code>之后，两个容器中的元素将交换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;		<span class="comment">//10个元素的vector</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;		<span class="comment">//24个元素的vector</span></span><br><span class="line"><span class="built_in">swap</span>(svec1, svec2);</span><br></pre></td></tr></table></figure>
<p>调用<code>swap</code>后，<code>svec1</code>将包含<strong>24</strong>个<code>string</code>元素，<code>svec2</code>将包含<strong>10</strong>个<code>string</code>。除<code>array</code>外，交换两个容器内容的操作保证会很快——元素本身并未交换，<code>swap</code>只是交换了两个容器的内部数据结构。</p>
<p>元素不会被移动的事实意味着，除<code>string</code>外，指向容器的迭代器、引用和指针<code>swap</code>操作之后都不会失效。它们仍指向<code>swap</code>操作之前所指向的那些元素。但是，在<code>swap</code>之后，这些元素已经属于不同的容器了。例如，假定<code>iter</code>在<code>swap</code>之前指向<code>svec1[3]</code>的<code>string</code>，那么在<code>swap</code>之后它指向<code>svec2[3]</code>的元素。与其他容器不同，对一个<code>string</code>调用<code>swap</code>会导致迭代器、引用和指针失效。</p>
<p>与其他容器不同，<code>swap</code>两个<code>array</code>会真正交换它们的元素。因此，交换两个<code>array</code>所需的时间与<code>array</code>中元素的数目成正比。</p>
<p>因此，对于<code>array</code>，在<code>swap</code>操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个<code>array</code>中对应元素的值进行了交换。</p>
<blockquote>
<p>在新标准库中，容器既提供成员函数版本的<code>swap</code>，也提供非成员版本的<code>swap</code>。而早期标准库版本只提供成员函数版本的<code>swap</code>。非成员版本的<code>swap</code>在泛型编程中是非常重要的。统一使用非成员版本的<code>swap</code>是一个好习惯。</p>
</blockquote>
<h5 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h5>
<p>每个容器类型都支持相等运算符( == 和 != )；除了无序关联容器外的所有容器都支持关系运算符( &gt;、&gt;=、&lt;、&lt;= )。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>&#125;;</span><br><span class="line">v1 &lt; v2		<span class="comment">//true</span></span><br><span class="line">v1 &lt; v3		<span class="comment">//false</span></span><br><span class="line">v1 == v4	<span class="comment">//true</span></span><br><span class="line">v1 == v2	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>容器的关系运算符使用元素的关系运算符完成比较</strong></p>
<p>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</p>
</blockquote>
<h3 id="顺序容器操作"><a class="markdownIt-Anchor" href="#顺序容器操作"></a> 顺序容器操作</h3>
<p>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。</p>
<h4 id="向顺序容器添加元素"><a class="markdownIt-Anchor" href="#向顺序容器添加元素"></a> 向顺序容器添加元素</h4>
<p>除<code>array</code>外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。下表列出了向顺序容器(非<code>array</code>)添加元素的操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>向顺序容器添加元素的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.push_back(t)<br />c.emplace_back(<em>args</em>)</td>
<td>在<code>c</code>的尾部创建一个值为<code>t</code>或由<em>args</em>创建的元素。返回<code>void</code></td>
</tr>
<tr>
<td>c.push_front(t)<br />c.emplace_front(<em>args</em>)</td>
<td>在<code>c</code>的头部创建一个值为<code>t</code>或由<em>args</em>创建的元素。返回<code>void</code></td>
</tr>
<tr>
<td>c.insert(p, t)<br />c.emplace(p, <em>args</em>)</td>
<td>在迭代器<code>p</code>指向的元素之前创建一个值为<code>t</code>或由<em>args</em>创建的元素。返回指向新添加的元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p, n, t)</td>
<td>在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素。返回指向新添加的第一个元素的迭代器；若<code>n</code>为<strong>0</strong>，则返回<code>p</code></td>
</tr>
<tr>
<td>c.insert(p, b, e)</td>
<td>将迭代器<code>b</code>和<code>e</code>指定的范围内的元素插入到迭代器<code>p</code>指向的元素之前。<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回<code>p</code></td>
</tr>
<tr>
<td>c.insert(p, il)</td>
<td><code>il</code>是一个花括号包围的元素值列表。将这些给定值插入到迭代器<code>p</code>指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回<code>p</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>forward_list有自己专属版本的insert和emplace，且不支持push_back和emplace_back。</p>
<p>vector和string不支持push_front和emplace_front。</p>
</blockquote>
<h5 id="在容器中的特定位置添加元素"><a class="markdownIt-Anchor" href="#在容器中的特定位置添加元素"></a> 在容器中的特定位置添加元素</h5>
<p>虽然某些容器不支持<code>push_front</code>操作，但它们对于<code>insert</code>操作并无类似的限制(插入开始位置)。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持<code>push_front</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">svec.<span class="built_in">insert</span>(svec.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"><span class="comment">//vector不支持push_front，但我们可以插入到begin()之前</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。</p>
</blockquote>
<h5 id="使用insert的返回值"><a class="markdownIt-Anchor" href="#使用insert的返回值"></a> 使用insert的返回值</h5>
<p>通过使用<code>insert</code>的返回值，可以在容器中一个特定位置反复插入元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; lst;</span><br><span class="line"><span class="keyword">auto</span> iter = lst.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    iter = lst.<span class="built_in">insert</span>(iter, word);		<span class="comment">//等价于调用push_front</span></span><br></pre></td></tr></table></figure>
<h5 id="使用emplace操作"><a class="markdownIt-Anchor" href="#使用emplace操作"></a> 使用emplace操作</h5>
<p>当调用<code>push</code>或<code>insert</code>成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个<code>emplace</code>成员函数时，则是将参数传递给元素类型的构造函数。<code>emplace</code>成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定<code>c</code>保存<code>Sales_data</code>元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，创建一个临时的Sales_data对象传递给push_back</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br><span class="line">c.<span class="built_in">emplace_back</span>();	<span class="comment">//使用默认的Sales_data的默认构造函数</span></span><br><span class="line"><span class="comment">//iter指向c中某一个元素</span></span><br><span class="line">c.<span class="built_in">emplace</span>(iter, <span class="string">&quot;999-99999999&quot;</span>);	<span class="comment">//使用Sales_data(string)</span></span><br><span class="line"><span class="comment">//使用Sales_data的接受一个ISBN、一个count和一个price的构造函数</span></span><br><span class="line">c.<span class="built_in">emplace_front</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br></pre></td></tr></table></figure>
<h4 id="访问元素"><a class="markdownIt-Anchor" href="#访问元素"></a> 访问元素</h4>
<p>下表列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。</p>
<table>
<thead>
<tr>
<th></th>
<th>在顺序容器中访问元素的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.back()</td>
<td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td>c.front()</td>
<td>返回<code>c</code>中首元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td>c[n]</td>
<td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义返回<code>c</code>中首元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://c.at">c.at</a>(n)</td>
<td>返回下标为<code>n</code>的元素的引用。如果下标越界，则抛出一个<code>out_of_range</code>异常</td>
</tr>
</tbody>
</table>
<p>包括<code>array</code>在内的每个顺序容器都有一个<code>front</code>成员函数，而除<code>forward_list</code>之外的所有顺序容器都有一个<code>back</code>成员函数。</p>
<p><code>at</code>和下标操作只适用于<code>string</code>、<code>vector</code>、<code>deque</code>和<code>array</code>。</p>
<h5 id="安全的随机访问和at成员函数"><a class="markdownIt-Anchor" href="#安全的随机访问和at成员函数"></a> 安全的随机访问和at成员函数</h5>
<p>如果我们希望确保下标是合法的，可以使用<code>at</code>成员函数。<code>at</code>成员函数类似下标运算符，但如果下标越界，<code>at</code>会抛出一个<code>out_of_range</code>异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>];		<span class="comment">//运行时错误，svec中没有元素</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>);		<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>
<h4 id="删除元素"><a class="markdownIt-Anchor" href="#删除元素"></a> 删除元素</h4>
<table>
<thead>
<tr>
<th></th>
<th>顺序容器的删除操作(array不支持)</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.pop_back()</td>
<td>删除<code>c</code>中尾元素。若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td>
</tr>
<tr>
<td>c.pop_front()</td>
<td>删除<code>c</code>中首元素。若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td>
</tr>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器<code>p</code>所指定的元素，返回一个指向被删元素之后元素的迭代器，若<code>p</code>指向尾元素，则返回尾后(off-the-end)迭代器。若<code>p</code>是尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td>c.erase(b, e)</td>
<td>删除迭代器<code>b</code>和<code>e</code>所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若<code>e</code>本身就是尾后迭代器，则函数也返回尾后迭代器</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除<code>c</code>中的所有元素。返回<code>void</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>forward_list有自己专属版本的erase，且不支持pop_back。</p>
<p>vector和string不支持pop_front。</p>
</blockquote>
<h4 id="特殊的forward_list操作"><a class="markdownIt-Anchor" href="#特殊的forward_list操作"></a> 特殊的forward_list操作</h4>
<p><code>forward_list</code>是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。出于这个原因，在一个 <code>forward_list</code>中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除操作所影响的元素。</p>
<p>由于这些操作与其他容器上的操作的实现方式不同，<code>forward_list</code>并未定义<code>insert</code>、<code>emplace</code>和<code>erase</code>，而是定义了名为<code>insert_after</code>、<code>emplace_after</code>和<code>erase_after</code>的操作。<code>forward_list</code>也定义了<code>before_begin</code>，它返回一个<strong>首前</strong>(off-the-beginning)迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素(亦即在链表首元素之前添加删除元素)。</p>
<table>
<thead>
<tr>
<th></th>
<th>forward_list中插入或删除操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>lst.before_begin()<br />lst.cbefore_begin()</td>
<td>返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。<code>cbefore_begin()</code>返回一个<code>const_iterator</code></td>
</tr>
<tr>
<td>lst.insert_after(p, t)<br />lst.insert_after(p, n, t)<br />lst.insert_after(p, b, e)<br />lst.insert_after(p, il)</td>
<td>在迭代器p之后的位置插入元素。<code>t</code>是一个对象，<code>n</code>是数量，<code>b</code>和<code>e</code>是表示范围的一对迭代器(<code>b</code>和<code>e</code>不能指向<code>lst</code>内)，<code>il</code>是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回<code>p</code>。若<code>p</code>为尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td>lst.emplace_after(p, <em>args</em>)</td>
<td>使用<em>args</em>在<code>p</code>指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td>lst.erase_after(p)<br />lst.erase_after(b, e)</td>
<td>删除<code>p</code>指向的位置之后的元素，或删除从<code>b</code>之后直到(但不包含)<code>e</code>之间的元素。返回一个指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义</td>
</tr>
</tbody>
</table>
<h4 id="改变容器大小"><a class="markdownIt-Anchor" href="#改变容器大小"></a> 改变容器大小</h4>
<p>我们可以用<code>resize</code>来增大或缩小容器，与往常一样，<code>array</code>不支持<code>resize</code>。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;		<span class="comment">//10个int，每个值都为42</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">15</span>);				<span class="comment">//将5个值为0的元素添加到ilist末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">25</span>, <span class="number">-1</span>);			<span class="comment">//将10个值为-1的元素添加到ilist末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">5</span>);				<span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></table></figure>
<p><code>resize</code>操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化。如果容器保存的是类类型元素，且<code>resize</code>向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供一个默认构造函数。</p>
<blockquote>
<p>resize操作极可能导致迭代器、指针和引用失效。</p>
</blockquote>
<h4 id="容器操作可能使迭代器失效"><a class="markdownIt-Anchor" href="#容器操作可能使迭代器失效"></a> 容器操作可能使迭代器失效</h4>
<p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。</p>
<blockquote>
<p>在向容器添加元素后：</p>
<p>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效</p>
<p>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</p>
<p>对于list和forward_list，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍有效。</p>
</blockquote>
<blockquote>
<p>当我们删除一个元素后：</p>
<p>对于list和forward_list，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、引用和指针仍有效。</p>
<p>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也会受影响。</p>
<p>对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。</p>
<p>注意：当我们删除元素时，尾后迭代器总是会失效。</p>
</blockquote>
<p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对<code>vector</code>、<code>string</code>和<code>deque</code>尤为重要。</p>
<h3 id="vector容器空间"><a class="markdownIt-Anchor" href="#vector容器空间"></a> vector容器空间</h3>
<p>为了支持快速随机访问，<code>vector</code>将元素连续存储。通常情况下，我们不必关心一个标准库类型是如何实现的，而只需关心它如何使用。然而，对于<code>vector</code>和<code>string</code>，其部分实现渗透到了接口中。</p>
<p>标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时，<code>vector</code>和<code>string</code>的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。</p>
<p>如下表所示，<code>vector</code>和<code>string</code>类型提供了一些成员函数，允许我们与它的实现中内存分配部分互动。<code>capacity</code>操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。<code>reserve</code>操作允许我们通知容器它应该准备保存多少个元素。</p>
<table>
<thead>
<tr>
<th></th>
<th>容器大小管理操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.shrink_to_fit()</td>
<td>发送一个请求，将<code>capacity</code>减少为<code>size</code>相同大小</td>
</tr>
<tr>
<td>c.capacity()</td>
<td>不重新分配空间的情况下，<code>c</code>可以保存多少元素</td>
</tr>
<tr>
<td>c.reserve(n)</td>
<td>分配至少能容纳<code>n</code>个元素的内存空间</td>
</tr>
</tbody>
</table>
<blockquote>
<p>shrink_to_fit只适用于vector、string和deque；</p>
<p>capacity和reserve只适用于vector和string。</p>
</blockquote>
<blockquote>
<p><code>reserve</code>并不改变容器中元素的数量，它仅影响<code>vector</code>预先分配多大的内存空间。</p>
</blockquote>
<p>只有当需要的内存空间超过当前容量时，<code>reserve</code>调用才会改变<code>vector</code>的容量。如果需求大小大于当前容量，<code>reserve</code>至少分配与需求一样大的内存空间(可能更大)。</p>
<p>如果需求大小小于或等于当前容量，<code>reserve</code> 什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用<code>reserve</code>之后，<code>capacity</code>将会大于或等于传递给<code>reserve</code>的参数。这样，调用<code>reserve</code>永远也不会减少容器占用的内存空间。类似的，<code>resize</code>成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用<code>resize</code>来减少容器预留的内存空间。</p>
<p>在新标准库中，我们可以调用<code>shrink_to_fit</code>来要求<code>deque</code>、<code>vector</code>或<code>string</code>退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用<code>shrink_to_fit</code>也并不保证一定退回内存空间。</p>
<h3 id="额外的string操作"><a class="markdownIt-Anchor" href="#额外的string操作"></a> 额外的string操作</h3>
<p>除了顺序容器共同的操作之外，<code>string</code>类型还提供了一些额外的操作。这些操作中的大部分要么是提供<code>string</code>类和C风格字符数组之间的相互转换，要么是增加了允许我们用下标代替迭代器的版本。</p>
<h4 id="构造string的其他方法"><a class="markdownIt-Anchor" href="#构造string的其他方法"></a> 构造string的其他方法</h4>
<table>
<thead>
<tr>
<th></th>
<th>构造string的其他方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s(cp, n)</td>
<td><code>s</code>是<code>cp</code>指向的字符数组中前<code>n</code>个字符的铂贝。此数组至少应该包含<code>n</code>个字符</td>
</tr>
<tr>
<td>string s(s2, pos2)</td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符的拷贝。若<code>pos2&gt;s2.size()</code>，构造函数的行为未定义</td>
</tr>
<tr>
<td>string s(s2, pos2, len2)</td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始<code>len2</code>个字符的拷贝。若<code>pos2&gt;s2.size()</code>，构造函数的行为未定义。不管<code>len2</code>的值是多少，构造函数至多拷贝<code>s2.size()-pos2</code>个字符</td>
</tr>
</tbody>
</table>
<p>这些构造函数接受一个<code>string</code>或一个<code>const char*</code>参数，还接受(可选的)指定拷贝多少个字符的参数。当我们传递给它们的是一个<code>string</code>时，还可以给定一个下标来指出从哪里开始拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = <span class="string">&quot;Hello World!!!&quot;</span>;	<span class="comment">//以空字符结束的数组</span></span><br><span class="line"><span class="type">char</span> noBull[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;;			<span class="comment">//不以空字符结束</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(cp)</span></span>;			<span class="comment">//拷贝cp中的字符直到遇到空字符，s1 == &quot;Hello World!!!&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(noNull, <span class="number">2</span>)</span></span>;	<span class="comment">//从noNull拷贝两个字符，s2 == &quot;Hi&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(nuNull)</span></span>;		<span class="comment">//未定义，noNull不是以空字符结束</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(cp + <span class="number">6</span>, <span class="number">5</span>)</span></span>;	<span class="comment">//从cp[6]开始拷贝5个字符，s4 == &quot;World&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(s1, <span class="number">6</span>, <span class="number">5</span>)</span></span>;	<span class="comment">//从s1[6]开始拷贝5个字符，s5 == &quot;World&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(s1, <span class="number">6</span>)</span></span>;		<span class="comment">//从s1[6]开始拷贝，直至s1末尾，s6 == &quot;World!!!&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(s1, <span class="number">6</span>, <span class="number">20</span>)</span></span>;	<span class="comment">//正确，只拷贝到s1末尾，s7 == &quot;World!!!&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s8</span><span class="params">(s1, <span class="number">16</span>)</span></span>;		<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>
<p>通常当我们从一个<code>const char*</code>创建<code>string</code>时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。</p>
<p>当从一个<code>string</code>拷贝字符时，我们可以提供一个可选的开始位置和一个计数值。开始位置必须小于或等于给定的<code>string</code>的大小。如果位置大于<code>size</code>，则构造函数抛出个<code>out_of_range</code>异常。如果我们传递了一个计数值，则从给定位置开始拷贝这么多个字符。不管我们要求拷贝多少个字符，标准库最多拷贝到<code>string</code>结尾，不会更多。</p>
<p><strong>substr操作</strong></p>
<p><code>substr</code>操作返回一个<code>string</code>，它是原始<code>string</code>的一部分或全部的拷贝。可以传递给<code>substr</code>一个可选的开始位置和计数值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);		<span class="comment">//s2 == &quot;Hello&quot;</span></span><br><span class="line">string s3 = s.<span class="built_in">substr</span>(<span class="number">6</span>);		<span class="comment">//s3 == &quot;World&quot;</span></span><br><span class="line">string s4 = s.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">11</span>);	<span class="comment">//s4 == &quot;World&quot;</span></span><br><span class="line">string s5 = s.<span class="built_in">substr</span>(<span class="number">12</span>);		<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>
<p>如果开始位置超过了<code>string</code>的大小，则<code>substr</code>函数抛出一个<code>out_of_range</code>异常。如果开始位置加上计数值大于<code>string</code>的大小，则<code>substr</code>会调整计数值，只拷贝到<code>string</code>的末尾。</p>
<h4 id="改变string的其他方法"><a class="markdownIt-Anchor" href="#改变string的其他方法"></a> 改变string的其他方法</h4>
<h5 id="额外的insert-assign和erase版本"><a class="markdownIt-Anchor" href="#额外的insert-assign和erase版本"></a> 额外的insert、assign和erase版本</h5>
<p>除了接受迭代器的<code>insert</code>和<code>erase</code>版本外，<code>string</code>还提供了接受下标的版本。下标指出了开始删除的位置，或是<code>insert</code>到给定值之前的位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>);		<span class="comment">//在s末尾插入5个感叹号</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">size</span>() - <span class="number">5</span>, <span class="number">5</span>);		<span class="comment">//从s删除最后5个字符</span></span><br></pre></td></tr></table></figure>
<p>标准库<code>string</code>类型还提供了接受C风格字符数组的<code>insert</code>和<code>assign</code>版本。例如，我们可以将以空字符结尾的字符数组<code>insert</code>到或<code>assign</code>给一个<code>string</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = <span class="string">&quot;Stately, plump Buck&quot;</span>;</span><br><span class="line">s.<span class="built_in">assign</span>(cp, <span class="number">7</span>);				<span class="comment">//s == &quot;Stately&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), cp + <span class="number">7</span>);		<span class="comment">//s == &quot;Stately, plump Buck&quot;</span></span><br></pre></td></tr></table></figure>
<p>此处我们首先通过调用<code>assign</code>替换<code>s</code>的内容。我们赋予<code>s</code>的是从<code>cp</code>指向的地址开始的<strong>7</strong>个字符。要求赋值的字符数必须小于或等于cp 指向的数组中的字符数(不包括结尾的空字符)。</p>
<p>接下来在<code>s</code>上调用<code>insert</code>，我们的意图是将字符插入到<code>s[size()]</code>处(不存在的)元素之前的位置。在此例中，我们将从<code>cp</code>的第<strong>7</strong>个字符开始(至多到结尾空字符之前)拷贝到<code>s</code>中。</p>
<blockquote>
<p>但是，我们不能对insert函数同时使用迭代器定位以及用字符指针指定新字符来源。</p>
</blockquote>
<p>我们也可以指定将来自其他<code>string</code>或子字符串的字符插入到当前<code>string</code>中或赋予当前<code>string</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;some string&quot;</span>, s2 = <span class="string">&quot;some other string&quot;</span>;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>, s2);</span><br><span class="line"><span class="comment">//在s[0]之前插入s2中s2[0]开始的s2.size()个字符</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>, s2, <span class="number">0</span>, s2.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>
<h5 id="append和relapce函数"><a class="markdownIt-Anchor" href="#append和relapce函数"></a> append和relapce函数</h5>
<p><code>string</code>类定义了两个额外的成员函数：<code>append</code>和<code>replace</code>，这两个函数可以改变<code>string</code>的内容。</p>
<p><code>append</code>操作是在<code>string</code>末尾进行插入操作的一种简写形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;C++ Primer&quot;</span>)</span>, s2 </span>= s;	<span class="comment">//将s和s2初始化为&quot;C++ Primer&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="string">&quot; 4th Ed.&quot;</span>);	<span class="comment">//s == &quot;C++ Primer 4th Ed.&quot;</span></span><br><span class="line">s2.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span>);			<span class="comment">//等价方法，将&quot; 4th Ed.&quot;追加到s2; s == s2</span></span><br></pre></td></tr></table></figure>
<p><code>replace</code>操作是调用<code>erase</code>和<code>insert</code>的一种简写形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将&quot;4th&quot;替换为&quot;5th&quot;的等价方法</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">11</span>, <span class="number">3</span>);				<span class="comment">//s == &quot;C++ Primer  Ed.&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">11</span>, <span class="string">&quot;5th&quot;</span>);		<span class="comment">//s == &quot;C++ Primer 5th Ed.&quot;</span></span><br><span class="line"><span class="comment">//从位置11开始，删除3个字符并插入&quot;5th&quot;</span></span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">11</span>, <span class="number">3</span>, <span class="string">&quot;5th&quot;</span>);	<span class="comment">//s2 == s</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此例中调用<code>replace</code>时，插入的文本恰好与删除的文本一样长。这不是必须的，可以插入一个更长或更短的<code>string</code>。</p>
</blockquote>
<h5 id="string搜索操作"><a class="markdownIt-Anchor" href="#string搜索操作"></a> string搜索操作</h5>
<p><code>string</code>类提供了<strong>6</strong>个不同的搜索函数，每个函数都有<strong>4</strong>个重载版本。下表描述了这些搜索成员函数及其参数。每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为<code>string::npos</code>的<code>static</code>成员。标准库将<code>npos</code>定义为一个<code>const string:.size_type</code>类型，并初始化为值**-1**。由于<code>npos</code>是一个<code>unsigned</code>类型，此初始值意味着<code>npos</code>等于任何<code>string</code>最大的可能大小。</p>
<table>
<thead>
<tr>
<th></th>
<th>string搜索操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(<em>args</em>)</td>
<td>查找<code>s</code>中<em>args</em>第一次出现的位置</td>
</tr>
<tr>
<td>s.rfind(<em>args</em>)</td>
<td>查找<code>s</code>中<em>args</em>最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_of(<em>args</em>)</td>
<td>在<code>s</code>中查找<em>args</em>中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td>s.find_last_of(<em>args</em>)</td>
<td>在<code>s</code>中查找<em>args</em>中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_not_of(<em>args</em>)</td>
<td>在<code>s</code>中查找第一个不在<em>args</em>中的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(<em>args</em>)</td>
<td>在<code>s</code>中查找最后一个不在<em>args</em>中的字符</td>
</tr>
</tbody>
</table>
<blockquote>
<p>搜索操作返回指定字符出现的下标，如果未找到则返回<code>npos</code>。</p>
<table>
<thead>
<tr>
<th><em>args</em>必须是以下形式之一</th>
<th>且都适用于以上6个搜索函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>c, pos</td>
<td>从<code>s</code>中位置<code>pos</code>开始查找字符<code>c</code>。<code>pos</code>默认为<strong>0</strong></td>
</tr>
<tr>
<td>s2, pos</td>
<td>从<code>s</code>中位置<code>pos</code>开始查找字符串<code>s2</code>。<code>pos</code>默认为<strong>0</strong></td>
</tr>
<tr>
<td>cp, pos</td>
<td>从<code>s</code>中位置<code>pos</code>开始查找指针 <code>cp</code>指向的以空字符结尾的C风格字符串。<code>pos</code>默认为<strong>0</strong></td>
</tr>
<tr>
<td>cp, pos, n</td>
<td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的数组的前<code>n</code>个字符。<code>pos</code>和<code>n</code>无默认值</td>
</tr>
</tbody>
</table>
</blockquote>
<p><code>find</code>函数完成最简单的搜索。它查找参数指定的字符串，若找到，则返回第一个配位置的下标，否则返回<code>npos</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">&quot;AnnaBelle&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> pos1 = name.<span class="built_in">find</span>(<span class="string">&quot;Anna&quot;</span>);		<span class="comment">//pos1 == 0</span></span><br></pre></td></tr></table></figure>
<p>这段程序返回<strong>0</strong>，即子字符串<code>&quot;Anna&quot;</code>在<code>&quot;AnnaBelle&quot;</code>中第一次出现的下标。</p>
<p>搜索(以及其他<code>string</code>操作)是大小写敏感的。当在<code>string</code>中查找子字符串时要注意大小写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">&quot;annaBelle&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> pos1 = name.<span class="built_in">find</span>(<span class="string">&quot;Anna&quot;</span>);		<span class="comment">//pos1 == npos</span></span><br></pre></td></tr></table></figure>
<p>这段代码会将<code>pos1</code>置为<code>npos</code>，因为<code>Anna</code>与<code>anna</code>不匹配。</p>
<p>一个更复杂一些的问题是查找与给定字符串中任何一个字符匹配的位置。例如，下面代码定位<code>name</code>中的第一个数字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">numbers</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span>, <span class="title">name</span><span class="params">(<span class="string">&quot;r2d2&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回1，即name中第一个数字的下标</span></span><br><span class="line"><span class="keyword">auto</span> pos = name.<span class="built_in">find_first_of</span>(numbers);</span><br></pre></td></tr></table></figure>
<p>如果是要搜索第一个不在参数中的字符，我们应该调用<code>find_first_not_of</code>。例如，为了搜索一个<code>string</code>中第一个非数字字符，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">dept</span><span class="params">(<span class="string">&quot;03714p3&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回5——字符&#x27;p&#x27;的下标</span></span><br><span class="line"><span class="keyword">auto</span> pos = dept.<span class="built_in">find_first_not_of</span>(numbers);</span><br></pre></td></tr></table></figure>
<p><strong>移动检索</strong></p>
<p>我们可以传递给<code>find</code>操作一个可选的开始位置。这个可选的参数指出从哪个位置开始进行搜索。默认情况下，此位置被置为<strong>0</strong>。一种常见的程序设计模式是用这个可选参数在字符串中循环地搜索子字符串出现的所有位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//每步循环查找name中下一个数</span></span><br><span class="line"><span class="keyword">while</span> ((pos = name.<span class="built_in">find_first_of</span>(numbers, pos)) != string::npos) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;found number at index: &quot;</span> &lt;&lt; pos</span><br><span class="line">         &lt;&lt; <span class="string">&quot; element is &quot;</span> &lt;&lt; name[pos] &lt;&lt; endl;</span><br><span class="line">    ++pos;	<span class="comment">//移动到下一个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>while</code>的循环条件将<code>pos</code>重置为从<code>pos</code>开始遇到的第一个数字的下标。只要<code>find_first_of</code>返回一个合法下标，我们就打印当前结果并递增<code>pos</code>。</p>
<h5 id="compare函数"><a class="markdownIt-Anchor" href="#compare函数"></a> compare函数</h5>
<p>除了关系运算符外，标准库<code>string</code>类型还提供了一组<code>compare</code>函数，这些函数与C标准库的<code>strcmp</code>函数很相似。类似<code>strcmp</code>，根据<code>s</code>是等于、大于还是小于参数指定的字符串，<code>s.compare</code>返回<strong>0</strong>、正数或负数。</p>
<p>如下表所示，<code>compare</code>有<strong>6</strong>个版本。根据我们是要比较两个<code>string</code>还是一个<code>string</code>与一个字符数组，参数各有不同。在这两种情况下，都可以比较整个或一部分字符串。</p>
<table>
<thead>
<tr>
<th></th>
<th>s.compare的几种参数形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>s2</td>
<td>比较<code>s</code>和<code>s2</code></td>
</tr>
<tr>
<td>pos1, n1, s2</td>
<td>将<code>s</code>中从<code>pos1</code>开始的<code>n1</code>个字符与<code>s2</code>进行比较</td>
</tr>
<tr>
<td>pos1, n1, s2, pos2, n2</td>
<td>将<code>s</code>中从<code>pos1</code>开始的<code>n1</code>个字符与<code>s2</code>中从<code>pos2</code>开始的<code>n2</code>个字符进行比较</td>
</tr>
<tr>
<td>cp</td>
<td>比较<code>s</code>与<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td>pos1, n1, cp</td>
<td>将<code>s</code>中从<code>pos1</code>开始的<code>n1</code>个字符与<code>cp</code>指向的以空字符结尾的字符数组进行比较</td>
</tr>
<tr>
<td>pos1, n1, cp, n2</td>
<td>将<code>s</code>中从<code>pos1</code>开始的<code>n1</code>个字符与指针<code>cp</code>指向的地址开始的<code>n2</code>个字符进行比较</td>
</tr>
</tbody>
</table>
<h5 id="数值转换"><a class="markdownIt-Anchor" href="#数值转换"></a> 数值转换</h5>
<p>新标准引入了多个函数，可以实现数值数据与标准库<code>string</code>之间的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">string s = <span class="built_in">to_string</span>(i);	<span class="comment">//将整数i转换为字符表示形式</span></span><br><span class="line"><span class="type">double</span> d = <span class="built_in">stod</span>(s);			<span class="comment">//将字符串s转换为浮点数</span></span><br></pre></td></tr></table></figure>
<p>要转换为数值的<code>string</code>中第一个非空白符必须是数值中可能出现的字符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s2 = <span class="string">&quot;pi = 3.14&quot;</span>;</span><br><span class="line"><span class="comment">//转换s中数字开始的第一个子串，结果d = 3.14</span></span><br><span class="line">d = <span class="built_in">stod</span>(s2.<span class="built_in">substr</span>(s2.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>在这个<code>stod</code>调用中，我们调用了<code>find_first_of</code>来获得中第一个可能是数值的一部分的字符的位置。我们将<code>s</code>中从此位置开始的子串传递<code>stod</code>。<code>stod</code>函数读取此参数，处理其中的字符，直至遇到不可能是数值的一部分的字符然后它就将找到的这个数值的字符串表示形式转换为对应的双精度浮点值。</p>
<p><code>string</code>参数中第一个非空白符必须是符号( + )或( - )或数字。它可以以<strong>0x</strong>或<strong>0X</strong>开头来表示十六进制数。对那些将字符串转换为浮点值的函数，<code>string</code>参数也可以以数点( . )开头，并可以包含<strong>e</strong>或<strong>E</strong>来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，<code>string</code>参数可以包含字母字符，对应大于数字<strong>9</strong>的数。</p>
<blockquote>
<p>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常。如果转换得到的数值无法用任何类型来表示则抛出一个out_of_range异常。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>string和数值之间的转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_string(val)</td>
<td>一组重载函数，返回数值<code>val</code>的<code>string</code>表示。<code>val</code>可以是任何算术类型。对每个浮点类型和<code>int</code>或更大的整型，都有相应版本的<code>to_string</code>。与往常一样，小整型会被提升</td>
</tr>
<tr>
<td>stoi(s, p, b)<br />stol(s, p, b)<br />stoul(s, p, b)<br />stoll(s, p, b)<br />stoull(s, p, b)</td>
<td>返回<code>s</code>的起始子串(表示整数内容)的数值，返回值类型分别是<code>int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code>、<code>unsigned long long</code>。 <code>b</code>表示转换所用的基数，默认值为<strong>10</strong>。<code>p</code>是<code>size_t</code>指针，用来保存<code>s</code>中第一个非数值字符的下标，<code>p</code>默认为<strong>0</strong>，即函数不保存下标</td>
</tr>
<tr>
<td>stof(s, p)<br />stod(s, p)<br />stold(s, p)</td>
<td>返回<code>s</code>的起始子串(表示浮点数内容)的数值，返回值类型分别是<code>float</code>、<code>double</code>或<code>long double</code>。参数<code>p</code>的作用与整数转换函数中一样</td>
</tr>
</tbody>
</table>
<h3 id="容器适配器"><a class="markdownIt-Anchor" href="#容器适配器"></a> 容器适配器</h3>
<p>除了顺序容器外，标准库还定义了三个顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。<strong>适配器</strong>(adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，<code>stack</code>适配器接受一个顺序容器(除<code>array</code>或<code>forward_list</code>外)，并使其操作起来像一个<code>stack</code>一样。下表列出了所有容器适配器都支持的操作和类型。</p>
<table>
<thead>
<tr>
<th></th>
<th>所有容器适配器都支持的操作和类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>size_type</td>
<td>一种类型，足以保存当前类型的最大对象的大小</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>container_type</td>
<td>实现适配器的底层容器类型</td>
</tr>
<tr>
<td>A a;</td>
<td>创建一个名为<code>a</code>的空适配器</td>
</tr>
<tr>
<td>A a©;</td>
<td>创建一个名为<code>a</code>的适配器，带有容器<code>c</code>的一个拷贝</td>
</tr>
<tr>
<td>关系运算符</td>
<td>每个适配器都支持所有关系运算符：==、!=、&lt;、&lt;=、&gt;和&gt;=<br />这些运算符返回底层容器的比较结果</td>
</tr>
<tr>
<td>a.empty()</td>
<td>若<code>a</code>包含任何元素，返回<code>false</code>，否则返回<code>true</code></td>
</tr>
<tr>
<td>a.size()</td>
<td>返回<code>a</code>中的元素数目</td>
</tr>
<tr>
<td>swap(a, b)<br />a.swap(b)</td>
<td>交换<code>a</code>和<code>b</code>的内容，<code>a</code>和<code>b</code>必须有相同类型，包括底层容器类型也必须相同</td>
</tr>
</tbody>
</table>
<h4 id="定义一个适配器"><a class="markdownIt-Anchor" href="#定义一个适配器"></a> 定义一个适配器</h4>
<p>每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。例如，假定<code>deq</code>是一个<code>deque&lt;int&gt;</code>，我们可以用<code>deq</code>来初始化一个新的<code>stack</code>，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>;		<span class="comment">//从deq拷贝元素到stk</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是在<code>vector</code>之上实现的。我们可以在创建一个适配器时将一个顺序容器名作为第二个类型参数，来重载默认容器类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在vector上实现的空栈</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">//str_stk2在vector上实现，初始化时保存sevc的拷贝</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span>(sevc);</span><br></pre></td></tr></table></figure>
<p>对于一个给定的适配器，可以使用哪些容器是有限制的。<strong>stack</strong>只要求<code>push_back</code>、<code>pop_back</code>和<code>back</code>操作，因此可以使用除<code>array</code>和<code>forward_list</code>之外的任何容器类型来构造<code>stack</code>。<strong>queue</strong>适配器要求<code>back</code>、<code>push_back</code>、<code>front</code>和<code>push_front</code>，因此它可以构造于<code>vector</code>、<code>list</code>或<code>deque</code>之上。<strong>priority_queue</strong>除了<code>front</code>、<code>push_back</code>和<code>pop_back</code>操作之外还要求随机访问能力，因此它可以构造于<code>vector</code>或<code>deque</code>之上，但不能基于<code>list</code>构造。</p>
<blockquote>
<p><strong>Note:</strong> 书中有关queue能否用vector构造的阐述前后矛盾，<strong>Luv</strong>实测是可以的。</p>
</blockquote>
<h4 id="栈适配器"><a class="markdownIt-Anchor" href="#栈适配器"></a> 栈适配器</h4>
<p><code>stack</code>类型定义在<code>stack</code>头文件中。下表列出了<code>stack</code>所支持的操作：</p>
<table>
<thead>
<tr>
<th></th>
<th>栈的特殊操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.pop()</td>
<td>删除栈顶元素，但不返回该元素值</td>
</tr>
<tr>
<td>s.push(item)</td>
<td>创建一个新元素压入栈顶，该元素通过拷贝<code>item</code>而来</td>
</tr>
<tr>
<td>s.emplace(<em>args</em>)</td>
<td>创建一个新元素压入栈顶，该元素通过<em>args</em>构造</td>
</tr>
<tr>
<td>s.top()</td>
<td>返回栈顶元素，但不将元素弹出栈</td>
</tr>
</tbody>
</table>
<p>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层容器类型的操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; intStack;		<span class="comment">//空栈</span></span><br><span class="line">intStack.<span class="built_in">push_back</span>(ix);		<span class="comment">//错误，不能直接使用deque操作</span></span><br></pre></td></tr></table></figure>
<h4 id="队列适配器"><a class="markdownIt-Anchor" href="#队列适配器"></a> 队列适配器</h4>
<p><code>queue</code>和<code>priority_queue</code>适配器定义在<code>queue</code>头文件中。下表列出它们所支持的操作：</p>
<table>
<thead>
<tr>
<th></th>
<th>队列的特殊操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>q.pop()</td>
<td>返回<code>queue</code>的首元素或<code>priority_queue</code>的最高优先级的元素，但不删除此元素</td>
</tr>
<tr>
<td>q.front()</td>
<td>返回首元素，但不删除此元素(只适用于<code>queue</code>)</td>
</tr>
<tr>
<td>q.back()</td>
<td>返回尾元素，但不删除此元素(只适用于<code>queue</code>)</td>
</tr>
<tr>
<td>q.top()</td>
<td>返回最高优先级元素，但不删除该元素(只适用于<code>priority_queue</code>)</td>
</tr>
<tr>
<td>q.push(item)</td>
<td>在<code>queue</code>末尾或<code>priority_queue</code>中恰当的位置创建一个元素，其值为<code>item</code></td>
</tr>
<tr>
<td>q.emplace(<em>args</em>)</td>
<td>在<code>queue</code>末尾或<code>priority_queue</code>中恰当的位置创建一个由<em>args</em>构造的元素</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于priority_queue：默认情况下，标准库在元素类型上使用 &lt; 运算符来确定相对优先级。我们将在后面学习如何重载这个默认设置。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luvreadunion.com/2024/03/20/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E5%90%9B%E5%AD%90%E7%BB%88%E6%97%A5%E4%B9%BE%E4%B9%BE/" data-id="cltzgjz8f000b489q1i1p3mzz" data-title="惊变42天: Week 3 君子终日乾乾" class="article-share-link">分享</a>
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%83%8A%E5%8F%9842%E5%A4%A9-C/" rel="tag">惊变42天:C++</a></li></ul>


    </footer>
  </div>
  
    
  <nav id="article-nav" class="wow fadeInUp">
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        <img data-src="/images/65002165.avif" data-sizes="auto" alt="惊变42天: Week 2 见龙在田" class="lazyload">
      
      <a href="/2024/03/10/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          惊变42天: Week 2 见龙在田
        
      </h3>
    </div>
    
  </nav>


  
</article>






</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrap wow fadeInRight wrap-sticky">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%9C%BA%E7%99%BD"><span class="toc-number">1.</span> <span class="toc-text"> 开场白</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-1-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text"> Week 1: 潜龙勿用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-2-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0"><span class="toc-number">3.</span> <span class="toc-text"> Week 2: 见龙在田</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-3-%E5%90%9B%E5%AD%90%E7%BB%88%E6%97%A5%E4%B9%BE%E4%B9%BE"><span class="toc-number">4.</span> <span class="toc-text"> Week 3: 君子终日乾乾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text"> 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1sales_data"><span class="toc-number">4.1.1.1.</span> <span class="toc-text"> 设计Sales_data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%94%B9%E8%BF%9B%E7%9A%84sales_data%E7%B1%BB"><span class="toc-number">4.1.1.2.</span> <span class="toc-text"> 定义改进的Sales_data类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text"> 定义成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5this"><span class="toc-number">4.1.1.2.2.</span> <span class="toc-text"> 引入this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.3.</span> <span class="toc-text"> 引入const成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.4.</span> <span class="toc-text"> 类作用域和成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.5.</span> <span class="toc-text"> 在类的外部定义成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.6.</span> <span class="toc-text"> 定义一个返回this对象的函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.3.</span> <span class="toc-text"> 定义类相关的非成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89read%E5%92%8Cprint%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.3.1.</span> <span class="toc-text"> 定义read和print函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89add%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.3.2.</span> <span class="toc-text"> 定义add函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.4.</span> <span class="toc-text"> 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.4.1.</span> <span class="toc-text"> 合成的默认构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89sales_data%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.4.2.</span> <span class="toc-text"> 定义Sales_data的构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#default-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">4.1.1.4.3.</span> <span class="toc-text"> &#x3D; default 的含义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.1.4.4.</span> <span class="toc-text"> 构造函数初始值列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.4.5.</span> <span class="toc-text"> 在类的外部定义函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 访问控制与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">4.1.2.1.</span> <span class="toc-text"> 友元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 类的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">4.1.3.1.</span> <span class="toc-text"> 定义类型成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E4%BD%9C%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.3.2.</span> <span class="toc-text"> 令成员作为内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">4.1.3.3.</span> <span class="toc-text"> 可变数据成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">4.1.3.4.</span> <span class="toc-text"> 类数据成员的初始值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.3.5.</span> <span class="toc-text"> 连续执行的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Econst%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">4.1.3.6.</span> <span class="toc-text"> 基于const的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.3.7.</span> <span class="toc-text"> 类的声明(不完全类型)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 友元再探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.4.1.</span> <span class="toc-text"> 类之间的友元关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83"><span class="toc-number">4.1.4.2.</span> <span class="toc-text"> 令成员函数作为友元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.1.5.</span> <span class="toc-text"> 类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%98%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%92%E5%B1%9E"><span class="toc-number">4.1.5.1.</span> <span class="toc-text"> 指明返回类型的归属</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="toc-number">4.1.5.2.</span> <span class="toc-text"> 类型名的特殊处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E6%88%90%E5%91%98%E5%90%8D%E5%AD%97%E5%92%8C%E5%8F%82%E6%95%B0%E5%90%8D%E5%AD%97"><span class="toc-number">4.1.5.3.</span> <span class="toc-text"> 区分成员名字和参数名字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E8%99%91%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B9%8B%E5%89%8D%E7%9A%84%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.1.5.4.</span> <span class="toc-text"> 考虑成员函数定义之前的全局作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="toc-number">4.1.6.</span> <span class="toc-text"> 构造函数再探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.6.1.</span> <span class="toc-text"> 初始值列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.6.2.</span> <span class="toc-text"> 委托构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.6.3.</span> <span class="toc-text"> 使用默认构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.4.</span> <span class="toc-text"> 隐式的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E6%AD%A5%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.4.1.</span> <span class="toc-text"> 只允许一步类类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%91%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.4.2.</span> <span class="toc-text"> 抑制构造函数定义的隐式转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.4.3.</span> <span class="toc-text"> 显式地使用构造函数进行转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">4.1.6.5.</span> <span class="toc-text"> 聚合类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-number">4.1.6.6.</span> <span class="toc-text"> 字面值常量类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.1.7.</span> <span class="toc-text"> 类的静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.1.7.1.</span> <span class="toc-text"> 声明静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.1.7.2.</span> <span class="toc-text"> 使用类的静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.1.7.3.</span> <span class="toc-text"> 定义静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.7.4.</span> <span class="toc-text"> 静态成员的类内初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.7.5.</span> <span class="toc-text"> 静态成员的运用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E5%BA%93"><span class="toc-number">4.2.</span> <span class="toc-text"> IO库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E7%B1%BB"><span class="toc-number">4.2.1.</span> <span class="toc-text"> IO类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">4.2.1.1.</span> <span class="toc-text"> IO对象无拷贝和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">4.2.1.2.</span> <span class="toc-text"> 条件状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.2.1.2.1.</span> <span class="toc-text"> 查询流的状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%B5%81%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.2.1.2.2.</span> <span class="toc-text"> 管理流的状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2"><span class="toc-number">4.2.1.3.</span> <span class="toc-text"> 管理输出缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.2.1.3.1.</span> <span class="toc-text"> 刷新输出缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unitbuf%E6%93%8D%E7%BA%B5%E7%AC%A6"><span class="toc-number">4.2.1.3.2.</span> <span class="toc-text"> unitbuf操纵符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">4.2.1.3.3.</span> <span class="toc-text"> 关联输入流和输出流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 文件输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.2.1.</span> <span class="toc-text"> 使用文件流对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8fstream%E4%BB%A3%E6%9B%BFiostream"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text"> 用fstream代替iostream&amp;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0open%E5%92%8Cclose"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text"> 成员函数open和close</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">4.2.2.1.3.</span> <span class="toc-text"> 自动构造和析构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.2.2.</span> <span class="toc-text"> 文件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A5out%E6%A8%A1%E5%BC%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%B7%B2%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.2.2.1.</span> <span class="toc-text"> 以out模式打开文件会丢失已有数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E6%B5%81"><span class="toc-number">4.2.3.</span> <span class="toc-text"> string流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text"> 顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 顺序容器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%93%E5%85%B1%E6%9C%89%E7%9A%84%E6%93%8D%E4%BD%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 容器库共有的操作概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.3.2.1.</span> <span class="toc-text"> 迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">4.3.2.2.</span> <span class="toc-text"> 容器类型成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%87%E7%9A%84begin%E5%92%8Cend"><span class="toc-number">4.3.2.3.</span> <span class="toc-text"> 重载过的begin和end</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.3.2.4.</span> <span class="toc-text"> 容器定义和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.3.2.4.1.</span> <span class="toc-text"> 将一个容器初始化为另一个容器的拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93array%E5%85%B7%E6%9C%89%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.3.2.4.2.</span> <span class="toc-text"> 标准库array具有固定大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8assign%E4%BB%85%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.2.4.3.</span> <span class="toc-text"> 使用assign(仅顺序容器)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8swap"><span class="toc-number">4.3.2.4.4.</span> <span class="toc-text"> 使用swap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.3.2.4.5.</span> <span class="toc-text"> 关系运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 顺序容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.3.1.</span> <span class="toc-text"> 向顺序容器添加元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.3.1.1.</span> <span class="toc-text"> 在容器中的特定位置添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8insert%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.3.3.1.2.</span> <span class="toc-text"> 使用insert的返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8emplace%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.3.1.3.</span> <span class="toc-text"> 使用emplace操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.3.2.</span> <span class="toc-text"> 访问元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%92%8Cat%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.3.2.1.</span> <span class="toc-text"> 安全的随机访问和at成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.3.3.</span> <span class="toc-text"> 删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84forward_list%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.3.4.</span> <span class="toc-text"> 特殊的forward_list操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.3.3.5.</span> <span class="toc-text"> 改变容器大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">4.3.3.6.</span> <span class="toc-text"> 容器操作可能使迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">4.3.4.</span> <span class="toc-text"> vector容器空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.5.</span> <span class="toc-text"> 额外的string操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.5.1.</span> <span class="toc-text"> 构造string的其他方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.5.2.</span> <span class="toc-text"> 改变string的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84insert-assign%E5%92%8Cerase%E7%89%88%E6%9C%AC"><span class="toc-number">4.3.5.2.1.</span> <span class="toc-text"> 额外的insert、assign和erase版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#append%E5%92%8Crelapce%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.5.2.2.</span> <span class="toc-text"> append和relapce函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.5.2.3.</span> <span class="toc-text"> string搜索操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#compare%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.5.2.4.</span> <span class="toc-text"> compare函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.5.2.5.</span> <span class="toc-text"> 数值转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.6.</span> <span class="toc-text"> 容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.6.1.</span> <span class="toc-text"> 定义一个适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.6.2.</span> <span class="toc-text"> 栈适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.6.3.</span> <span class="toc-text"> 队列适配器</span></a></li></ol></li></ol></li></ol></li></ol></div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/lian.gif" data-sizes="auto" alt="Luv" class="lazyload">
  <div class="sidebar-author-name">Luv</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">6</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">6</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>
</div>
    
    
      <div class="sidebar-btn-wrapper" style="position:static">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  </div>

  
</aside>

          
        </div>
        <footer id="footer" class="wow fadeInUp">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="outer">
    <div id="footer-info" class="inner">
      
      <div>
        <span class="icon-copyright"></span>
        2020-2024
        <span class="footer-info-sep"></span>
        Luv
      </div>
      
        <div>
          基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
          Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
        </div>
      
      
        <div>
          <span class="icon-brush"></span>
          73.2k
          &nbsp;|&nbsp;
          <span class="icon-coffee"></span>
          04:30
        </div>
      
      
        <div>
          <span class="icon-eye"></span>
          <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
          &nbsp;|&nbsp;
          <span class="icon-user"></span>
          <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
        </div>
      
    </div>
  </div>
</footer>

        <div class="sidebar-top">
          <img src="/images/taichi.png" height="50" width="50" />
          <div class="arrow-up"></div>
        </div>
        <div id="mask"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%9C%BA%E7%99%BD"><span class="toc-number">1.</span> <span class="toc-text"> 开场白</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-1-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text"> Week 1: 潜龙勿用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-2-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0"><span class="toc-number">3.</span> <span class="toc-text"> Week 2: 见龙在田</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-3-%E5%90%9B%E5%AD%90%E7%BB%88%E6%97%A5%E4%B9%BE%E4%B9%BE"><span class="toc-number">4.</span> <span class="toc-text"> Week 3: 君子终日乾乾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text"> 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1sales_data"><span class="toc-number">4.1.1.1.</span> <span class="toc-text"> 设计Sales_data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%94%B9%E8%BF%9B%E7%9A%84sales_data%E7%B1%BB"><span class="toc-number">4.1.1.2.</span> <span class="toc-text"> 定义改进的Sales_data类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text"> 定义成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5this"><span class="toc-number">4.1.1.2.2.</span> <span class="toc-text"> 引入this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.3.</span> <span class="toc-text"> 引入const成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.4.</span> <span class="toc-text"> 类作用域和成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.5.</span> <span class="toc-text"> 在类的外部定义成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.6.</span> <span class="toc-text"> 定义一个返回this对象的函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.3.</span> <span class="toc-text"> 定义类相关的非成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89read%E5%92%8Cprint%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.3.1.</span> <span class="toc-text"> 定义read和print函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89add%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.3.2.</span> <span class="toc-text"> 定义add函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.4.</span> <span class="toc-text"> 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.4.1.</span> <span class="toc-text"> 合成的默认构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89sales_data%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.4.2.</span> <span class="toc-text"> 定义Sales_data的构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#default-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">4.1.1.4.3.</span> <span class="toc-text"> &#x3D; default 的含义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.1.4.4.</span> <span class="toc-text"> 构造函数初始值列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.4.5.</span> <span class="toc-text"> 在类的外部定义函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 访问控制与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">4.1.2.1.</span> <span class="toc-text"> 友元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 类的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">4.1.3.1.</span> <span class="toc-text"> 定义类型成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E4%BD%9C%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.3.2.</span> <span class="toc-text"> 令成员作为内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">4.1.3.3.</span> <span class="toc-text"> 可变数据成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">4.1.3.4.</span> <span class="toc-text"> 类数据成员的初始值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.3.5.</span> <span class="toc-text"> 连续执行的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Econst%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">4.1.3.6.</span> <span class="toc-text"> 基于const的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.3.7.</span> <span class="toc-text"> 类的声明(不完全类型)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 友元再探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.4.1.</span> <span class="toc-text"> 类之间的友元关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83"><span class="toc-number">4.1.4.2.</span> <span class="toc-text"> 令成员函数作为友元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.1.5.</span> <span class="toc-text"> 类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%98%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%92%E5%B1%9E"><span class="toc-number">4.1.5.1.</span> <span class="toc-text"> 指明返回类型的归属</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="toc-number">4.1.5.2.</span> <span class="toc-text"> 类型名的特殊处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E6%88%90%E5%91%98%E5%90%8D%E5%AD%97%E5%92%8C%E5%8F%82%E6%95%B0%E5%90%8D%E5%AD%97"><span class="toc-number">4.1.5.3.</span> <span class="toc-text"> 区分成员名字和参数名字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E8%99%91%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B9%8B%E5%89%8D%E7%9A%84%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.1.5.4.</span> <span class="toc-text"> 考虑成员函数定义之前的全局作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="toc-number">4.1.6.</span> <span class="toc-text"> 构造函数再探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.6.1.</span> <span class="toc-text"> 初始值列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.6.2.</span> <span class="toc-text"> 委托构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.6.3.</span> <span class="toc-text"> 使用默认构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.4.</span> <span class="toc-text"> 隐式的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E6%AD%A5%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.4.1.</span> <span class="toc-text"> 只允许一步类类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%91%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.4.2.</span> <span class="toc-text"> 抑制构造函数定义的隐式转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.6.4.3.</span> <span class="toc-text"> 显式地使用构造函数进行转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">4.1.6.5.</span> <span class="toc-text"> 聚合类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-number">4.1.6.6.</span> <span class="toc-text"> 字面值常量类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.1.7.</span> <span class="toc-text"> 类的静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.1.7.1.</span> <span class="toc-text"> 声明静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.1.7.2.</span> <span class="toc-text"> 使用类的静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">4.1.7.3.</span> <span class="toc-text"> 定义静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.7.4.</span> <span class="toc-text"> 静态成员的类内初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.7.5.</span> <span class="toc-text"> 静态成员的运用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E5%BA%93"><span class="toc-number">4.2.</span> <span class="toc-text"> IO库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E7%B1%BB"><span class="toc-number">4.2.1.</span> <span class="toc-text"> IO类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">4.2.1.1.</span> <span class="toc-text"> IO对象无拷贝和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">4.2.1.2.</span> <span class="toc-text"> 条件状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.2.1.2.1.</span> <span class="toc-text"> 查询流的状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%B5%81%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.2.1.2.2.</span> <span class="toc-text"> 管理流的状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2"><span class="toc-number">4.2.1.3.</span> <span class="toc-text"> 管理输出缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.2.1.3.1.</span> <span class="toc-text"> 刷新输出缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unitbuf%E6%93%8D%E7%BA%B5%E7%AC%A6"><span class="toc-number">4.2.1.3.2.</span> <span class="toc-text"> unitbuf操纵符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">4.2.1.3.3.</span> <span class="toc-text"> 关联输入流和输出流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 文件输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.2.1.</span> <span class="toc-text"> 使用文件流对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8fstream%E4%BB%A3%E6%9B%BFiostream"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text"> 用fstream代替iostream&amp;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0open%E5%92%8Cclose"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text"> 成员函数open和close</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">4.2.2.1.3.</span> <span class="toc-text"> 自动构造和析构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.2.2.</span> <span class="toc-text"> 文件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A5out%E6%A8%A1%E5%BC%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%B7%B2%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.2.2.1.</span> <span class="toc-text"> 以out模式打开文件会丢失已有数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E6%B5%81"><span class="toc-number">4.2.3.</span> <span class="toc-text"> string流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text"> 顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 顺序容器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%93%E5%85%B1%E6%9C%89%E7%9A%84%E6%93%8D%E4%BD%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 容器库共有的操作概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.3.2.1.</span> <span class="toc-text"> 迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">4.3.2.2.</span> <span class="toc-text"> 容器类型成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%87%E7%9A%84begin%E5%92%8Cend"><span class="toc-number">4.3.2.3.</span> <span class="toc-text"> 重载过的begin和end</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.3.2.4.</span> <span class="toc-text"> 容器定义和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.3.2.4.1.</span> <span class="toc-text"> 将一个容器初始化为另一个容器的拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93array%E5%85%B7%E6%9C%89%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.3.2.4.2.</span> <span class="toc-text"> 标准库array具有固定大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8assign%E4%BB%85%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.2.4.3.</span> <span class="toc-text"> 使用assign(仅顺序容器)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8swap"><span class="toc-number">4.3.2.4.4.</span> <span class="toc-text"> 使用swap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.3.2.4.5.</span> <span class="toc-text"> 关系运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 顺序容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.3.1.</span> <span class="toc-text"> 向顺序容器添加元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.3.1.1.</span> <span class="toc-text"> 在容器中的特定位置添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8insert%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.3.3.1.2.</span> <span class="toc-text"> 使用insert的返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8emplace%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.3.1.3.</span> <span class="toc-text"> 使用emplace操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.3.2.</span> <span class="toc-text"> 访问元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%92%8Cat%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.3.2.1.</span> <span class="toc-text"> 安全的随机访问和at成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.3.3.</span> <span class="toc-text"> 删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84forward_list%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.3.4.</span> <span class="toc-text"> 特殊的forward_list操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.3.3.5.</span> <span class="toc-text"> 改变容器大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">4.3.3.6.</span> <span class="toc-text"> 容器操作可能使迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">4.3.4.</span> <span class="toc-text"> vector容器空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.5.</span> <span class="toc-text"> 额外的string操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.5.1.</span> <span class="toc-text"> 构造string的其他方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.5.2.</span> <span class="toc-text"> 改变string的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84insert-assign%E5%92%8Cerase%E7%89%88%E6%9C%AC"><span class="toc-number">4.3.5.2.1.</span> <span class="toc-text"> 额外的insert、assign和erase版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#append%E5%92%8Crelapce%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.5.2.2.</span> <span class="toc-text"> append和relapce函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.5.2.3.</span> <span class="toc-text"> string搜索操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#compare%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.5.2.4.</span> <span class="toc-text"> compare函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.5.2.5.</span> <span class="toc-text"> 数值转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.6.</span> <span class="toc-text"> 容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.6.1.</span> <span class="toc-text"> 定义一个适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.6.2.</span> <span class="toc-text"> 栈适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.6.3.</span> <span class="toc-text"> 队列适配器</span></a></li></ol></li></ol></li></ol></li></ol></div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/lian.gif" data-sizes="auto" alt="Luv" class="lazyload">
  <div class="sidebar-author-name">Luv</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">6</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">6</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    <div class="site-search">
      <div class="reimu-popup popup">
        <div class="reimu-search">
          <span class="reimu-search-input-icon"></span>
          <div class="reimu-search-input" id="reimu-search-input"></div>
        </div>
        <div class="reimu-results">
          <div id="reimu-stats"></div>
          <div id="reimu-hits"></div>
          <div id="reimu-pagination" class="reimu-pagination"></div>
        </div>
        <span class="popup-btn-close"></span>
      </div>
    </div>
    
<script src="https://npm.webcache.cn/jquery@3.7.1/dist/jquery.min.js"></script>


<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script>



  
<script src="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script>




  
<script src="https://npm.webcache.cn/mermaid@9.4.3/dist/mermaid.min.js"></script>

  <script>
    if (window.mermaid) {
      // https://github.com/mermaid-js/mermaid/issues/1945
      const elementCode = '.mermaid'
      const saveOriginalData = () => {
        return new Promise((resolve, reject) => {
          try {
            var els = document.querySelectorAll(elementCode),
                count = els.length;
            els.forEach(element => {
              if (element.getAttribute('data-original-code') == null){
                element.setAttribute('data-original-code', element.innerHTML)
              }
              count--
              if(count == 0){
                resolve()
              }
            });
          } catch (error) {
          reject(error) 
          }
        })
      }
      const resetProcessed = () => {
        return new Promise((resolve, reject) => {
          try {
            var els = document.querySelectorAll(elementCode),
                count = els.length;
            els.forEach(element => {
              if(element.getAttribute('data-original-code') != null){
                element.removeAttribute('data-processed')
                element.innerHTML = element.getAttribute('data-original-code')
              }
              count--
              if(count == 0){
                resolve()
              }
            });
          } catch (error) {
          reject(error) 
          }
        })
      } 
      const loadMermaid = (theme) => {
        window.mermaid.initialize({theme})
        window.mermaid.init({theme}, document.querySelectorAll(elementCode))
      }
      document.body.addEventListener('dark-theme-set', () => {
        saveOriginalData()
        .then(resetProcessed())
        .then(loadMermaid('dark'))
        .catch(console.error)
      })
      document.body.addEventListener('light-theme-set', () => {
        saveOriginalData()
        .then(resetProcessed())
        .then(loadMermaid('default'))
        .catch(console.error)
      })
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>















  
<script src="https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js"></script>

  
<script src="https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js"></script>

  
<script src="/js/algolia_search.js"></script>

  <script>
    var CONFIG = {
      root: '/',
      algolia: {
        applicationID: "37ZQYZE607",
        apiKey: "dfdbcdcf987c68afcf35a63def2936e2",
        indexName: "Luv",
        hits: {
          "per_page": parseInt("10")
        },
        labels: {
          "input_placeholder": "搜索.....",
          "hits_empty": "未发现与 「${query}」相关内容",
          "hits_stats": "找到${hits}条结果（用时 ${time} ms）"
        }
      }
    };
  </script>



  
<script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script>

  <script>
    firework(JSON.parse('{"excludeElements":["a"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>







<script src="/js/script.js"></script>



  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '0.1.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  

  <!-- hexo injector body_end start -->
<script src="/js/insert_highlight.js" data-pjax></script>
<!-- hexo injector body_end end --></body>
  </html>

