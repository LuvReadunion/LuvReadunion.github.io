
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <title>
    惊变42天: Week 2 见龙在田 |
    
    Luv Read Union
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
<link rel="stylesheet" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/regular.min.css">
<link rel="stylesheet" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/solid.min.css">

  <link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/brands.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;"><link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/v5-font-face.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;"><link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/v4-font-face.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
<link rel="stylesheet" href="/css/loader.css">

  <meta name="description" content="开场白 相比于第一周，第二周刚开始就举步维艰。 课余的空闲时间减少、课程作业变多、阅读的信息量增大…… 同样是三个章节的跨度，第二周需要新学的东西多了很多，笔记的篇幅也相应地增长，甚至已经没法做到“一天20面”的可能了。 预期是第二周完成第七章，看来也必须放在第三周了。 不过， 那又如何呢？ 无非是完成得更晚一点罢了。 ~o( &#x3D;∩ω∩&#x3D; )m 万一禅关砉然破，美人如玉剑如虹。  Week 1:">
<meta property="og:type" content="article">
<meta property="og:title" content="惊变42天: Week 2 见龙在田">
<meta property="og:url" content="https://luvreadunion.com/2024/03/10/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0/index.html">
<meta property="og:site_name" content="Luv Read Union">
<meta property="og:description" content="开场白 相比于第一周，第二周刚开始就举步维艰。 课余的空闲时间减少、课程作业变多、阅读的信息量增大…… 同样是三个章节的跨度，第二周需要新学的东西多了很多，笔记的篇幅也相应地增长，甚至已经没法做到“一天20面”的可能了。 预期是第二周完成第七章，看来也必须放在第三周了。 不过， 那又如何呢？ 无非是完成得更晚一点罢了。 ~o( &#x3D;∩ω∩&#x3D; )m 万一禅关砉然破，美人如玉剑如虹。  Week 1:">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-10T11:58:21.000Z">
<meta property="article:modified_time" content="2024-03-10T12:16:25.029Z">
<meta property="article:author" content="Luv">
<meta property="article:tag" content="惊变42天:C++">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Luv Read Union" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/typeface-source-code-pro@1.1.13/index.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css">

  
  
  
  
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script>

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/wowjs@1.1.3/css/libs/animate.css">

    
<script src="https://npm.webcache.cn/wowjs@1.1.3/dist/wow.min.js"></script>

    <script>
      new WOW({
        offset: 0,
        mobile: true,
        live: false
      }).init();
    </script>
  
  
    <script src="/sw.js"></script>
  
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg"></div>
    <div class="loading-right-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
          <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
          <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
          <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
        </svg>
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    const startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    const endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('load', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/">首页</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/archives">归档</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/about">关于</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/friend">友链</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
    
    
      <a id="nav-search-btn" class="nav-icon popup-trigger" title="搜索"></a>
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="/images/65002165.avif" alt="惊变42天: Week 2 见龙在田">
  
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div id="logo-wrap">
        
          
          
            <a href="/" id="logo">
              <h1>惊变42天: Week 2 见龙在田</h1>
            </a>
          
        
      </div>
      
        
        <h2 id="subtitle-wrap">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="outer">
          
          <section id="main"><article id="post-惊变42天-C++-见龙在田" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    <div class="article-meta">
      <div class="article-date wow slideInLeft">
  <a href="/2024/03/10/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0/" class="article-date-link">
    <time datetime="2024-03-10T11:58:21.000Z" itemprop="datePublished">2024-03-10</time>
  </a>
</div>

      
  <div class="article-category wow slideInLeft">
    <a class="article-category-link" href="/categories/C/">C++</a><a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="开场白"><a class="markdownIt-Anchor" href="#开场白"></a> 开场白</h1>
<p>相比于第一周，第二周刚开始就<strong>举步维艰</strong>。</p>
<p>课余的空闲时间减少、课程作业变多、阅读的信息量增大……</p>
<p>同样是三个章节的跨度，第二周需要新学的东西多了很多，笔记的篇幅也相应地增长，甚至已经没法做到“<strong>一天20面</strong>”的可能了。</p>
<p>预期是第二周完成第七章，看来也必须放在第三周了。</p>
<p>不过，</p>
<p><strong>那又如何呢？</strong></p>
<p><strong>无非</strong>是完成得<strong>更晚一点</strong>罢了。</p>
<p><strong>~o( =∩ω∩= )m</strong></p>
<p><strong>万一禅关砉然破，美人如玉剑如虹。</strong></p>
<h1 id="week-1-潜龙勿用"><a class="markdownIt-Anchor" href="#week-1-潜龙勿用"></a> Week 1: 潜龙勿用</h1>
<p>点击跳转<a href="/2024/03/02/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8/">第一期内容：潜龙勿用</a></p>
<h1 id="week-2-见龙在田"><a class="markdownIt-Anchor" href="#week-2-见龙在田"></a> Week 2: 见龙在田</h1>
<h2 id="表达式"><a class="markdownIt-Anchor" href="#表达式"></a> 表达式</h2>
<p>表达式由一个或多个<strong>运算对象</strong>(operand)组成，对表达式求值将得到一个<strong>结果</strong>(result)。字面值和变量是最简单的<strong>表达式</strong>(expression)，其结果就是字面值和变量的值。把一个<strong>运算符</strong>(operator)和一个或多个运算对象组合起来可以生成较复杂度表达式。</p>
<blockquote>
<p>本章节在书中的内容与C语言基础知识高度重合，笔记也因此省略了很多。</p>
</blockquote>
<h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3>
<h4 id="重载运算符"><a class="markdownIt-Anchor" href="#重载运算符"></a> 重载运算符</h4>
<p>当运算符作用于类类型的运算对象时，用户可以自行定义其含义，成为<strong>重载运算符</strong>(overloaded operator)。IO库的 <strong>&gt;&gt;</strong> 和 <strong>&lt;&lt;</strong> 运算符以及<strong>string</strong>对象、<strong>vector</strong>对象和迭代器使用的运算符都是重载的运算符。</p>
<p>我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p>
<h4 id="左值和右值"><a class="markdownIt-Anchor" href="#左值和右值"></a> 左值和右值</h4>
<p><strong>左值</strong>(rvalue)和<strong>右值</strong>(lvalue)的概念是从C语言继承过来的。一般来说，在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用。</p>
<p>使用<strong>decltype</strong>关键字时，左值和右值有所不同。如果表达式的求值结果是左值，<strong>decltype</strong>作用于该表达式(不是变量)得到一个引用类型。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1 = <span class="number">42</span> , a2 = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a1;</span><br><span class="line"><span class="keyword">decltype</span> ( *p ) a3 = a2;		<span class="comment">//得到引用类型，a3是a2的引用</span></span><br></pre></td></tr></table></figure>
<p>另一方面，因为取地址运算符生成右值，所以<code>decltype(&amp;p)</code>的结果是<code>int**</code>，也就是说，结果是一个指向整形指针的指针。</p>
<h3 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h3>
<p>算术运算符的运算对象和求值结果都是右值。</p>
<h4 id="除法和取余"><a class="markdownIt-Anchor" href="#除法和取余"></a> 除法和取余</h4>
<p>C++11新标准规定：</p>
<p>除法运算中，商一律向<strong>0</strong>取整(即直接切除小数部分)。</p>
<p>加入取余运算后，除了-m导致溢出的特殊情况，其他时候<code>(-m)/n</code>和<code>m/(-n)</code>都等于-<code>(m/n)</code>，<code>m%(-n)</code>等于<code>m%n</code>，<code>(-m)%n</code>等于<code>-(m%n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span> % <span class="number">6</span>;  	<span class="comment">/* 结果是3 */</span>		<span class="number">21</span> / <span class="number">6</span>;  	<span class="comment">/* 结果是3 */</span></span><br><span class="line"><span class="number">21</span> % <span class="number">7</span>;  	<span class="comment">/* 结果是0 */</span>		<span class="number">21</span> / <span class="number">7</span>;  	<span class="comment">/* 结果是3 */</span></span><br><span class="line"><span class="number">-21</span> % <span class="number">-8</span>;  	<span class="comment">/* 结果是-5 */</span>		<span class="number">-21</span> / <span class="number">-8</span>;  	<span class="comment">/* 结果是2 */</span></span><br><span class="line"><span class="number">21</span> % <span class="number">-5</span>;  	<span class="comment">/* 结果是1 */</span>		<span class="number">21</span> / <span class="number">-5</span>;  	<span class="comment">/* 结果是-4 */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果m%n不等于0，则它的符号和m相同。</p>
</blockquote>
<h3 id="逻辑和关系运算符"><a class="markdownIt-Anchor" href="#逻辑和关系运算符"></a> 逻辑和关系运算符</h3>
<h4 id="逻辑与和逻辑或运算符"><a class="markdownIt-Anchor" href="#逻辑与和逻辑或运算符"></a> 逻辑与和逻辑或运算符</h4>
<p>逻辑与(&amp;&amp;)和逻辑或(||)运算符都是先求左侧运算对象的值再求右侧运算对象的值，<strong>当且仅当</strong>左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为<strong>短路求值</strong>(short-circuit evaluation)。</p>
<p>举一个使用逻辑或的例子：</p>
<p>假定有一个存储着若干<code>string</code>对象的<code>vector</code>对象，要求输出<code>string</code>对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。使用基于范围的<code>for</code>循环处理<code>string</code>对象中的每个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s是对常量的引用；元素既没有被拷贝也没有被改变</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">const</span> <span class="keyword">auto</span> &amp;s : text ) &#123;		<span class="comment">//对于text的每个元素</span></span><br><span class="line">    cout &lt;&lt; s;						<span class="comment">//输出当前元素</span></span><br><span class="line">    <span class="comment">//遇到空字符串或者以句号结束的字符串进行换行</span></span><br><span class="line">    <span class="keyword">if</span> ( s.<span class="built_in">empty</span>() || s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span>;				<span class="comment">//否则用空格隔开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h4>
<p>关系运算符比较运算对象的大小并返回布尔值。关系运算符都满足<strong>左结合律</strong>。</p>
<h3 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h3>
<p>赋值运算的结果是它的左侧运算对象，并且是一个左值，类型即左侧运算对象的类型。如果左右运算对象类型不同，则右侧运算对象转换成左侧运算对象的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">k = <span class="number">3.14</span>;			<span class="comment">//结果：类型是int，值是3</span></span><br></pre></td></tr></table></figure>
<p>C++11新标准允许使用花括号括起来的初始值列表作为赋值运算语句的右侧运算对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k = &#123;<span class="number">3.14</span>&#125;;						<span class="comment">//错误：窄化转换</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi;					<span class="comment">//初始为空</span></span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;		<span class="comment">//vi现在含有10个元素了，值从0到9</span></span><br></pre></td></tr></table></figure>
<p>如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话也不应该大于目标类型的空间。</p>
<blockquote>
<p>vector模板重载了赋值运算符并且可以接受初始值列表，当赋值发生时用右侧运算对象的元素替换左侧运算对象的元素。</p>
</blockquote>
<p>赋值运算满足右结合律：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival , jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;		<span class="comment">//正确，都被赋值为0</span></span><br></pre></td></tr></table></figure>
<h4 id="赋值运算优先级较低"><a class="markdownIt-Anchor" href="#赋值运算优先级较低"></a> 赋值运算优先级较低</h4>
<p>因为赋值运算优先级相对较低，所以将其放在条件中时，需要加上括号。</p>
<p>将赋值语句放在条件当中是很好的写法，以下是示例，其中循环的目的是反复调用一个函数直到返回期望的值为止：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一种繁琐、容易出错的写法</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">get_value</span>();			<span class="comment">//得到第一个值</span></span><br><span class="line"><span class="keyword">while</span> ( i != <span class="number">42</span> ) &#123;</span><br><span class="line">    <span class="comment">//其他处理……</span></span><br><span class="line">    i = <span class="built_in">get_value</span>();			<span class="comment">//得到剩下的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更好的写法：条件部分表达得更加清晰</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> ( ( i = <span class="built_in">get_value</span>() ) != <span class="number">42</span> ) &#123;</span><br><span class="line">	<span class="comment">//其他处理……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个版本的<code>while</code>条件更容易表达我们的真实意图：不断循环读取数据直到遇到<code>42</code>为止。</p>
<h3 id="递增和递减运算符"><a class="markdownIt-Anchor" href="#递增和递减运算符"></a> 递增和递减运算符</h3>
<blockquote>
<p><strong>Tip:</strong> 非必需情况下，不使用递增递减运算符的后置版本。由于需要保存被改变量的原始值，在不需要原始值的情况下使用后置版本的操作就是一种浪费。这种浪费对于复杂的迭代器类型可能开销巨大。</p>
<p>建议养成使用前置版本的习惯。</p>
</blockquote>
<h4 id="在一条语句中混用解引用和递增运算符"><a class="markdownIt-Anchor" href="#在一条语句中混用解引用和递增运算符"></a> 在一条语句中混用解引用和递增运算符</h4>
<p>这里使用需要后置版本的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//输出元素直至遇到第一个负值为止</span></span><br><span class="line"><span class="keyword">while</span> ( pbeg != v.<span class="built_in">end</span>() &amp;&amp; *pbeg &gt;= <span class="number">0</span> )</span><br><span class="line">    cout &lt;&lt; *pbeg++ &lt;&lt; endl;	<span class="comment">//输出当前值并将pbeg向前移动一个元素</span></span><br></pre></td></tr></table></figure>
<p>后置递增运算符的优先级高于解引用运算符。因此 <code>*pbeg++</code> 等价于 <code>*(pbeg++)</code> 。</p>
<blockquote>
<p><strong>Tip:</strong> 形如 *pbeg++ 的表达式一开始可能不太容易理解，但其实这是一种被广泛使用的、有效的写法。当这种形式熟悉之后，书写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *iter++ &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>要比书写下面的等价语句更简洁、也更少出错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">++iter;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="条件运算符"><a class="markdownIt-Anchor" href="#条件运算符"></a> 条件运算符</h3>
<p>条件运算符( ? : )允许我们把简单的<strong>if-else</strong>逻辑嵌入到单个表达式当中，按如下形式使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure>
<p><code>cond</code>是判断条件的表达式，而<code>expr1</code>和<code>expr2</code>是两个类型相同或可能转换为某个公共类型的表达式。条件运算符同样使用<strong>短路求值</strong>的策略。</p>
<h4 id="嵌套条件运算符"><a class="markdownIt-Anchor" href="#嵌套条件运算符"></a> 嵌套条件运算符</h4>
<p>允许在条件运算符的内部嵌套另一个条件运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string finalgrade = ( grade &gt; <span class="number">90</span> ) ? <span class="string">&quot;high pass&quot;</span></span><br><span class="line">    					: ( grade &lt; <span class="number">60</span> ) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>条件运算符满足<strong>右结合律</strong>，意味着运算对象(一般)按照从右向左的顺序组合。因此在上述代码中，靠右边的条件运算构成了靠左边的条件运算的 : 分支</p>
<h4 id="在输出表达式中使用条件运算符"><a class="markdownIt-Anchor" href="#在输出表达式中使用条件运算符"></a> 在输出表达式中使用条件运算符</h4>
<p>条件运算符的优先级非常低，通常需要在两端加上括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ( ( grade &lt; <span class="number">60</span> ) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span> );	<span class="comment">//输出pass或者fail</span></span><br><span class="line">cout &lt;&lt; ( grade &lt; <span class="number">60</span> ) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;	<span class="comment">//输出0或1</span></span><br><span class="line">cout &lt;&lt; grade &lt; <span class="number">60</span> ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;		<span class="comment">//错误，试图比较cout和60</span></span><br></pre></td></tr></table></figure>
<p>其中，第二条表达式等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ( grade &lt; <span class="number">60</span> );	  <span class="comment">//输出0或1</span></span><br><span class="line">cout ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;	  <span class="comment">//根据cout的值是true还是false产生对应的字面值</span></span><br></pre></td></tr></table></figure>
<p>第三条表达式等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; grade;		<span class="comment">//小于运算符的优先级低于移位运算符，所以先输出grade</span></span><br><span class="line">cout &lt; <span class="number">60</span> ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;	<span class="comment">//然后比较cout和60</span></span><br></pre></td></tr></table></figure>
<h3 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h3>
<p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。</p>
<p>一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且，此时的左移操作可能会改变符号的值，因此是一种未定义的行为。</p>
<blockquote>
<p>移位运算符(又叫IO运算符)满足左结合律。</p>
</blockquote>
<h3 id="sizeof运算符"><a class="markdownIt-Anchor" href="#sizeof运算符"></a> sizeof运算符</h3>
<p><strong>sizeof</strong>运算符返回一条表达式或一个类型名字所占的字节数。<code>sizeof</code>满足右结合律，其所得到的值是一个<code>size_t</code>类型的常量表达式。</p>
<p>该运算符的运算对象有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (type)		 		<span class="keyword">sizeof</span> expr</span><br></pre></td></tr></table></figure>
<p>在第二种形式中，<code>sizeof</code>返回的是表达式结果类型的大小，而且<code>sizeof</code>并不会实际计算其运算对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data , *p;</span><br><span class="line"><span class="built_in">sizeof</span>( Sales_data );		<span class="comment">//存储Sales_data类型的对象所占的空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;				<span class="comment">//data的类型的大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> p;					<span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;					<span class="comment">//p所指类型的空间大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue;		<span class="comment">//Sales_data的revenue成员对应类型的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> Sales_data::revenue;	<span class="comment">//另一种获取revenue大小的方式(无须提供一个具体的对象)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 <code>sizeof *p</code> ：首先，因为sizeof满足右结合律并且与 * 运算符的优先级一样，所以等价于 <code>sizeof(*p)</code> 。其次，因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为。</p>
</blockquote>
<p><code>sizeof</code>运算符的结果部分地依赖于其作用的类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">得到的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char类型 或 类型为char的表达式</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">引用类型</td>
<td style="text-align:center">被引用对象所占空间大小</td>
</tr>
<tr>
<td style="text-align:center">指针</td>
<td style="text-align:center">指针本身所占空间大小</td>
</tr>
<tr>
<td style="text-align:center">解引用指针</td>
<td style="text-align:center">指针指向的对象所占空间大小，指针不需有效</td>
</tr>
<tr>
<td style="text-align:center">数组</td>
<td style="text-align:center">整个数组所占空间大小</td>
</tr>
<tr>
<td style="text-align:center">string对象或vector对象</td>
<td style="text-align:center">该类型固定部分的大小</td>
</tr>
</tbody>
</table>
<p>对数组执行<code>sizeof</code>的结果等价于对数组中所有元素各执行一次<code>sizeof</code>运算并求和，注意，<code>sizeof</code>运算并不会把数组转换成指针来处理。</p>
<blockquote>
<p>因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sizeof(ia)/sizeof(*ia)返回ia的元素数量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia)/<span class="built_in">sizeof</span>(*ia);</span><br><span class="line"><span class="type">int</span> arr2[sz];		<span class="comment">//正确，sizeof返回一个常量表达式</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="逗号运算符"><a class="markdownIt-Anchor" href="#逗号运算符"></a> 逗号运算符</h3>
<p><strong>逗号运算符</strong>(comma operator)含有两个运算对象，按照从左往右的顺序依次求值。</p>
<p>对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终求值结果也是左值。</p>
<p>逗号运算符常被用在for循环当中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type cnt = ivec.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//将把从size到1的值赋给ivec的元素</span></span><br><span class="line"><span class="keyword">for</span> ( vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span> ; ix != ivec.<span class="built_in">size</span>() ; ++ix , --cnt )</span><br><span class="line">    ivec[ix] = cnt;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h3>
<p>如果两种类型之间可以<strong>相互转换</strong>(conversion)，那么它们就是关联的。</p>
<h4 id="算术转换"><a class="markdownIt-Anchor" href="#算术转换"></a> 算术转换</h4>
<p>把一种算术类型转换成另一种算术类型。</p>
<h5 id="整型提升"><a class="markdownIt-Anchor" href="#整型提升"></a> 整型提升</h5>
<p><strong>整型提升</strong>(integral promotion)负责把小整数类型转换成较大的整数类型。对于<strong>bool</strong>、<strong>char</strong>、<strong>signed char</strong>、<strong>unsigned char</strong>、<strong>short</strong>、和<strong>unsigned short</strong>等类型来说，只要它们所有可能的值都能在<strong>int</strong>中，就会提升成<strong>int</strong>类型，否则提升成<strong>unsigned int</strong>类型。</p>
<p>布尔值<strong>false</strong>提升成<strong>0</strong>、<strong>true</strong>提升成<strong>1</strong>。</p>
<p>较大的char类型(<strong>wchar_t</strong>、<strong>char16_t</strong>、<strong>char32_t</strong>)提升成<strong>int</strong>、<strong>unsigned int</strong>、<strong>long</strong>、<strong>unsigned long</strong>、<strong>long long</strong>和<strong>unsigned long long</strong>中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。</p>
<h5 id="无符号类型运算对象"><a class="markdownIt-Anchor" href="#无符号类型运算对象"></a> 无符号类型运算对象</h5>
<p>如果一个运算对象是无符号类型，另一个是带符号类型：</p>
<p>① 若无符号类型不小于带符号类型，那么有符号类型转变成无符号的。</p>
<p>例如<strong>unsigned int</strong>和<strong>int</strong>运算，<strong>int</strong>转换为<strong>unsigned int</strong>。此时就可能导致运算错误。</p>
<p>② 若带符号类型大于无符号类型，此时转换结果依赖于机器。并再细分为两种情况：</p>
<p>(1) 无符号类型的所有值均能存在带符号类型中，则“无”转“带”。</p>
<p>例如<strong>long</strong>和<strong>unsigned int</strong>，<strong>long</strong>占用空间比<strong>int</strong>大，则<strong>unsigned int</strong>转<strong>long</strong>。</p>
<p>(2) 否则，“带”转“无”</p>
<p>例如<strong>long</strong>和<strong>unsigned int</strong>，<strong>int</strong>和<strong>long</strong>大小相同，则<strong>long</strong>转<strong>unsigned int</strong>。</p>
<h4 id="其他隐式转换"><a class="markdownIt-Anchor" href="#其他隐式转换"></a> 其他隐式转换</h4>
<h5 id="数组转换成指针"><a class="markdownIt-Anchor" href="#数组转换成指针"></a> 数组转换成指针</h5>
<p>在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *ip = ia;			<span class="comment">//ia自动转换成指向首元素的指针</span></span><br></pre></td></tr></table></figure>
<p>当数组被用作<code>decltype</code>关键字的参数、或者作为取地址符(&amp;)、<code>sizeof</code>及<code>typeid</code>等运算符的运算对象时，上述转换不会发生。同样，如果用一个引用来初始化数组，上述转换也不会发生。</p>
<h5 id="指针转换"><a class="markdownIt-Anchor" href="#指针转换"></a> 指针转换</h5>
<p>C++还规定了几种其他的指针转换方式：</p>
<ul>
<li>常量整数值<code>0</code>或者字面值<code>nullptr</code>能转换成任意指针类型</li>
<li>指向任意非常量的指针可以转换成<code>void*</code></li>
<li>指向任意对象的指针能转换成<code>const void*</code></li>
<li>(有继承关系的类型间还有另外一种指针转换方式)</li>
</ul>
<h5 id="转换成布尔类型"><a class="markdownIt-Anchor" href="#转换成布尔类型"></a> 转换成布尔类型</h5>
<p>如果指针或算术类型的值为<code>0</code>，转换结果为<code>false</code>；否则为<code>true</code>。</p>
<h5 id="转换成常量"><a class="markdownIt-Anchor" href="#转换成常量"></a> 转换成常量</h5>
<p>允许将指向非常量类型的指针转换成指向相应类型的常量类型的指针。也就是说，如果T是一种类型，我们就能将指向 <strong>T</strong> 的指针或引用分别转换成指向 <strong>const T</strong> 的指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;j = i;		<span class="comment">//非常量转换成const int的引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i;		<span class="comment">//非常量的地址转换成const的地址</span></span><br><span class="line"><span class="type">int</span> &amp;r = j , *q = p;	<span class="comment">//错误，不允许const转换成非常量</span></span><br></pre></td></tr></table></figure>
<p>相反的转换并不存在，因为它试图删掉底层<code>const</code>。</p>
<h5 id="类类型定义的转换"><a class="markdownIt-Anchor" href="#类类型定义的转换"></a> 类类型定义的转换</h5>
<p>类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。(如果同时提出多个转换请求，这些请求将被拒绝。)</p>
<p>已有的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s , t = <span class="string">&quot;a value&quot;</span>;	<span class="comment">//字符串字面值转换成string类型</span></span><br><span class="line"><span class="keyword">while</span>( cin &gt;&gt; s )			<span class="comment">//while的条件部分把cin转换成布尔值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>IO库定义了从istream向布尔值的转换规则。</p>
</blockquote>
<h4 id="显式转换"><a class="markdownIt-Anchor" href="#显式转换"></a> 显式转换</h4>
<p>有时我们希望显式地将对象强制转换成另外一种类型，这种方法称作<strong>强制类型转换</strong>(cast)。</p>
<blockquote>
<p><strong>Tip:</strong> 虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的，干扰了正常的类型检查，应尽量避免使用。</p>
</blockquote>
<h5 id="命名的强制类型转换"><a class="markdownIt-Anchor" href="#命名的强制类型转换"></a> 命名的强制类型转换</h5>
<p>一个命名的强制类型转换具有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name &lt;type&gt; (expression);</span><br></pre></td></tr></table></figure>
<p>其中，<strong>type</strong>是转换的目标类型而<strong>expression</strong>是要转换的值。如果<strong>type</strong>是引用类型，则结果为左值。<code>cast-name</code>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code>中的一种，指定了执行的是那种转换。</p>
<p>(<code>dynamic_cast</code>支持运行时类型识别，此处先掠过)</p>
<p><strong>static_cast</strong></p>
<p>任何具有明确定义的类型转换，只要不包含底层<strong>const</strong>，都可以使用<code>static_cast</code>。例如，通过将一个运算对象强制转换成<code>double</code>类型就能使表达式执行浮点数除法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) / i;</span><br></pre></td></tr></table></figure>
<p>当需要把一个较大的算术类型赋值给较小的类型时，<code>static_cast</code>非常有用。此时相当于告诉编译器：我们知道且不在乎潜在的精度损失。</p>
<p>一般来说，如果编译器发现了一个较大的算术类型试图赋值给一个较小的类型，就会发出警告信息；但是当我们执行了显示的类型转换后，警告信息就被关闭了。</p>
<p><code>static_cas</code>t对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用<code>static_cast</code>找回存在于<code>void*</code>的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p = &amp;d;		<span class="comment">//正确，任何非常量对象的地址都能存入void*</span></span><br><span class="line"><span class="comment">//正确，将void*转换回初始的指针类型</span></span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们必须保证转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。</p>
</blockquote>
<p><strong>const_cast</strong></p>
<p><code>const_cast</code>只能改变运算对象的底层<code>const</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);</span><br><span class="line"><span class="comment">//正确，但是通过p写值是未定义的行为</span></span><br></pre></td></tr></table></figure>
<p>对于常量对象转换为非常量对象的行为，一般称为“<strong>去掉const性质</strong>(cast away the const)”。一旦去掉某个对象的<code>const</code>性质，编译器就不再阻止我们对该对象进行写操作了。如果该对象本身不是个常量，使用强制类型转换是合法的行为；然而如果对象是个常量，在使用<code>const_cast</code>执行写操作就会产生未定义的后果。</p>
<blockquote>
<p>只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。</p>
</blockquote>
<p>同样地，<code>const_cast</code>不能用于改变表达式类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cp;</span><br><span class="line"><span class="built_in">const_cast</span>&lt;string&gt;(cp);		<span class="comment">//错误，const_cast只能改变常量属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>const_cast常用于有函数重载的上下文中</p>
</blockquote>
<p><strong>reinterpret_cast</strong></p>
<p><code>reinterpret_cast</code>通常为运算对象的<strong>位模式提供较低层次上</strong>的重新解释。</p>
<p>假设有如下转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure>
<p>必须牢记<code>pc</code>所指的是<code>int</code>而非字符，如果把<code>pc</code>当成普通的字符指针使用就可能在运行时发生错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(pc)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用reinterpret_cast非常危险。</p>
<p>reinterpret_cast本质上依赖于机器，要想安全使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。</p>
</blockquote>
<h5 id="旧式的强制类型转换"><a class="markdownIt-Anchor" href="#旧式的强制类型转换"></a> 旧式的强制类型转换</h5>
<p>在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> (expr);			<span class="comment">//函数形式的强制类型转换</span></span><br><span class="line">(type) expr;			<span class="comment">//C语言风格的强制类型转换</span></span><br></pre></td></tr></table></figure>
<p>根据所涉及的类型不同，旧式的强制类型转换分别与<code>const_cast</code>、<code>static_cast</code>和<code>reinterpret_cast</code>有相似的行为。当我们执行旧式的强制类型转换时，如果换成<code>const_cast</code>和<code>static_cast</code>也合法，则其行为与对应的命名转换一致；否则与<code>reinterpret_cast</code>类似。</p>
<h2 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h2>
<p>通常情况下，<strong>语句</strong>(statement)是顺序执行的。</p>
<p>C++语言提供了一组<strong>控制流</strong>(flow-of-control)语句以支持更复杂的执行路径。</p>
<blockquote>
<p>为了避免重复，C语言有的概念和性质不在本文中阐述。</p>
</blockquote>
<h3 id="复合语句"><a class="markdownIt-Anchor" href="#复合语句"></a> 复合语句</h3>
<p><strong>复合语句</strong>(compound statement)是指用花括号括起来的(可能为空的)语句和声明的序列，也被称作<strong>块</strong>(block)。一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套的在块中的子块里访问。</p>
<blockquote>
<p>块不以分号作为结束</p>
</blockquote>
<h3 id="switch语句"><a class="markdownIt-Anchor" href="#switch语句"></a> switch语句</h3>
<p><strong>switch</strong>语句首先对括号里的表达式求值，该表达式紧跟在关键字<strong>switch</strong>后面，可以是一个初始化的变量声明(如 <code>switch ( int i = get_num )</code> )。表达式的值转换成整数类型，然后与每个<strong>case</strong>标签比较。</p>
<p>如果表达式和某个<code>case</code>标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了<code>switch</code>的结尾或者遇到一条<code>break</code>语句为止。</p>
<p>如果<code>switch</code>语句的表达式和所有<code>case</code>都没有匹配上，将直接跳转到<code>switch</code>结构之后的第一条语句。</p>
<p><code>case</code>关键字和它对应的值一起被称为 <strong>case标签</strong> (case label)。<code>case</code>标签必须是整型常量表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="built_in">getVal</span>();</span><br><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3.14</span>:		<span class="comment">//错误，case标签不是一个整数</span></span><br><span class="line">    <span class="keyword">case</span> ival:		<span class="comment">//错误，case标签不是一个常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何两个<code>case</code>标签的值不能相同，否则就会引发错误。另外，<code>default</code>也是一种特殊的<code>case</code>标签。</p>
<p>如果没有任何一个<code>case</code>标签能匹配上<code>switch</code>表达式的值，程序将执行紧跟在<strong>default标签</strong>(default label)后面的语句。</p>
<blockquote>
<p><strong>Tip:</strong> default部分程序的最后，如果不加break语句，也会像其它case一样继续向下执行，而不是跳出当前的控制流。</p>
</blockquote>
<h3 id="for语句"><a class="markdownIt-Anchor" href="#for语句"></a> for语句</h3>
<blockquote>
<p>这一部分for语句以及不在这里呈现的while语句、dowhile语句都继承了C语言的性质，只提少部分重点。</p>
</blockquote>
<h4 id="传统for语句"><a class="markdownIt-Anchor" href="#传统for语句"></a> 传统for语句</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( init-statement ; condition ; expression )</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>关键字<strong>for</strong>以及括号里的部分称作<strong>for语句头</strong>。</p>
<blockquote>
<p><strong>Tip:</strong> 和其他的声明一样，init-statement也可以定义多个对象。但是init-statement只能有一条声明语句，因此，所有变量的基础类型必须相同。</p>
</blockquote>
<h4 id="范围for语句"><a class="markdownIt-Anchor" href="#范围for语句"></a> 范围for语句</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( declaration : expression )</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p><code>expression</code>表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者<code>vector</code>或<code>string</code>等类型的对象。这些类型的共同特点是拥有能返回迭代器的<code>begin</code>和<code>end</code>成员。</p>
<p>范围<code>for</code>语句的定义来源于与之等价的传统<code>for</code>语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> beg = v.<span class="built_in">begin</span>(), end = v.<span class="built_in">end</span>() ; beg!= end ; ++beg ) &#123;</span><br><span class="line">	<span class="keyword">auto</span> &amp;r = *beg;		<span class="comment">//r必须是引用类型，这样才能对元素执行写操作</span></span><br><span class="line">    r *= <span class="number">2</span>;				<span class="comment">//将v中每个元素的值翻倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是为什么不能通过范围for语句增加vector对象(或其他容器)的元素的原因。</p>
<p>在范围for语句中，预存了end()的值。一旦在序列中添加(删除)元素，end函数的值就可能变得无效了。</p>
</blockquote>
<h3 id="跳转语句"><a class="markdownIt-Anchor" href="#跳转语句"></a> 跳转语句</h3>
<p>跳转语句中断当前的执行过程。C++ 语言提供了4种跳转语句：<strong>break</strong>、<strong>continue</strong>、<strong>goto</strong>和<strong>return</strong>。(这里只介绍<strong>goto</strong>语句。)</p>
<h4 id="goto语句"><a class="markdownIt-Anchor" href="#goto语句"></a> goto语句</h4>
<p><strong>goto</strong>语句(goto statement)的作用是从<code>goto</code>语句无条件跳转到同一函数内的另一条语句。</p>
<blockquote>
<p>不要在程序中使用goto语句，因为它使得程序既难理解又难修改。</p>
</blockquote>
<p><code>goto</code>的语法形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure>
<p>其中，<code>label</code>是用于标识一条语句的标示符。<strong>带标签语句</strong>(labeled statement)是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end: <span class="keyword">return</span>;		<span class="comment">//带标签语句，可以作为goto的目标</span></span><br></pre></td></tr></table></figure>
<p>标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。<code>goto</code>语句和控制权转向的那条带标签的语句必须位于同一个函数内。</p>
<p>和<code>switch</code>类似，<code>goto</code>语句也不能将程序的控制权从变量的作用域外转移到作用域之内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">goto</span> end;</span><br><span class="line">	<span class="type">int</span> ix = <span class="number">10</span>;	<span class="comment">//错误，goto语句绕过了一个带初始化的变量定义</span></span><br><span class="line">end:</span><br><span class="line">	<span class="comment">//错误，此代码需要使用ix，但是goto语句绕过了它的声明</span></span><br><span class="line">	ix = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>向前跳过一个已经执行的定义是合法的。跳回到变量定义之前意味这系统将销毁该变量，然后重新创建它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向后跳过一个带初始化的变量定义是合法的</span></span><br><span class="line">begin:</span><br><span class="line">	<span class="type">int</span> sz = <span class="built_in">get_size</span>();</span><br><span class="line">	<span class="keyword">if</span> ( sz &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">		<span class="keyword">goto</span> begin;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="try语句块和异常处理"><a class="markdownIt-Anchor" href="#try语句块和异常处理"></a> try语句块和异常处理</h3>
<p><strong>异常</strong>是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括<strong>失去数据库连接</strong>以及<strong>遇到意外输入</strong>等。处理反常行为可能是设计所有系统最难的一部分。</p>
<p>如果程序中含有可能引发异常的代码，那么通常也会又专门的代码处理问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，会发出报警信息。</p>
<p><strong>异常处理机制</strong>为<strong>程序检测</strong>和<strong>异常处理</strong>这两部分的协作提供支持。在 C++ 语言中，异常处理包括：</p>
<ul>
<li><strong>throw表达式</strong>(throw expression)，异常检测部分使用<code>throw</code>表达式来表示它遇到了无法处理的问题。我们说<code>throw</code><strong>引发</strong>(raise)了异常。</li>
<li><strong>try语句块</strong>(try block)，异常处理部分使用<code>try</code>语句块处理异常。<code>try</code>语句块以关键字<code>try</code>开始，并以一个或多个<strong>catch子句</strong>(catch clause)结束。<code>try</code>语句块中代码抛出的异常通常会被某个<code>catch</code>子句处理。因为<code>catch</code>子句“<strong>处理</strong>”异常，所以它们也被称作<strong>异常处理代码</strong>(exception handler)。</li>
<li>一套<strong>异常类</strong>(exception class)，用于在<code>throw</code>表达式和相关的<code>catch</code>子句之间传递异常的具体信息。</li>
</ul>
<h4 id="throw表达式"><a class="markdownIt-Anchor" href="#throw表达式"></a> throw表达式</h4>
<p><code>throw</code>表达式包含关键字<code>throw</code>和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。<code>throw</code>语句后面通常紧跟一个分号，从而构成一条表达式语句。</p>
<p>举个例子，把两个<code>Sales_item</code>对象相加的程序。这个程序检查它读入的记录是否是关于同一种书籍的，如果不是，输出一条信息然后退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sales_item item1, item2;</span><br><span class="line">cin &gt;&gt; item1 &gt;&gt; item2;</span><br><span class="line"><span class="comment">//首先检查item1和item2是否是同一种书籍</span></span><br><span class="line"><span class="keyword">if</span> ( item1.<span class="built_in">isbn</span>() == item2.<span class="built_in">isbn</span>() ) &#123;</span><br><span class="line">    cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//表示成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Data must refer to same ISBN&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//表示失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得检查完成后不在直接输出一条信息，而是抛出一个异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先检查两条数据是否是关于同一种书籍的</span></span><br><span class="line"><span class="keyword">if</span> ( item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>() )</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line"><span class="comment">//如果程序执行到了这里，表示两个ISBN是相同的</span></span><br><span class="line">cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>如果<code>ISBN</code>不一样，就抛出一个异常。该异常是类型<strong>runtime error</strong>的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。</p>
<p>类型<code>runtime_error</code>是标准库异常类型的一种，定义在<strong>stdexpr</strong>头文件中。我们必须初始化<code>runtime_error</code>的对象，方式是给它提供一个<code>string</code>对象或者一个C风格字符串，这个字符串中有一些关于异常的辅助信息。</p>
<h4 id="try语句块"><a class="markdownIt-Anchor" href="#try语句块"></a> try语句块</h4>
<p><code>try</code>语句块的通用语法形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    program-statements</span><br><span class="line">&#125; <span class="built_in">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125; <span class="built_in">catch</span> (exception-declaration) &#123;</span><br><span class="line">	handler-statements</span><br><span class="line">&#125;	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><code>try</code>语句块的一开始是<code>try</code>关键字，随后紧跟着一个块。</p>
<p>跟在<code>try</code>块之后的是一个或多个<code>catch</code>子句。<code>catch</code>子句包括三部分：关键字<code>catch</code>、括号内一个(可能未命名的)对象的声明(称作<strong>异常声明</strong>，exception declaration)以及一个块。当选中了某个<code>catch</code>子句之后，执行与之对应的块。<code>catch</code>一旦完成，程序跳转到<code>try</code>语句块最后一个<code>catch</code>子句之后的那条语句继续执行。</p>
<p><code>try</code>语句块中的<code>program-statements</code>组成程序的正常逻辑，像其他任何块一样，<code>program-statements</code>可以有包括声明在内的任意C++语句。一如往常，<code>try</code>语句块内声明的变量在块外部无法访问，特别是在<code>catch</code>子句内也无法访问。</p>
<h5 id="编写处理代码"><a class="markdownIt-Anchor" href="#编写处理代码"></a> 编写处理代码</h5>
<p>在之前的例子里，我们使用了一个<code>throw</code>表达式以避免把两个代表不同书籍的<code>Sales_item</code>相加。我们假设执行<code>Sales_item</code>对象加法的代码是与用户交互的代码分离开来的。其中与用户交互的代码负责处理的异常，它的形式可能如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( cin &gt;&gt; item1 &gt;&gt; item2 ) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行添加两个Sales_item对象的代码</span></span><br><span class="line">        <span class="comment">//如果添加失败，代码抛出一个runtime_error异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> ( runtime_error err ) &#123;</span><br><span class="line">        <span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">        cout &lt;&lt; err.<span class="built_in">what</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nTry Again? Enter y or n&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> ( !cin || c == <span class="string">&#x27;n&#x27;</span> )</span><br><span class="line">            <span class="keyword">break</span>;	<span class="comment">//跳出while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序本来要执行的任务出现在<code>try</code>语句块中，这是因为这段代码可能会抛出一个<code>runtime_error</code>类型的异常。</p>
<p><code>try</code>语句块对应一个<code>catch</code>子句，该子句负责处理类型为<code>runtime_error</code>的异常。如果try语句块的代码抛出了<code>runtime_error</code>异常，接下来执行<code>catch</code>块内的语句。在我们书写的<code>catch</code>子句中，输出一段提示信息要求用户指定程序是否继续。如果用户输入’<strong>n</strong>’，执行<code>break</code>语句并退出<code>while</code>循环；否则，直接执行<code>while</code>循环的右侧花括号，意味着程序控制权跳回到<code>while</code>条件部分准备下一次迭代。</p>
<p>给用户的提示信息中输出了<code>err.what()</code>的返回值。我们知道<code>err</code>的类型是<code>runtime_error</code>，因此能推断<code>what</code>是<code>runtime_error</code>的一个成员函数。每个标准库异常类都定义了名为<code>what</code>的成员函数，这些函数没有参数，返回值是C风格字符串(即<code>const char*</code>)。其中，<code>runtime_error</code>的<code>what</code>成员返回的是初始化一个具体对象时所用的<code>string</code>对象的副本。</p>
<h5 id="函数在寻找处理代码的过程中退出"><a class="markdownIt-Anchor" href="#函数在寻找处理代码的过程中退出"></a> 函数在寻找处理代码的过程中退出</h5>
<p>在复杂系统中，程序遇到抛出异常的代码前，其执行路径可能已经经过了多个<code>try</code>语句块。例如，一个<code>try</code>语句块可能调用了包含另一个<code>try</code>语句块的函数，新的<code>try</code>语句块可能调用了包含又一个<code>try</code>语句块的新函数，以此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的<code>catch</code>子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的<code>catch</code>子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的<code>catch</code>子句为止。</p>
<p>如果最终还是没有找到任何匹配的<code>catch</code>子句，程序转到名为<strong>terminate</strong>的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p>
<p>对于那些没有任何<code>try</code>语句块定义的异常，也按照类似的方式处理：毕竟，没有<code>try</code>语句块也就意味着没有匹配的<code>catch</code>子句。如果一段程序没有<code>try</code>语句块且发生了异常，系统会调用<code>terminate</code>函数并终止当前程序的执行。</p>
<blockquote>
<p><strong>Note:</strong> <strong>Luv</strong>本地实测含有异常的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std :: runtime_error;			<span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//代码抛出一个runtime_error异常</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;first exception&quot;</span>);</span><br><span class="line"> &#125; <span class="built_in">catch</span> ( runtime_error err ) &#123;</span><br><span class="line">     <span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">     cout &lt;&lt; err.<span class="built_in">what</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot;\nTry Again? Enter y or n&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">char</span> c;</span><br><span class="line">     cin &gt;&gt; c;</span><br><span class="line">     <span class="keyword">if</span> ( !cin || c == <span class="string">&#x27;n&#x27;</span> )</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Break out!&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接抛出一个异常，此时没有catch子句与之匹配</span></span><br><span class="line">	<span class="comment">//程序转到名为terminate的标准库函数 </span></span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;second exception&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">first exception</span><br><span class="line">Try Again? Enter y or n</span><br><span class="line">n</span><br><span class="line">Break out!</span><br><span class="line">terminate called after throwing an instance of &#x27;std::runtime_error&#x27;</span><br><span class="line">what():  second exception</span><br></pre></td></tr></table></figure>
<p>并且，此时主函数return的值为3。</p>
</blockquote>
<h4 id="标准异常"><a class="markdownIt-Anchor" href="#标准异常"></a> 标准异常</h4>
<p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：</p>
<ul>
<li><code>exception</code>头文件定义了最通用的异常类<code>exception</code>。它只报告异常的发生，不提供任何额外信息。</li>
<li><code>stdexcept</code>头文件定义了几种常用的异常类，在下标列出。</li>
<li><code>new</code>头文件定义了<code>bad_alloc</code>异常类型，这种类型在后续有关动态内存章节介绍。</li>
<li><code>type_info</code>头文件定义了<code>bad_cast</code>异常类型，这种类型在最后一章介绍。</li>
</ul>
<table>
<thead>
<tr>
<th><stdexcept>定义的异常类</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>runtime_error</td>
<td>只有在运行时才能检测出的问题</td>
</tr>
<tr>
<td>range_error</td>
<td>运行时错误：生成的结果超出了有意义的值域范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时错误：计算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误：计算下溢</td>
</tr>
<tr>
<td>logic_error</td>
<td>程序逻辑错误</td>
</tr>
<tr>
<td>domain_error</td>
<td>逻辑错误：参数对应的结果值不存在</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>逻辑错误：无效参数</td>
</tr>
<tr>
<td>length_error</td>
<td>逻辑错误：试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td>out_of_range</td>
<td>逻辑错误：使用一个超出有效范围的值</td>
</tr>
</tbody>
</table>
<p>标准异常类只定义了几种运算，包括创建或拷贝异常类型的对象，以及为异常类型的对象赋值。</p>
<p>我们只能以<strong>默认初始化</strong>的方式初始化<code>exception</code>、<code>bad_alloc</code>和<code>bad_cast</code>对象，不允许为这些对象提供初始值。</p>
<p>其他异常类型的行为则恰好相反：应该使用<code>string</code>对象或者C风格字符串初始化这些类型的对象，且不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。</p>
<p>异常类型只定义了一个名为<code>what</code>的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的<code>const char*</code>。该字符串的目的是提供关于异常的一些文本信息。</p>
<blockquote>
<p><strong>Note:</strong> <strong>Luv</strong>进入<stdexcept>头文件查看，发现what成员函数的定义只在runtime_error和logic_error中出现，推测其他异常类应该分别是这两种异常类的继承子类，经测试，它们同样可以调用what成员函数。</p>
</blockquote>
<p><code>what</code>函数返回的C风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则<code>what</code>返回该字符串。对于其他无初始值的异常类型来说，<code>what</code>返回的内容由编译器决定。</p>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<p><strong>函数</strong>(function)是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且(通常)会产生一个结果。可以重载函数，也就是说，同一个名字可以对应几个不同的函数。</p>
<blockquote>
<p>与前面章节类似，我们对于已经在C语言中熟悉的内容将不在本文中展示。</p>
</blockquote>
<h3 id="函数基础"><a class="markdownIt-Anchor" href="#函数基础"></a> 函数基础</h3>
<h4 id="形参列表"><a class="markdownIt-Anchor" href="#形参列表"></a> 形参列表</h4>
<p>函数的<strong>形参</strong>(parameter)列表可以为空，但是不能省略。为了与C语言兼容，也可以用关键字<strong>void</strong>表示函数没有形参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span> <span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;			<span class="comment">//隐式地定义空形参列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;		<span class="comment">//显式地定义空形参列表</span></span><br></pre></td></tr></table></figure>
<p>形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f3</span> <span class="params">( <span class="type">int</span> v1 , v2 )</span> </span>&#123; <span class="comment">/* ... */</span> &#125;	<span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f3</span> <span class="params">( <span class="type">int</span> v1 , <span class="type">int</span> v2 )</span> </span>&#123; <span class="comment">/* ... */</span> &#125;	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>任意两个形参不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。</p>
<blockquote>
<p>形参名是可选的(可以不写)。但是由于我们无法使用未命名的形参，所以形参一般都应该有个名字。是否设置未命名的形参并不影响调用时提供的实参数量，即使某个形参不被函数使用，也必须为它提供一个形参。</p>
</blockquote>
<h4 id="函数返回类型"><a class="markdownIt-Anchor" href="#函数返回类型"></a> 函数返回类型</h4>
<p>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。</p>
<h4 id="局部对象"><a class="markdownIt-Anchor" href="#局部对象"></a> 局部对象</h4>
<p>在C++语言中，名字有作用域，对象有<strong>生命周期</strong>(lifetime)。</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见。</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
</ul>
<p>局部对象的生命周期依赖于定义的方式。</p>
<h5 id="自动对象"><a class="markdownIt-Anchor" href="#自动对象"></a> 自动对象</h5>
<p>我们把只存在于块执行期间的对象称为<strong>自动对象</strong>(automatic object)。当块的执行结束后，块中创建的自动对象被销毁，值也变成未定义的。</p>
<p>形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。</p>
<h5 id="局部静态对象"><a class="markdownIt-Anchor" href="#局部静态对象"></a> 局部静态对象</h5>
<p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成<code>static</code>类型从而获得这样的对象。<strong>局部静态对象</strong>(local static object)在程序的执行路径第一次经过定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p>
<h4 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h4>
<p>和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。</p>
<blockquote>
<p>如果一个函数永远也不会被我们用到，那么它可以只用声明没有定义</p>
</blockquote>
<p>因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们选择beg和end作为形参的名字以表示这两个迭代器划定了输出值的范围</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">( vector&lt;<span class="type">int</span>&gt;::const_iterator beg ,</span></span></span><br><span class="line"><span class="params"><span class="function">             vector&lt;<span class="type">int</span>&gt;::const_iterator end )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数的三要素(返回类型、函数名、形参类型)描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作<strong>函数原型</strong>(function prototype)。</p>
<blockquote>
<p><strong>在头文件中进行函数声明</strong></p>
<p>与变量类似，函数也应该在头文件中声明而在源文件中定义，方便确保同一函数的所用声明保持一致。</p>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p>
</blockquote>
<h4 id="分离式编译"><a class="markdownIt-Anchor" href="#分离式编译"></a> 分离式编译</h4>
<p>为了允许编写程序时按照逻辑关系将其划分开来，C++语言支持所谓的<strong>分离式编译</strong>(separate compilation)。分离式编译允许我们把程序分隔到几个文件中去，每个文件独立编译。</p>
<h5 id="编译和链接多个源文件"><a class="markdownIt-Anchor" href="#编译和链接多个源文件"></a> 编译和链接多个源文件</h5>
<p>举个例子，假设<code>fact</code>函数的定义位于一个名为<code>fact.cc</code>的文件中，它的声明位于名为<code>Chapter6.h</code>的头文件中。显然与其他所用用到<code>fact</code>函数的文件一样，<code>fact.cc</code>应该包含<code>Chapter6.h</code>头文件。另外，我们在名为<code>factMain.cc</code>的文件中创建<code>main</code>函数，<code>main</code>函数将调用<code>fact</code>函数。要生成<strong>可执行文件</strong>(executable file)，必须告诉编译器我们用到的代码在哪里。</p>
<p>对于上述几个文件来说，编译的过程如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ CC factMain.cc fact.cc <span class="comment"># generates factMain.exe or a.out</span></span><br><span class="line">$ CC factMain.cc fact.cc -o main <span class="comment"># generates main or main.exe</span></span><br></pre></td></tr></table></figure>
<p>其中，<strong>CC</strong>是编译器的名字，<strong>$</strong> 是系统提示符， <strong>#</strong> 后面是命令行下的注释语句。接下来运行可执行文件，就会执行我们定义的<code>main</code>函数。</p>
<p>如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件。大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是 .obj(Windows) 或 .o(UNIX) 的文件，后缀名的含义是该文件包含对象代码(object code)。</p>
<p>接下来编译器负责把对象文件联结在一起形成可执行文件。在我们的系统中，编译的过程如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ CC -c factMain.cc <span class="comment"># generates factMain.o</span></span><br><span class="line">$ CC -c fact.cc <span class="comment"># generates fact.o</span></span><br><span class="line">$ CC factMain.o fact.o <span class="comment"># generates factMain.exe or a.out</span></span><br><span class="line">$ CC factMain.o fact.o <span class="comment"># generates main or main.exe</span></span><br></pre></td></tr></table></figure>
<h3 id="参数传递"><a class="markdownIt-Anchor" href="#参数传递"></a> 参数传递</h3>
<p>当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>(passed by reference)或者函数被<strong>传引用调用</strong>(called by reference)。</p>
<p>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>(passed by value)或者函数被<strong>传值调用</strong>(called by value)。</p>
<blockquote>
<p>熟悉C的程序员常常使用<strong>指针</strong>类型的形参访问函数外部的对象。在C++语言中，建议使用<strong>引用</strong>类型的形参替代指针。</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> 可以使用引用形参返回多个结果。</p>
</blockquote>
<h4 id="使用引用避免拷贝"><a class="markdownIt-Anchor" href="#使用引用避免拷贝"></a> 使用引用避免拷贝</h4>
<p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型(包括<strong>IO</strong>类型在内)根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p>
<blockquote>
<p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p>
</blockquote>
<h4 id="const形参和实参"><a class="markdownIt-Anchor" href="#const形参和实参"></a> const形参和实参</h4>
<p>当形参是<code>const</code>时，像其他初始化过程一样，我们会忽略掉被初始化的对象(即形参)的顶层<code>const</code>。当形参有顶层<code>const</code>时，传给它常量对象或者非常量对象都是可以的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123;	<span class="comment">/* fcn能够读取i，但是不能向i写值 */</span>		&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>fcn</code>函数时，既可以传入<code>const int</code>也可以传入<code>int</code>。</p>
<p>注意，忽略掉形参的顶层<code>const</code>可能产生意想不到的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123;	<span class="comment">/* fcn能够读取i，但是不能向i写值 */</span>		&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span> <span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;	<span class="comment">//错误，重复定义了fcn(int)</span></span><br></pre></td></tr></table></figure>
<p>在C++语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别。因为顶层<code>const</code>被忽略掉了，所以在上面的代码中传入两个<code>fcn</code>函数的参数可以完全一样，因此第二个<code>fcn</code>是错误的。</p>
<h5 id="指针或引用形参与const"><a class="markdownIt-Anchor" href="#指针或引用形参与const"></a> 指针或引用形参与const</h5>
<p>形参的初始化方式和变量的初始化方式是一样的，我们可以用一个非常量初始化一个底层<code>const</code>对象，但是反过来不行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;				</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp = &amp;i;		<span class="comment">//正确，但是cp不能改变i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;		<span class="comment">//正确，但是r不能改变i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;		<span class="comment">//正确，字面值初始化常量引用</span></span><br><span class="line"><span class="type">int</span> *p = cp;			<span class="comment">//错误，p和cp的类型不匹配</span></span><br><span class="line"><span class="type">int</span> &amp;r3 = r;			<span class="comment">//错误，r3和r的类型不匹配</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = <span class="number">42</span>;			<span class="comment">//错误，不能用字面值初始化一个非常量引用</span></span><br></pre></td></tr></table></figure>
<p>将同样的初始化规则应用到参数传递上可得如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span> <span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    *ip = <span class="number">0</span>;		<span class="comment">//改变指针ip所指对象的值</span></span><br><span class="line">    ip = <span class="number">0</span>;			<span class="comment">//只改变了ip的局部拷贝，实参未被改变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span> <span class="params">(<span class="type">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;			<span class="comment">//改变了i所引对象的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string::size_type <span class="title">find_char</span><span class="params">(<span class="type">const</span> string &amp;s , <span class="type">char</span> c , </span></span></span><br><span class="line"><span class="params"><span class="function">                            string::size_type &amp;occurs)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;</span><br><span class="line">string::size_type ctr = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">reset</span>(&amp;i);				<span class="comment">//调用形参类型是int*的reset函数</span></span><br><span class="line"><span class="built_in">reset</span>(&amp;ci);				<span class="comment">//错误，不能用指向const int对象的指针初始化int*</span></span><br><span class="line"><span class="built_in">reset</span>(i);				<span class="comment">//调用形参类型是int&amp;的reset函数</span></span><br><span class="line"><span class="built_in">reset</span>(ci);				<span class="comment">//错误，不能用普通引用</span></span><br><span class="line"><span class="built_in">reset</span>(<span class="number">42</span>);				<span class="comment">//错误，不能把普通引用绑定到字面值上</span></span><br><span class="line"><span class="built_in">reset</span>(ctr);				<span class="comment">//错误，类型不匹配，ctr是无符号类型</span></span><br><span class="line"><span class="comment">//正确，find_char的第一个形参是对常量的引用</span></span><br><span class="line"><span class="built_in">find_char</span>(<span class="string">&quot;Hello World!&quot;</span> , <span class="string">&#x27;o&#x27;</span> , ctr);</span><br></pre></td></tr></table></figure>
<p>要想调用引用版本的<code>reset</code>，只能使用<code>int</code>类型的对象，而不能使用字面值、求值结果尾<code>int</code>的表达式、需要转换的对象或者<code>const int</code>类型的对象。类似的，要想调用指针版本的<code>reset</code>只能使用<code>int*</code>。</p>
<p>另一方面，我们能传递一个字符串字面值作为<code>find_char</code>的第一个实参，这是因为该函数的引用形参是常量引用，而C++允许我们用字面值初始化常量引用。</p>
<h5 id="尽量使用常量引用"><a class="markdownIt-Anchor" href="#尽量使用常量引用"></a> 尽量使用常量引用</h5>
<p>把函数不会改变的形参定义成(普通的)引用是一种比较常见的<strong>错误</strong>，这么做带给函数的调用者一种<strong>误导</strong>，即函数可以修改它的实参的值。此外使用引用而非常量引用也会极大地<strong>限制</strong>函数所能接受的实参类型。</p>
<blockquote>
<p><strong>Tip:</strong> 这个函数编写习惯很重要。</p>
</blockquote>
<h4 id="数组形参"><a class="markdownIt-Anchor" href="#数组形参"></a> 数组形参</h4>
<p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽管形式不同，但这三个print函数是等价的</span></span><br><span class="line"><span class="comment">//每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;	<span class="comment">//可以看出来，函数的意图是作用于一个数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;	<span class="comment">//这里的维度表示我们期望数组含有多少个元素，实际不一定</span></span><br></pre></td></tr></table></figure>
<p>尽管表达形式不同，但上面的三个函数是等价的：每个函数的唯一形参都是<code>const int*</code> 类型的。当编译器处理对<code>print</code>函数的调用时，只检查传入的参数是否是<code>const int*</code> 类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span> , j[<span class="number">2</span>] = &#123; <span class="number">0</span> , <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);			<span class="comment">//正确，&amp;i的类型是int*</span></span><br><span class="line"><span class="built_in">print</span>(j);			<span class="comment">//正确，j转换成int*并指向j[0]</span></span><br></pre></td></tr></table></figure>
<p>如果我们传给<code>print</code>函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数调用没有影响。</p>
<p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术：</p>
<p><strong>使用标记指定数组长度</strong></p>
<p>要求数组本身包含了一个结束标记，典型示例是C风格字符串。函数在处理C风格字符串时遇到空字符停止：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cp)					<span class="comment">//若cp不是一个空指针</span></span><br><span class="line">        <span class="built_in">whlie</span>(*cp)			<span class="comment">//只要指针所指的字符不是空字符</span></span><br><span class="line">        	cout &lt;&lt; *cp++;	<span class="comment">//输出当前字符并将指针向前移动一个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用标准库规范</strong></p>
<p>传递指向数组首元素和尾后元素的指针，这种方法收到了标准库技术的启发：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( <span class="type">const</span> <span class="type">int</span> *beg , <span class="type">const</span> <span class="type">int</span> *end )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输出beg和end之间(不含end)的所有元素</span></span><br><span class="line">    <span class="keyword">while</span> ( beg != end )</span><br><span class="line">        cout &lt;&lt; *beg++ &lt;&lt; endl;	<span class="comment">//输出当前元素并将指针向前移动一个位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j[<span class="number">2</span>] = &#123; <span class="number">0</span> , <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">//j转换成指向它首元素的指针</span></span><br><span class="line"><span class="comment">//第二个实参是指向j的尾后元素的指针</span></span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">begin</span>(j) , <span class="built_in">end</span>(j) );		<span class="comment">//标准库begin和end函数</span></span><br></pre></td></tr></table></figure>
<p><strong>显示传递一个表示数组大小的形参</strong></p>
<p>专门定义了一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const int ia[]等价于const int *ia</span></span><br><span class="line"><span class="comment">//size表示数组的大小，将它显式地传给函数用于控制对ia元素的访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( <span class="type">const</span> <span class="type">int</span> ia[] , <span class="type">size_t</span> size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">size_t</span> i = <span class="number">0</span> ; i != size ; ++i ) &#123;</span><br><span class="line">        cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j[] = &#123; <span class="number">0</span> , <span class="number">1</span> &#125;;	<span class="comment">//大小为2的整型数组</span></span><br><span class="line"><span class="built_in">print</span>( j , <span class="built_in">end</span>(j) - <span class="built_in">begin</span>(j) );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上三个print函数都把数组形参定义成了指向const的指针。当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。</p>
</blockquote>
<h5 id="数组引用形参"><a class="markdownIt-Anchor" href="#数组引用形参"></a> 数组引用形参</h5>
<p>C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，形参是数组的引用，维度是类型的一部分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( <span class="type">int</span> (&amp;arr) [<span class="number">10</span>] )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> elem : arr )</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>&amp;arr 两端的括号必不可少。</p>
</blockquote>
<p>因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，这一用法也无形中限制了<code>print</code>函数的可用性，我们只能将函数作用于大小为<strong>10</strong>的数组。</p>
<h5 id="传递多维数组"><a class="markdownIt-Anchor" href="#传递多维数组"></a> 传递多维数组</h5>
<p>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维(以及后面所有维度)的大小都是数组类型的一部分，不能省略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">10</span>], <span class="type">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">10</span>], <span class="type">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>第二种声明看起来是一个数组，实际上形参是指向含有<strong>10</strong>个整数的数组的指针。</p>
<h4 id="main-处理命令行选项"><a class="markdownIt-Anchor" href="#main-处理命令行选项"></a> main: 处理命令行选项</h4>
<p>有时我们需要给<code>main</code>传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的的操作。例如，假定<code>main</code>函数位于可执行文件<code>prog</code>之内，我们可以向程序传递下面的选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure>
<p>这些命令行选项通过两个(可选的)形参传递给<code>main</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( <span class="type">int</span> argc , <span class="type">char</span> *argc[] )</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>第二个形参<code>argv</code>是一个数组，它的元素是指向C风格字符串的指针；第一个形参<code>argc</code>表示数组中字符串的数量。因为第二个形参是数组，所以<code>main</code>函数也可以定义成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( <span class="type">int</span> argc , <span class="type">char</span> **argv )</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>argv</code>指向<code>char*</code>。</p>
<p>当实参传给<code>main</code>函数之后，<code>argv</code>的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。</p>
<p>以上面提供的命令行为例，<code>argc</code>应该等于5，<code>argv</code>应该包含如下的C风格字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;prog&quot;</span>;		<span class="comment">//或者argv[0]也可以指向一个空字符串</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-d&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;-o&quot;</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">&quot;ofile&quot;</span>;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">&quot;data0&quot;</span>;</span><br><span class="line">argv[<span class="number">5</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip:</strong> 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。</p>
</blockquote>
<h4 id="含有可变形参的函数"><a class="markdownIt-Anchor" href="#含有可变形参的函数"></a> 含有可变形参的函数</h4>
<p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：</p>
<ul>
<li>如果所有的实参类型相同，可以传递一个名为<code>initializer_list</code>的标准库类型；</li>
<li>如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，其细节我们在后面章节讲解。</li>
</ul>
<h5 id="initializer_list形参"><a class="markdownIt-Anchor" href="#initializer_list形参"></a> initializer_list形参</h5>
<p>如果函数的实参数量未知但是全部实参的类型相同，我们可以使用<code>initializer_list</code>类型的形参。<code>initializer_list</code>是一种标准库类型，用于表示某种特定类型的值的数组。其定义在同名的头文件中，提供的操作如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>提供的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>initializer_list<T> lst;</td>
<td>默认初始化；T类型元素的空列表</td>
</tr>
<tr>
<td>initializer_list<T> lst{a,b,c…};</td>
<td>lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const</td>
</tr>
<tr>
<td>lst2 (lst)  ,  lst2 = lst</td>
<td>拷贝或赋值一个initializer_list对象；拷贝后，原是列表和副本共享元素</td>
</tr>
<tr>
<td>lst.size()</td>
<td>列表中的元素数量</td>
</tr>
<tr>
<td>lst.begin()</td>
<td>返回指向lst中首元素的指针</td>
</tr>
<tr>
<td>lst.end()</td>
<td>返回1指向lst中尾元素下一位置的指针</td>
</tr>
</tbody>
</table>
<p>和<code>vector</code>一样，<code>initializer_list</code>也是一种模板类型。定义<code>initializer_list</code>对象时，必须说明列表中所含元素的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initializer_list &lt;string&gt; ls;	<span class="comment">//元素类型是string</span></span><br><span class="line">initializer_list &lt;<span class="type">int</span>&gt; li;		<span class="comment">//元素类型是int</span></span><br></pre></td></tr></table></figure>
<p>和<code>vector</code>不一样的是，<code>initializer_list</code>对象中的元素永远是常量值，我们无法改变<code>initializer_list</code>对象中元素的值。</p>
<p>我们使用如下形式编写错误信息的函数，使其可以作用域可变数量的实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span> <span class="params">( initializer_list&lt;string&gt; il )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>() ; beg != il.<span class="built_in">end</span>() ; ++beg )</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想向<code>initializer_list</code>形参中传递一个值的序列，则必须把序列放在一对花括号内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//expected和actual是string对象</span></span><br><span class="line"><span class="keyword">if</span> ( expected != actual )</span><br><span class="line">    <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>, expected, actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>含有<code>initializer_list</code>形参的函数也可以同时拥有其他形参。例如，调试系统可能有个名为<code>ErrCode</code>的类用来表示不同类型的错误，因此我们可以改写之前的程序，使其包含一个<code>initializer_list</code>形参和一个<code>ErrCode</code>形参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span> <span class="params">(ErrCode e, initializer_list&lt;string&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; e.<span class="built_in">msg</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;elem : il)</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>initializer_list</code>包含<code>begin</code>和<code>end</code>成员，所以我们可以使用范围<code>for</code>循环处理其中的元素。为了调用该版本的<code>error_msg</code>函数，需要额外传递一个<code>ErrCode</code>实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( expected != actual )</span><br><span class="line">    <span class="built_in">error_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">42</span>), &#123;<span class="string">&quot;functionX&quot;</span>, expected, actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">0</span>), &#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="省略符形参"><a class="markdownIt-Anchor" href="#省略符形参"></a> 省略符形参</h4>
<p>C++ 还有一种特殊的形参类型(即省略符)，可以用它传递可变数量的实参。这种功能是为了便于 C++ 程序访问某些特殊的C代码而设置的，这些代码使用了名为<code>varargs</code>的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用<code>varargs</code>。</p>
<blockquote>
<p>省略符形参应该仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
</blockquote>
<p>省略符形参只能出现在形参列表的最后一个位置，它的形式无非以下两种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一种形式制定了<code>foo</code>函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参对应的实参无须类型检查。在第一种形式中，形参声明后面的逗号是可选的。</p>
<h3 id="返回类型和return语句"><a class="markdownIt-Anchor" href="#返回类型和return语句"></a> 返回类型和return语句</h3>
<h4 id="值是如何被返回的"><a class="markdownIt-Anchor" href="#值是如何被返回的"></a> 值是如何被返回的</h4>
<p>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数的调用结果。</p>
<p>同其他引用类型一样，如果函数返回引用，则该引用仅是它所引对象的一个别名。举个例子，假定某函数挑出两个<code>string</code>形参中较短的那个并返回其引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挑出两个string对象中较短的那个，返回其引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1 , <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中形参和返回类型都是<code>const string的</code>引用，不管是调用函数还是返回结果都不会真正拷贝<code>string</code>对象。</p>
<blockquote>
<p><strong>不要返回局部对象的引用或指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//严重错误：这个函数试图返回局部对象引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> string ret;</span><br><span class="line"> <span class="comment">//以某种方式改变一下ret</span></span><br><span class="line"> <span class="keyword">if</span>( !ret.<span class="built_in">empty</span>() )</span><br><span class="line">     <span class="keyword">return</span> ret;		<span class="comment">//错误，返回局部对象的引用</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>;	<span class="comment">//错误，&quot;Empty&quot;是一个局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>return的两个对象都是局部的，最后都会指向不可再用的空间。</p>
</blockquote>
<h4 id="返回类类型的函数和调用运算符"><a class="markdownIt-Anchor" href="#返回类类型的函数和调用运算符"></a> 返回类类型的函数和调用运算符</h4>
<p>如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员。例如，我们可以通过如下形式得到较短的<code>string</code>对象的长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用string对象的size成员，该string对象是由shorterString函数返回的</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="built_in">shorterString</span>(s1,s2).<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<h4 id="引用返回左值"><a class="markdownIt-Anchor" href="#引用返回左值"></a> 引用返回左值</h4>
<p>函数的返回类型决定函数调用是否是左值。调用一个返回<strong>引用</strong>的函数得到左值，其他返回类型得到右值。</p>
<p>可以像使用其他左值那样来使用返回引用的函数的调用，特别地，我们能为返回类型是<strong>非常量引用</strong>的函数的结果赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span> <span class="params">(string &amp;str , string::size_type ix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];			<span class="comment">//get_val假定索引值是有效的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span> <span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;			<span class="comment">//输出a value</span></span><br><span class="line">    <span class="built_in">get_val</span>( s , <span class="number">0</span> ) = <span class="string">&#x27;A&#x27;</span>;		<span class="comment">//将s[0]的值改为A</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;			<span class="comment">//输出A value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="列表初始化返回值"><a class="markdownIt-Anchor" href="#列表初始化返回值"></a> 列表初始化返回值</h4>
<p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p>
<p>例如，在下面的函数中，我们返回一个<code>vector</code>对象，用它存放表示错误信息的<code>string</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// expected 和 actual 是 string 对象</span></span><br><span class="line">    <span class="keyword">if</span> (expected.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;						<span class="comment">//返回一个空vector对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (expected == actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okey&quot;</span>&#125;;	<span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一条<code>return</code>语句返回一个空列表，此时，<code>process</code>函数返回的<code>vector</code>对象是空的。如果<code>expected</code>不为空，根据<code>expected</code>和<code>actual</code>是否相等，函数返回的<code>vector</code>对象分别用两个或三个元素初始化。</p>
<p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。</p>
<h4 id="主函数main的返回值"><a class="markdownIt-Anchor" href="#主函数main的返回值"></a> 主函数main的返回值</h4>
<p><code>main</code>函数的返回值可以看做是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。</p>
<p>为了使返回值与机器无关，<code>cstdlib</code>头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功和失败：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;	<span class="comment">//定义在cstdlib头文件中</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;	<span class="comment">//定义在cstdlib头文件中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为它们是预处理变量，所以既不能在前面加上<code>std::</code>，也不能在<code>using</code>声明中出现。</p>
<h3 id="返回数组指针"><a class="markdownIt-Anchor" href="#返回数组指针"></a> 返回数组指针</h3>
<p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>];		<span class="comment">//arrT是一个类型别名，它表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="type">int</span>[<span class="number">10</span>];		<span class="comment">//arrT的等价声明</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;			<span class="comment">//func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<p>其中<code>arrT</code>是含有<strong>10</strong>个整数的数组的别名。因为我们无法返回数组，所以将返回类型定义成数组的指针。因此，<code>func</code>函数接受一个<code>int</code>实参，返回一个指向包含<strong>10</strong>个整数的数组的指针。</p>
<h4 id="声明一个返回数组指针的函数"><a class="markdownIt-Anchor" href="#声明一个返回数组指针的函数"></a> 声明一个返回数组指针的函数</h4>
<p>要想在声明<code>func</code>时不使用类型别名，我们必须记住，数组的<strong>维度</strong>应跟随在要定义的数组名之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];			<span class="comment">//arr是一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];			<span class="comment">//p1是一个含有10个指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">10</span>] = &amp;arr;	<span class="comment">//p2是一个指针，它指向含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<p>和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且<strong>形参列表应该先于数组的维度</strong>。因此，返回数组指针的函数形式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Type</span> (*<span class="built_in">function</span>(parameter_list)) [dimension]</span><br></pre></td></tr></table></figure>
<p>类似于数组的声明，<code>Type</code>表示元素的类型，<code>dimension</code>表示数组的大小。<code>(*function(parameter_list))</code>两端的括号必须存在，就像我们定义<code>p2</code>时两端必须有括号一样。如果没有这对括号，函数的返回类型将是指针的数组。</p>
<p>举个更具体的例子，线面这个<code>func</code>函数的声明没有类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i)) [<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>可以按照以下的顺序来逐层理解该声明的含义：</p>
<ol>
<li><code>func(int i)</code> 表示调用<code>func</code>函数时需要一个<code>int</code>类型的实参。</li>
<li><code>(*func(int i))</code> 意味着我们可以对函数调用的结果执行解引用操作。</li>
<li><code>(*func(int i))[10]</code> 表示解引用<code>func</code>的调用将得到一个大小是<strong>10</strong>的数组。</li>
<li><code>int (*func(int i))[10]</code> 表示数组中的元素是<code>int</code>类型。</li>
</ol>
<h4 id="使用尾置返回类型"><a class="markdownIt-Anchor" href="#使用尾置返回类型"></a> 使用尾置返回类型</h4>
<p>在C++11新标准中还有一种可以简化上述<code>func</code>声明的方法，就是使用<strong>尾置返回类型</strong>(trailing return type)。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个 <strong>-&gt;</strong> 符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<code>auto</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>
<p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到<code>func</code>函数返回的是一个指针，并且该指针指向了含有<strong>10</strong>个整数的数组。</p>
<h4 id="使用decltype"><a class="markdownIt-Anchor" href="#使用decltype"></a> 使用decltype</h4>
<p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用<code>decltype</code>关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数 <code>i</code> 的不同指向两个已知数组中的某一个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">//返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ( i % <span class="number">2</span> ) ? &amp;odd : &amp;even;	<span class="comment">//返回一个指向数组的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>arrPtr</code>使用关键字<code>decltype</code>表示它的返回类型是个指针，并且该指针所指的对象与<code>odd</code>的类型一致。因为<code>odd</code>是数组，所以<code>arrPtr</code>返回一个指向含有<strong>5</strong>个整数的数组的指针。有一个需要注意的地方：<code>decltype</code>并不负责把数组类型转换成对应的指针，所以<code>decltype</code>的结果是个数组，要想表示<code>arrPtr</code>返回指针还必须在函数声明时加一个 * 符号。</p>
<blockquote>
<p><strong>Note:</strong> <strong>Luv</strong>个人觉得此处的decltype作用相当于前面的typedef取别名的方法。</p>
</blockquote>
<h3 id="函数重载"><a class="markdownIt-Anchor" href="#函数重载"></a> 函数重载</h3>
<p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载</strong>(overloaded)函数。</p>
<p>函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。</p>
<blockquote>
<p>main函数不能重载。</p>
</blockquote>
<h4 id="定义重载函数"><a class="markdownIt-Anchor" href="#定义重载函数"></a> 定义重载函数</h4>
<p>对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。</p>
<p>不允许两个函数除了返回类型外其他所有的要素都相同。假设有两个函数，它们的形参列表一样但是返回值类型不同，则第二个函数的声明是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;</span><br><span class="line"><span class="function">cool <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;	<span class="comment">//错误，与上一个函数相比只有返回类型不同</span></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Phone Telno;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Telno&amp;)</span></span>;	<span class="comment">//Telno和Phone类型相同</span></span><br></pre></td></tr></table></figure>
<p>类型别名不是创建新类型，两个声明是一样的。</p>
</blockquote>
<h4 id="重载和const形参"><a class="markdownIt-Anchor" href="#重载和const形参"></a> 重载和const形参</h4>
<p>顶层<code>const</code>不影响传入函数的对象。一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone)</span></span>;		<span class="comment">//重复声明了Record lookup(Phone)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="type">const</span>)</span></span>;	<span class="comment">//重复声明了Record lookup(Phone*)</span></span><br></pre></td></tr></table></figure>
<p>两组声明分别是等价的。</p>
<p>另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的<code>const</code>是底层的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同。</span></span><br><span class="line"><span class="comment">//以下定义了4个独立的重载函数</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;		<span class="comment">//函数作用于Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;	<span class="comment">//新函数，作用于常量引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;		<span class="comment">//新函数，作用于指向Account的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account*)</span></span>;	<span class="comment">//新函数，作用于指向常量的指针</span></span><br></pre></td></tr></table></figure>
<p>以上，我们只能把<code>const</code>对象传给使用<code>const</code>形参的函数；而<strong>4</strong>个函数都能作用于非常量对象或者指向非常量对象的指针。</p>
<blockquote>
<p>不过，当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。</p>
</blockquote>
<h4 id="const_cast和重载"><a class="markdownIt-Anchor" href="#const_cast和重载"></a> const_cast和重载</h4>
<p><code>const_cast</code>在重载函数的情境中最有用。例如以下的<code>shortString</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string对象的长度，返回较短的那个引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shortString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的参数和返回类型都是<code>const string</code>的引用。我们可以对两个非常量的<code>string</code>实参调用函数，但返回的结果仍是<code>const string</code>的引用。因此我们需要一种新的<code>shortString</code>函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用<code>const_cast</code>可以做到这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">shortString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shortString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1), <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本的函数中，首先将它的实参强制转换成对<code>const</code>的引用，然后调用了<code>shortString</code>函数的<code>const</code>版本。<code>const</code>版本返回对<code>const string</code>的引用，这个引用事实上绑定在某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的<code>string&amp;</code>，这显然是安全的。</p>
<h4 id="调用重载的函数"><a class="markdownIt-Anchor" href="#调用重载的函数"></a> 调用重载的函数</h4>
<p><strong>函数匹配</strong>(function matching)是指一个过程，在这个过程中我们把函数调用和一组重载函数中的某一个关联起来，函数匹配也叫做<strong>重载确定</strong>(overload resolution)。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个参数。</p>
<p>调用重载函数时可能有三个结果：</p>
<ul>
<li>编译器找到一个与实参<strong>最佳匹配</strong>(best match)的函数，并生成调用该函数的代码。</li>
<li>找不到一个函数与调用的实参匹配，此时编译器发出<strong>无匹配</strong>(no match)的错误信息。</li>
<li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用</strong>(ambiguous call)。</li>
</ul>
<blockquote>
<p><strong>Tip:</strong> 不要将函数声明在局部作用域内。尤其当重载函数时，内层的函数声明会隐藏外层的同名函数声明，使得作用域内不能准确匹配重载函数。</p>
</blockquote>
<h3 id="特殊用途语言特性"><a class="markdownIt-Anchor" href="#特殊用途语言特性"></a> 特殊用途语言特性</h3>
<p>以下是一些对程序非常有用的语言特性，分别是：默认实参、内联函数和<strong>constexpr</strong>函数，以及在程序调试过程中常用的一些功能。</p>
<h4 id="默认实参"><a class="markdownIt-Anchor" href="#默认实参"></a> 默认实参</h4>
<p>调用含有<strong>默认实参</strong>(default argument)的函数时，可以包含该实参，也可以省略该实参。</p>
<p>例如，我们使用<code>string</code>对象表示窗口的内容。一般情况下，我们希望窗口的高、宽和背景字符都使用默认值。但是同时我们也应该允许用户为这几个参数自由指定于默认值不同的数值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span> , sz wid = <span class="number">80</span> , <span class="type">char</span> backgrnd = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中我们为每一个形参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<p><strong>使用默认实参</strong></p>
<p>使用默认实参只要在调用函数时省略该实参就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string window;</span><br><span class="line">window = <span class="built_in">screen</span>();				<span class="comment">//等价于screen(24,80,&#x27; &#x27;)</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>);			<span class="comment">//等价于screen(66,80,&#x27; &#x27;)</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>);		<span class="comment">//screen(66,256,&#x27; &#x27;)</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>,<span class="string">&#x27;#&#x27;</span>);	<span class="comment">//screen(66,256,&#x27;#&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参(靠右侧位置)。例如想要覆盖<code>backgrnd</code>的默认值，必须为<code>ht</code>和<code>wid</code>提供实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window = <span class="built_in">screen</span>( , , <span class="string">&#x27;?&#x27;</span>);		<span class="comment">//错误，只能省略尾部的实参</span></span><br><span class="line">window = <span class="built_in">screen</span>(<span class="string">&#x27;?&#x27;</span>);			<span class="comment">//调用screen(&#x27;?&#x27;,80,&#x27; &#x27;)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意，第二个调用传递一个字符值，是合法的调用。但是它的实际效果却与书写的意图不符。</p>
</blockquote>
<p>当设计含有默认实参的函数时，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p>
<p><strong>默认实参声明</strong></p>
<p>在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。假如给定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示高度和宽度的形参没有默认值</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们不能修改一个已经存在的默认值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;			<span class="comment">//错误，重复声明</span></span><br></pre></td></tr></table></figure>
<p>但是可以按照如下形式添加默认实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="type">char</span>)</span></span>;		<span class="comment">//正确，添加默认实参</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip:</strong> 通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p>
</blockquote>
<p><strong>设置和改变默认实参初始值</strong></p>
<p>局部变量不能作为默认初始值。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wd、def和ht的声明必须出现在函数之外</span></span><br><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="type">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="type">char</span> = def)</span></span>;</span><br><span class="line">string window = <span class="built_in">screen</span>();		<span class="comment">//调用screen(ht(), 80, &#x27; &#x27;)</span></span><br></pre></td></tr></table></figure>
<p>用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    def = <span class="string">&#x27;*&#x27;</span>;				<span class="comment">//改变默认实参的值</span></span><br><span class="line">    sz wd = <span class="number">100</span>;			<span class="comment">//隐藏了外层定义的wd，但是没有改变默认值</span></span><br><span class="line">    window = <span class="built_in">screen</span>();		<span class="comment">//调用screen(ht(), 80, &#x27;*&#x27;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在函数<code>f2</code>内部改变了<code>def</code>的值，所以对<code>screen</code>的调用将会传递这个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的<code>wd</code>，但是该局部变量与传递给<code>screen</code>的默认实参没有任何关系。</p>
<h4 id="内联函数和constexpr函数"><a class="markdownIt-Anchor" href="#内联函数和constexpr函数"></a> 内联函数和constexpr函数</h4>
<p>把先前像<code>shortString</code>这样的规模较小的操作定义为一个函数有很多好处，但也存在一个潜在的缺点：调用函数一般比求等价表达式的值要慢一些。</p>
<p>在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。</p>
<h5 id="内联函数可避免函数调用的开销"><a class="markdownIt-Anchor" href="#内联函数可避免函数调用的开销"></a> 内联函数可避免函数调用的开销</h5>
<p>将函数指定为<strong>内联函数</strong>(inline)，通常就是将它在每个调用点上“<strong>内联地</strong>”展开。假设我们把<code>shortString</code>函数定义成内联函数。则如下调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">shortString</span>(s1, s2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>将在编译过程中展开成类似于下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1 : s2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>从而消除了<code>shortString</code>函数运行时的开销。</p>
<p>在<code>shortString</code>函数的返回类型前面加上关键字<code>inline</code>，就可以将它声明成内联函数了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内联版本：寻找两个string对象中较短的那个</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;</span></span><br><span class="line"><span class="function"><span class="title">shortString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，内联机制用于规模较小、流程直接、频繁调用的函数。</p>
<blockquote>
<p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p>
</blockquote>
<h5 id="constexpr函数"><a class="markdownIt-Anchor" href="#constexpr函数"></a> constexpr函数</h5>
<p><code>constexpr</code>函数(constexpr function)是指能用于常量表达式的函数。</p>
<p>定义<code>constexpr</code>函数的方法与其他函数类似，不过要遵守两项约定：</p>
<ul>
<li>函数的返回类型及所有形参的类型都得是字面值类型。</li>
<li>函数体中有且仅有一条<code>return</code>语句。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();		<span class="comment">//正确，foo是一个常量表达式</span></span><br></pre></td></tr></table></figure>
<p>我们把<code>new_sz</code>定义成无参数的<code>constexpr</code>函数。</p>
<p>因为编译器能在程序编译时验证<code>new_sz</code>函数返回的是常量表达式，所以可以用<code>new_sz</code>函数初始化<code>constexpr</code>类型的变量<code>foo</code>。</p>
<p>以上展示的是<code>constexpr</code>函数返回常量表达式的情况，但实际上，<code>constexpr</code>函数也能返回非常量表达式，这取决于调用该类型函数传递的实参是否有常量表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果arg是常量表达式，则scale(arg)也是常量表达式</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt; &#125;</span><br></pre></td></tr></table></figure>
<p>当<code>scale</code>的实参是常量表达式时，它的返回值也是常量表达式；反之则不然：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];		<span class="comment">//正确，scale(2)是常量表达式</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;				<span class="comment">//i不是常量表达式</span></span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)];		<span class="comment">//错误，scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure>
<p>如上例所示，当我们给<code>scale</code>函数传入一个形如字面值<strong>2</strong>的常量表达式时，它的返回类型也是常量表达式。此时，编译器用相应的结果值替换对<code>scale</code>函数的调用。</p>
<p>如果我们用一个非常量表达式调用<code>scale</code>函数，比如<code>int</code>类型的对象<code>i</code>，则返回值是一个非常量表达式。当把<code>scale</code>函数用在需要常量表达式的上下文中时，由编译器负责检查函数的结果是否符合要求。如果结果恰好不是常量表达式，编译器将发出错误消息。</p>
<blockquote>
<p>constexpr函数体内实际也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如constexpr函数中可以有空语句、类型别名以及using声明。</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> 内联函数和constexpr函数通常定义在头文件中。</p>
</blockquote>
<h5 id="调试功能"><a class="markdownIt-Anchor" href="#调试功能"></a> 调试功能</h5>
<p>C++程序员有时会用到一种类似于头文件保护的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：<strong>assert</strong>和<strong>NDEBUG</strong>。</p>
<p><strong>assert预处理宏</strong></p>
<p><code>assert</code>是一种<strong>预处理宏</strong>(preprocessor marco)。所谓预处理宏其实是一个<strong>预处理变量</strong>，它的行为有点类似于内联函数。<code>assert</code>宏使用一个表达式作为它的条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(expr);</span><br></pre></td></tr></table></figure>
<p>首先对<code>expr</code>求值，如果表达式为假(即<strong>0</strong>)，<code>assert</code>输出信息并终止程序的执行。如果表达式为真(即非<strong>0</strong>)，<code>assert</code>什么也不做。</p>
<p><code>assert</code><strong>宏定义</strong>在<code>cassert</code>头文件中。如我们所知，预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无须提供<code>using</code>声明。也就是说，我们应该使用<code>assert</code>而不是<code>std::assert</code>，也不需要为<code>assert</code>提供<code>using</code>声明。</p>
<p>和预处理变量一样，宏名字在程序内必须唯一。含有<code>cassert</code>头文件的程序不能再定义名为<code>assert</code>的变量、函数或者其他实体。</p>
<blockquote>
<p>即使没有包含cassert头文件，也最好不要为了其他目的使用assert，因为很多头文件都包含了cassert。</p>
</blockquote>
<p><code>assert</code>宏常用来检查“<strong>不允许发生</strong>”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(word.<span class="built_in">size</span>() &gt; threshold);</span><br></pre></td></tr></table></figure>
<p><strong>NDEBUG预处理变量</strong></p>
<p><code>assert</code>的行为依赖于一个名为<code>NDEBUG</code>的预处理变量的状态。如果定义了<code>NDEBUG</code>，则<code>assert</code>什么也不做。默认状态下没有定义<code>NDEBUG</code>，此时<code>assert</code>将执行运行时检查。</p>
<p>我们可以使用一个<code>#define</code>语句定义<code>NDEBUG</code>，从而关闭调试状态。同时，很多编译器提供了一个命令行选项使我们可以定义预处理变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CC -D NDEBUG main.C <span class="comment"># use /D with the Microsoft compiler</span></span><br></pre></td></tr></table></figure>
<p>这条命令的作用等价于在<code>main.c</code>文件的一开始写 <code>#define NDEBUG</code>。</p>
<p>定义<code>NDEBUG</code>能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。因此，<code>assert</code>应该仅用于验证那些确实不可能发生的事情。我们可以把<code>assert</code>当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。</p>
<p>除了用于<code>assert</code>外，也可以使用<code>NDEBUG</code>编写自己的条件调试代码。如果<code>NDEBUG</code>未定义，将执行<code>#ifnde</code>f和<code>#endif</code>之间的代码；如果定义了<code>NDEBUG</code>，这些代码将被忽略掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( <span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// __func__ 是编译器定义的一个局部静态变量，用于存放函数的名字。</span></span><br><span class="line">    cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: array size is &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> 以下所有的变量名中的空格只是为了书写展示，在实际代码中都是没有的。</p>
</blockquote>
<p>在这段代码中，我们使用变量 <code>_ _ func _ _</code> 输出当前调试的函数的名字。编译器为每个函数都定义了 <code>_ _ func _ _</code> ，它是<code>const char</code>的一个静态数组，用于存放函数的名字。</p>
<p>除了 C++ 编译器定义的 <code>_ _ func _ _</code> 之外，预处理器还定义了<strong>4</strong>个对于程序调试很有用的名字：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>_ _ FILE _ _</td>
<td>存放文件名的字符串字面值</td>
</tr>
<tr>
<td>_ _ LINE _ _</td>
<td>存放当前行号的整型字面值</td>
</tr>
<tr>
<td>_ _ TIME _ _</td>
<td>存放文件编译时间的字符串字面值</td>
</tr>
<tr>
<td>_ _ DATA _ _</td>
<td>存放文件编译日期的字符串字面值</td>
</tr>
</tbody>
</table>
<p>可以使用这些常量在错误消息中提供更多信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( word.<span class="built_in">size</span>() &lt; threshold )</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; __FILE__</span><br><span class="line">    	 &lt;&lt; <span class="string">&quot; : in function &quot;</span> &lt;&lt; __func__</span><br><span class="line">    	 &lt;&lt; <span class="string">&quot; at line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl</span><br><span class="line">    	 &lt;&lt; <span class="string">&quot;        Compiled on &quot;</span> &lt;&lt; __DATE__</span><br><span class="line">    	 &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl</span><br><span class="line">    	 &lt;&lt; <span class="string">&quot;        Word read was \&quot;&quot;</span> &lt;&lt; word</span><br><span class="line">    	 &lt;&lt; <span class="string">&quot;\&quot;: Length too short&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>如果我们给程序提供了一个长度小于<code>threshold</code>的<code>string</code>对象，将得到下面的错误消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: Wdebug.cpp : <span class="keyword">in</span> <span class="keyword">function</span> <span class="built_in">print</span> at line 19</span><br><span class="line">        Compiled on Mar 10 2024 at 16:45:10</span><br><span class="line">        Word <span class="built_in">read</span> was <span class="string">&quot;foo&quot;</span>: Length too short</span><br></pre></td></tr></table></figure>
<h3 id="函数匹配"><a class="markdownIt-Anchor" href="#函数匹配"></a> 函数匹配</h3>
<ol>
<li>先选定<strong>候选函数</strong>：与被调用函数同名、其声明在调用点可见。</li>
<li>再选出<strong>可行函数</strong>：实参数量足够(允许默认实参)，每个实参的类型与对应的形参类型相同或者能转换成形参的类型。</li>
<li>在可行函数中找<strong>最佳匹配</strong>(如果有的话)。</li>
</ol>
<blockquote>
<p><strong>最佳匹配</strong></p>
<p>如果有且只有一个函数满足下列条件，则匹配成功：</p>
<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li>
</ul>
<p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用错误。</p>
</blockquote>
<blockquote>
<p>所有算数类型转换的级别是一样的。例如，从int向unsigned int的转换并不比从int向double的转换级别高：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">3.14</span>);			<span class="comment">//错误，二义性调用</span></span><br></pre></td></tr></table></figure>
<p>字面值<strong>3.14</strong>的类型是double，它既能转换成float。因为存在两种可能的算术类型转换，所以该调用具有二义性。</p>
</blockquote>
<h3 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h3>
<p>函数指针指向的是函数而非对象。</p>
<p>和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string对象的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数的类型是<code>bool(const string&amp;, const string&amp;)</code>。要想声明一个可以指向该函数类型的指针，只需要用指针<strong>替换</strong>该函数名即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型</span></span><br><span class="line"><span class="built_in">bool</span> (*pf) (<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);	<span class="comment">//未初始化</span></span><br></pre></td></tr></table></figure>
<p>从我们声明的名字开始观察，<code>pf</code>前面有个 *，因此<code>pf</code>是指针；右侧是形参列表，表示<code>pf</code>指向的是函数；再观察左侧，发现函数的返回类型是布尔值。因此，<code>pf</code>是一个指向函数的指针，其中该函数的参数是两个<code>const string</code>的引用，返回值是<code>bool</code>类型。</p>
<blockquote>
<p><code>*pf</code>两端的括号必不可少，否则pf是一个返回值为bool指针的函数。</p>
</blockquote>
<h4 id="使用函数指针"><a class="markdownIt-Anchor" href="#使用函数指针"></a> 使用函数指针</h4>
<p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。例如，按照如下形式我们可以将<code>lengthCompare</code>的地址赋给<code>pf</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;		<span class="comment">//pf指向名为lengthCompare的函数</span></span><br><span class="line">pf = &amp;lengthCompare;	<span class="comment">//等价的赋值语句，取地址符是可选的</span></span><br></pre></td></tr></table></figure>
<p>此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);				<span class="comment">//调用lengthCompare函数</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);			<span class="comment">//一个等价的调用</span></span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);	<span class="comment">//另一个等价的调用</span></span><br></pre></td></tr></table></figure>
<p>在指向不同函数类型(返回类型不同或形参类型不同)的指针之间不存在转换规则。但是，我们可以为函数指针赋一个<code>nullptr</code>或者值为<strong>0</strong>的整型常量表达式，表示该指针没有指向任何一个函数。</p>
<h4 id="重载函数的指针"><a class="markdownIt-Anchor" href="#重载函数的指针"></a> 重载函数的指针</h4>
<p>当我们使用重载函数时，指针类型必须与重载函数中的某一个精准匹配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*pf1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff;		<span class="comment">//pf1指向ff(unsigned)</span></span><br><span class="line"><span class="built_in">void</span> (*pf2)(<span class="type">int</span>) = ff;				<span class="comment">//错误，没有任何一个ff与该形参列表匹配</span></span><br><span class="line"><span class="built_in">double</span> (*pf3)(<span class="type">int</span>*) = ff;			<span class="comment">//错误，ff和pf3的返回类型不匹配</span></span><br></pre></td></tr></table></figure>
<h4 id="函数指针形参"><a class="markdownIt-Anchor" href="#函数指针形参"></a> 函数指针形参</h4>
<blockquote>
<p><strong>Note:</strong> <strong>Luv</strong>认为这一块和下一块的内容跟<strong>数组指针做形参</strong>的内容极其相似。</p>
</blockquote>
<p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个形参是函数类型，它会自动地转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">( <span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> pf(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;) )</span></span>;</span><br><span class="line"><span class="comment">//等价的声明，显式地将形参定义成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">( <span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;) )</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们可以直接把函数作为实参使用，此时它会自动转换成指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动将函数lengthCompare转换成指向该函数的指针</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure>
<p>正如<code>useBigger</code>的声明语句所示，直接使用函数指针类型显得冗长而烦琐。类型别名和<code>decltype</code>能让我们简化使用了函数指针的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;		<span class="comment">//等价的类型</span></span><br><span class="line"><span class="comment">//FuncP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;	<span class="comment">//等价的类型</span></span><br></pre></td></tr></table></figure>
<p><code>decltype</code>返回函数类型，不会自动转为指针类型，需要在结果前面加上 * 才能得到指针。可以按如下形式重新声明<code>useBigger</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//useBigger的等价声明，其中使用了类型别名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">( <span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;, Func)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">( <span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;, FuncP2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动地将<code>Func</code>表示的函数类型转换成指针。</p>
<h4 id="返回指向函数的指针"><a class="markdownIt-Anchor" href="#返回指向函数的指针"></a> 返回指向函数的指针</h4>
<p>和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。</p>
<p>与往常一样，要想声明一个返回函数指针的函数，最简单的方法就是使用类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>);		<span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span>*, <span class="type">int</span>);	<span class="comment">//PF是指针类型</span></span><br></pre></td></tr></table></figure>
<p>将F定义成函数类型，将<code>PF</code>定义成指向函数类型的指针。必须注意的是，和函数类型的形参不同，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;			<span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;			<span class="comment">//错误，F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;			<span class="comment">//正确，显式地指定返回类型是指向函数的指针</span></span><br></pre></td></tr></table></figure>
<p>当然，我们也能用下面的形式直接声明<code>f1</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>)) (<span class="type">int</span>*, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>按照由内向外的顺序阅读这条声明语句：我们看到<code>f1</code>有形参列表，所以<code>f1</code>是个函数；<code>f1</code>前面有 *，所以<code>f1</code>返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是<code>int</code>。</p>
<p>还可以使用尾置返回类型的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="将auto和decltype用于函数指针类型"><a class="markdownIt-Anchor" href="#将auto和decltype用于函数指针类型"></a> 将auto和decltype用于函数指针类型</h5>
<p>如果明确知道返回的函数是哪一个，就能使用<code>decltype</code>简化书写函数指针返回类型的过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function">string::size_type <span class="title">largerLength</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="comment">//根据其形参的取值，getFun函数返回指向sumLength或者largeLenth的指针</span></span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *<span class="built_in">getFun</span>(<span class="type">const</span> string&amp;);</span><br></pre></td></tr></table></figure>
<p>声明<code>getFun</code>需要注意，<code>decltype</code>返回函数类型而非指针类型，因此必须显式地加上 * 以表示我们需要返回指针，而非函数本身。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luvreadunion.com/2024/03/10/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0/" data-id="cm609lk82000r1g9qc63q1anq" data-title="惊变42天: Week 2 见龙在田" class="article-share-link">分享</a>
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%83%8A%E5%8F%9842%E5%A4%A9-C/" rel="tag">惊变42天:C++</a></li></ul>


    </footer>
  </div>
  
    
  <nav id="article-nav" class="wow fadeInUp">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          <img data-src="/images/66458540.avif" data-sizes="auto" alt="惊变42天: Week 3 君子终日乾乾" class="lazyload">
        
        <a href="/2024/03/20/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E5%90%9B%E5%AD%90%E7%BB%88%E6%97%A5%E4%B9%BE%E4%B9%BE/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            惊变42天: Week 3 君子终日乾乾
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        <img data-src="/images/50172085.avif" data-sizes="auto" alt="我希望你快乐" class="lazyload">
      
      <a href="/2024/03/03/Luv%E7%9A%84%E9%9A%8F%E7%AC%94%EF%BC%9A%E6%88%91%E5%B8%8C%E6%9C%9B%E4%BD%A0%E5%BF%AB%E4%B9%90/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          我希望你快乐
        
      </h3>
    </div>
    
  </nav>


  
</article>






</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrap wow fadeInRight wrap-sticky">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%9C%BA%E7%99%BD"><span class="toc-number">1.</span> <span class="toc-text"> 开场白</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-1-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text"> Week 1: 潜龙勿用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-2-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0"><span class="toc-number">3.</span> <span class="toc-text"> Week 2: 见龙在田</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text"> 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.1.1.</span> <span class="toc-text"> 重载运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">3.1.1.2.</span> <span class="toc-text"> 左值和右值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E5%92%8C%E5%8F%96%E4%BD%99"><span class="toc-number">3.1.2.1.</span> <span class="toc-text"> 除法和取余</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 逻辑和关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.3.1.</span> <span class="toc-text"> 逻辑与和逻辑或运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.3.2.</span> <span class="toc-text"> 关系运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7%E8%BE%83%E4%BD%8E"><span class="toc-number">3.1.4.1.</span> <span class="toc-text"> 赋值运算优先级较低</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.5.</span> <span class="toc-text"> 递增和递减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%B7%B7%E7%94%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.5.1.</span> <span class="toc-text"> 在一条语句中混用解引用和递增运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.6.</span> <span class="toc-text"> 条件运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.6.1.</span> <span class="toc-text"> 嵌套条件运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%BE%93%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.6.2.</span> <span class="toc-text"> 在输出表达式中使用条件运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.7.</span> <span class="toc-text"> 位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.8.</span> <span class="toc-text"> sizeof运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.9.</span> <span class="toc-text"> 逗号运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.</span> <span class="toc-text"> 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.1.</span> <span class="toc-text"> 算术转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87"><span class="toc-number">3.1.10.1.1.</span> <span class="toc-text"> 整型提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.10.1.2.</span> <span class="toc-text"> 无符号类型运算对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.2.</span> <span class="toc-text"> 其他隐式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%8C%87%E9%92%88"><span class="toc-number">3.1.10.2.1.</span> <span class="toc-text"> 数组转换成指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.2.2.</span> <span class="toc-text"> 指针转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.10.2.3.</span> <span class="toc-text"> 转换成布尔类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B8%B8%E9%87%8F"><span class="toc-number">3.1.10.2.4.</span> <span class="toc-text"> 转换成常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.2.5.</span> <span class="toc-text"> 类类型定义的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.3.</span> <span class="toc-text"> 显式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.3.1.</span> <span class="toc-text"> 命名的强制类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A7%E5%BC%8F%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.3.2.</span> <span class="toc-text"> 旧式的强制类型转换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.</span> <span class="toc-text"> 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 复合语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.2.</span> <span class="toc-text"> switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.3.</span> <span class="toc-text"> for语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Ffor%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.3.1.</span> <span class="toc-text"> 传统for语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.3.2.</span> <span class="toc-text"> 范围for语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.4.</span> <span class="toc-text"> 跳转语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#goto%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.4.1.</span> <span class="toc-text"> goto语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.2.5.</span> <span class="toc-text"> try语句块和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#throw%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.2.5.1.</span> <span class="toc-text"> throw表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">3.2.5.2.</span> <span class="toc-text"> try语句块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.5.2.1.</span> <span class="toc-text"> 编写处理代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9C%A8%E5%AF%BB%E6%89%BE%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%80%80%E5%87%BA"><span class="toc-number">3.2.5.2.2.</span> <span class="toc-text"> 函数在寻找处理代码的过程中退出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.5.3.</span> <span class="toc-text"> 标准异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text"> 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%88%97%E8%A1%A8"><span class="toc-number">3.3.1.1.</span> <span class="toc-text"> 形参列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.1.2.</span> <span class="toc-text"> 函数返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.1.3.</span> <span class="toc-text"> 局部对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.1.3.1.</span> <span class="toc-text"> 自动对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.1.3.2.</span> <span class="toc-text"> 局部静态对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">3.3.1.4.</span> <span class="toc-text"> 函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91"><span class="toc-number">3.3.1.5.</span> <span class="toc-text"> 分离式编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.1.5.1.</span> <span class="toc-text"> 编译和链接多个源文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.3.2.1.</span> <span class="toc-text"> 使用引用避免拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">3.3.2.2.</span> <span class="toc-text"> const形参和实参</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82%E4%B8%8Econst"><span class="toc-number">3.3.2.2.1.</span> <span class="toc-text"> 指针或引用形参与const</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.2.2.</span> <span class="toc-text"> 尽量使用常量引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.2.3.</span> <span class="toc-text"> 数组形参</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.2.3.1.</span> <span class="toc-text"> 数组引用形参</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.3.2.3.2.</span> <span class="toc-text"> 传递多维数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">3.3.2.4.</span> <span class="toc-text"> main: 处理命令行选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.2.5.</span> <span class="toc-text"> 含有可变形参的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#initializer_list%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.2.5.1.</span> <span class="toc-text"> initializer_list形参</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.2.6.</span> <span class="toc-text"> 省略符形参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 返回类型和return语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%BF%94%E5%9B%9E%E7%9A%84"><span class="toc-number">3.3.3.1.</span> <span class="toc-text"> 值是如何被返回的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.3.3.2.</span> <span class="toc-text"> 返回类类型的函数和调用运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E5%B7%A6%E5%80%BC"><span class="toc-number">3.3.3.3.</span> <span class="toc-text"> 引用返回左值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.3.3.4.</span> <span class="toc-text"> 列表初始化返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0main%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.3.3.5.</span> <span class="toc-text"> 主函数main的返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.4.</span> <span class="toc-text"> 返回数组指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.4.1.</span> <span class="toc-text"> 声明一个返回数组指针的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.4.2.</span> <span class="toc-text"> 使用尾置返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8decltype"><span class="toc-number">3.3.4.3.</span> <span class="toc-text"> 使用decltype</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">3.3.5.</span> <span class="toc-text"> 函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.5.1.</span> <span class="toc-text"> 定义重载函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8Cconst%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.5.2.</span> <span class="toc-text"> 重载和const形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const_cast%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">3.3.5.3.</span> <span class="toc-text"> const_cast和重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%87%8D%E8%BD%BD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.5.4.</span> <span class="toc-text"> 调用重载的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.6.</span> <span class="toc-text"> 特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">3.3.6.1.</span> <span class="toc-text"> 默认实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.6.2.</span> <span class="toc-text"> 内联函数和constexpr函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%8F%AF%E9%81%BF%E5%85%8D%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">3.3.6.2.1.</span> <span class="toc-text"> 内联函数可避免函数调用的开销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constexpr%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.6.2.2.</span> <span class="toc-text"> constexpr函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="toc-number">3.3.6.2.3.</span> <span class="toc-text"> 调试功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">3.3.7.</span> <span class="toc-text"> 函数匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.</span> <span class="toc-text"> 函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.1.</span> <span class="toc-text"> 使用函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.2.</span> <span class="toc-text"> 重载函数的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.8.3.</span> <span class="toc-text"> 函数指针形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.4.</span> <span class="toc-text"> 返回指向函数的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86auto%E5%92%8Cdecltype%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.8.4.1.</span> <span class="toc-text"> 将auto和decltype用于函数指针类型</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/lian.gif" data-sizes="auto" alt="Luv" class="lazyload">
  <div class="sidebar-author-name">Luv</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">11</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">8</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">15</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>
</div>
    
    
      <div class="sidebar-btn-wrapper" style="position:static">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  </div>

  
</aside>

          
        </div>
        <footer id="footer" class="wow fadeInUp">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="outer">
    <div id="footer-info" class="inner">
      
      <div>
        <span class="icon-copyright"></span>
        2020-2025
        <span class="footer-info-sep"></span>
        Luv
      </div>
      
        <div>
          基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
          Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
        </div>
      
      
        <div>
          <span class="icon-brush"></span>
          99.1k
          &nbsp;|&nbsp;
          <span class="icon-coffee"></span>
          06:14
        </div>
      
      
        <div>
          <span class="icon-eye"></span>
          <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
          &nbsp;|&nbsp;
          <span class="icon-user"></span>
          <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
        </div>
      
    </div>
  </div>
</footer>

        <div class="sidebar-top">
          <img src="/images/taichi.png" height="50" width="50" />
          <div class="arrow-up"></div>
        </div>
        <div id="mask"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%9C%BA%E7%99%BD"><span class="toc-number">1.</span> <span class="toc-text"> 开场白</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-1-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text"> Week 1: 潜龙勿用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-2-%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0"><span class="toc-number">3.</span> <span class="toc-text"> Week 2: 见龙在田</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text"> 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.1.1.</span> <span class="toc-text"> 重载运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">3.1.1.2.</span> <span class="toc-text"> 左值和右值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E5%92%8C%E5%8F%96%E4%BD%99"><span class="toc-number">3.1.2.1.</span> <span class="toc-text"> 除法和取余</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 逻辑和关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.3.1.</span> <span class="toc-text"> 逻辑与和逻辑或运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.3.2.</span> <span class="toc-text"> 关系运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7%E8%BE%83%E4%BD%8E"><span class="toc-number">3.1.4.1.</span> <span class="toc-text"> 赋值运算优先级较低</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.5.</span> <span class="toc-text"> 递增和递减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%B7%B7%E7%94%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.5.1.</span> <span class="toc-text"> 在一条语句中混用解引用和递增运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.6.</span> <span class="toc-text"> 条件运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.6.1.</span> <span class="toc-text"> 嵌套条件运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%BE%93%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.6.2.</span> <span class="toc-text"> 在输出表达式中使用条件运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.7.</span> <span class="toc-text"> 位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.8.</span> <span class="toc-text"> sizeof运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.9.</span> <span class="toc-text"> 逗号运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.</span> <span class="toc-text"> 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.1.</span> <span class="toc-text"> 算术转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87"><span class="toc-number">3.1.10.1.1.</span> <span class="toc-text"> 整型提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.10.1.2.</span> <span class="toc-text"> 无符号类型运算对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.2.</span> <span class="toc-text"> 其他隐式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%8C%87%E9%92%88"><span class="toc-number">3.1.10.2.1.</span> <span class="toc-text"> 数组转换成指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.2.2.</span> <span class="toc-text"> 指针转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.10.2.3.</span> <span class="toc-text"> 转换成布尔类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B8%B8%E9%87%8F"><span class="toc-number">3.1.10.2.4.</span> <span class="toc-text"> 转换成常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.2.5.</span> <span class="toc-text"> 类类型定义的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.3.</span> <span class="toc-text"> 显式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.3.1.</span> <span class="toc-text"> 命名的强制类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A7%E5%BC%8F%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.10.3.2.</span> <span class="toc-text"> 旧式的强制类型转换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.</span> <span class="toc-text"> 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 复合语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.2.</span> <span class="toc-text"> switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.3.</span> <span class="toc-text"> for语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Ffor%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.3.1.</span> <span class="toc-text"> 传统for语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.3.2.</span> <span class="toc-text"> 范围for语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.4.</span> <span class="toc-text"> 跳转语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#goto%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.4.1.</span> <span class="toc-text"> goto语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.2.5.</span> <span class="toc-text"> try语句块和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#throw%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.2.5.1.</span> <span class="toc-text"> throw表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">3.2.5.2.</span> <span class="toc-text"> try语句块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.5.2.1.</span> <span class="toc-text"> 编写处理代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9C%A8%E5%AF%BB%E6%89%BE%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%80%80%E5%87%BA"><span class="toc-number">3.2.5.2.2.</span> <span class="toc-text"> 函数在寻找处理代码的过程中退出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.5.3.</span> <span class="toc-text"> 标准异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text"> 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%88%97%E8%A1%A8"><span class="toc-number">3.3.1.1.</span> <span class="toc-text"> 形参列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.1.2.</span> <span class="toc-text"> 函数返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.1.3.</span> <span class="toc-text"> 局部对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.1.3.1.</span> <span class="toc-text"> 自动对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.1.3.2.</span> <span class="toc-text"> 局部静态对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">3.3.1.4.</span> <span class="toc-text"> 函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91"><span class="toc-number">3.3.1.5.</span> <span class="toc-text"> 分离式编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.1.5.1.</span> <span class="toc-text"> 编译和链接多个源文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.3.2.1.</span> <span class="toc-text"> 使用引用避免拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">3.3.2.2.</span> <span class="toc-text"> const形参和实参</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82%E4%B8%8Econst"><span class="toc-number">3.3.2.2.1.</span> <span class="toc-text"> 指针或引用形参与const</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.2.2.</span> <span class="toc-text"> 尽量使用常量引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.2.3.</span> <span class="toc-text"> 数组形参</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.2.3.1.</span> <span class="toc-text"> 数组引用形参</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.3.2.3.2.</span> <span class="toc-text"> 传递多维数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">3.3.2.4.</span> <span class="toc-text"> main: 处理命令行选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.2.5.</span> <span class="toc-text"> 含有可变形参的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#initializer_list%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.2.5.1.</span> <span class="toc-text"> initializer_list形参</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.2.6.</span> <span class="toc-text"> 省略符形参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 返回类型和return语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%BF%94%E5%9B%9E%E7%9A%84"><span class="toc-number">3.3.3.1.</span> <span class="toc-text"> 值是如何被返回的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.3.3.2.</span> <span class="toc-text"> 返回类类型的函数和调用运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E5%B7%A6%E5%80%BC"><span class="toc-number">3.3.3.3.</span> <span class="toc-text"> 引用返回左值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.3.3.4.</span> <span class="toc-text"> 列表初始化返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0main%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.3.3.5.</span> <span class="toc-text"> 主函数main的返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.4.</span> <span class="toc-text"> 返回数组指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.4.1.</span> <span class="toc-text"> 声明一个返回数组指针的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.4.2.</span> <span class="toc-text"> 使用尾置返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8decltype"><span class="toc-number">3.3.4.3.</span> <span class="toc-text"> 使用decltype</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">3.3.5.</span> <span class="toc-text"> 函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.5.1.</span> <span class="toc-text"> 定义重载函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8Cconst%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.5.2.</span> <span class="toc-text"> 重载和const形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const_cast%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">3.3.5.3.</span> <span class="toc-text"> const_cast和重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%87%8D%E8%BD%BD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.5.4.</span> <span class="toc-text"> 调用重载的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.6.</span> <span class="toc-text"> 特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">3.3.6.1.</span> <span class="toc-text"> 默认实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.6.2.</span> <span class="toc-text"> 内联函数和constexpr函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%8F%AF%E9%81%BF%E5%85%8D%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">3.3.6.2.1.</span> <span class="toc-text"> 内联函数可避免函数调用的开销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constexpr%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.6.2.2.</span> <span class="toc-text"> constexpr函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="toc-number">3.3.6.2.3.</span> <span class="toc-text"> 调试功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">3.3.7.</span> <span class="toc-text"> 函数匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.</span> <span class="toc-text"> 函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.1.</span> <span class="toc-text"> 使用函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.2.</span> <span class="toc-text"> 重载函数的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82"><span class="toc-number">3.3.8.3.</span> <span class="toc-text"> 函数指针形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.4.</span> <span class="toc-text"> 返回指向函数的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86auto%E5%92%8Cdecltype%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.8.4.1.</span> <span class="toc-text"> 将auto和decltype用于函数指针类型</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/lian.gif" data-sizes="auto" alt="Luv" class="lazyload">
  <div class="sidebar-author-name">Luv</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">11</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">8</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">15</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    <div class="site-search">
      <div class="reimu-popup popup">
        <div class="reimu-search">
          <span class="reimu-search-input-icon"></span>
          <div class="reimu-search-input" id="reimu-search-input"></div>
        </div>
        <div class="reimu-results">
          <div id="reimu-stats"></div>
          <div id="reimu-hits"></div>
          <div id="reimu-pagination" class="reimu-pagination"></div>
        </div>
        <span class="popup-btn-close"></span>
      </div>
    </div>
    
<script src="https://npm.webcache.cn/jquery@3.7.1/dist/jquery.min.js"></script>


<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script>



  
<script src="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script>




  
<script src="https://npm.webcache.cn/mermaid@9.4.3/dist/mermaid.min.js"></script>

  <script>
    if (window.mermaid) {
      // https://github.com/mermaid-js/mermaid/issues/1945
      const elementCode = '.mermaid'
      const saveOriginalData = () => {
        return new Promise((resolve, reject) => {
          try {
            var els = document.querySelectorAll(elementCode),
                count = els.length;
            els.forEach(element => {
              if (element.getAttribute('data-original-code') == null){
                element.setAttribute('data-original-code', element.innerHTML)
              }
              count--
              if(count == 0){
                resolve()
              }
            });
          } catch (error) {
          reject(error) 
          }
        })
      }
      const resetProcessed = () => {
        return new Promise((resolve, reject) => {
          try {
            var els = document.querySelectorAll(elementCode),
                count = els.length;
            els.forEach(element => {
              if(element.getAttribute('data-original-code') != null){
                element.removeAttribute('data-processed')
                element.innerHTML = element.getAttribute('data-original-code')
              }
              count--
              if(count == 0){
                resolve()
              }
            });
          } catch (error) {
          reject(error) 
          }
        })
      } 
      const loadMermaid = (theme) => {
        window.mermaid.initialize({theme})
        window.mermaid.init({theme}, document.querySelectorAll(elementCode))
      }
      document.body.addEventListener('dark-theme-set', () => {
        saveOriginalData()
        .then(resetProcessed())
        .then(loadMermaid('dark'))
        .catch(console.error)
      })
      document.body.addEventListener('light-theme-set', () => {
        saveOriginalData()
        .then(resetProcessed())
        .then(loadMermaid('default'))
        .catch(console.error)
      })
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>















  
<script src="https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js"></script>

  
<script src="https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js"></script>

  
<script src="/js/algolia_search.js"></script>

  <script>
    var CONFIG = {
      root: '/',
      algolia: {
        applicationID: "37ZQYZE607",
        apiKey: "dfdbcdcf987c68afcf35a63def2936e2",
        indexName: "Luv",
        hits: {
          "per_page": parseInt("10")
        },
        labels: {
          "input_placeholder": "搜索.....",
          "hits_empty": "未发现与 「${query}」相关内容",
          "hits_stats": "找到${hits}条结果（用时 ${time} ms）"
        }
      }
    };
  </script>



  
<script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script>

  <script>
    firework(JSON.parse('{"excludeElements":["a"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>







<script src="/js/script.js"></script>



  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '0.1.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  

  <!-- hexo injector body_end start -->
<script src="/js/insert_highlight.js" data-pjax></script>
<!-- hexo injector body_end end --></body>
  </html>

