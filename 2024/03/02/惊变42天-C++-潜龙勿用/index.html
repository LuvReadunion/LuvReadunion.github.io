
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <title>
    惊变42天: Week 1 潜龙勿用 |
    
    Luv Read Union
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
<link rel="stylesheet" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/regular.min.css">
<link rel="stylesheet" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/solid.min.css">

  <link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/brands.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;"><link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/v5-font-face.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;"><link rel="preload" href="https://npm.webcache.cn/@fortawesome/fontawesome-free@6.5.1/css/v4-font-face.min.css" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;">
  
<link rel="stylesheet" href="/css/loader.css">

  <meta name="description" content="开场白 QAQ开学了，心血来潮立了一个flag，挑战六周读完《C++ Primer》。 是中文版，毕竟英文啃不动一点。 Emmmmm… 三分钟热度的我究竟能否完成呢？ 拭目以待。 ο(&#x3D;•ω＜&#x3D;)ρ⌒☆  Week 1: 潜龙勿用  变量和基本类型 包括算数类型(arithmetic type)和空类型(void)    类型 含义 最小尺寸     bool 布尔类型 未定义   char 字">
<meta property="og:type" content="article">
<meta property="og:title" content="惊变42天: Week 1 潜龙勿用">
<meta property="og:url" content="https://luvreadunion.com/2024/03/02/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="Luv Read Union">
<meta property="og:description" content="开场白 QAQ开学了，心血来潮立了一个flag，挑战六周读完《C++ Primer》。 是中文版，毕竟英文啃不动一点。 Emmmmm… 三分钟热度的我究竟能否完成呢？ 拭目以待。 ο(&#x3D;•ω＜&#x3D;)ρ⌒☆  Week 1: 潜龙勿用  变量和基本类型 包括算数类型(arithmetic type)和空类型(void)    类型 含义 最小尺寸     bool 布尔类型 未定义   char 字">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-02T12:40:51.000Z">
<meta property="article:modified_time" content="2024-03-05T09:41:25.409Z">
<meta property="article:author" content="Luv">
<meta property="article:tag" content="惊变42天:C++">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Luv Read Union" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/typeface-source-code-pro@1.1.13/index.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css">

  
  
  
  
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script>

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/wowjs@1.1.3/css/libs/animate.css">

    
<script src="https://npm.webcache.cn/wowjs@1.1.3/dist/wow.min.js"></script>

    <script>
      new WOW({
        offset: 0,
        mobile: true,
        live: false
      }).init();
    </script>
  
  
    <script src="/sw.js"></script>
  
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg"></div>
    <div class="loading-right-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
          <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
          <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
          <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
        </svg>
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    const startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    const endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('load', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/">首页</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/archives">归档</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/about">关于</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/friend">友链</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
    
    
      <a id="nav-search-btn" class="nav-icon popup-trigger" title="搜索"></a>
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="/images/62713194.avif" alt="惊变42天: Week 1 潜龙勿用">
  
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div id="logo-wrap">
        
          
          
            <a href="/" id="logo">
              <h1>惊变42天: Week 1 潜龙勿用</h1>
            </a>
          
        
      </div>
      
        
        <h2 id="subtitle-wrap">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="outer">
          
          <section id="main"><article id="post-惊变42天-C++-潜龙勿用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    <div class="article-meta">
      <div class="article-date wow slideInLeft">
  <a href="/2024/03/02/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8/" class="article-date-link">
    <time datetime="2024-03-02T12:40:51.000Z" itemprop="datePublished">2024-03-02</time>
  </a>
</div>

      
  <div class="article-category wow slideInLeft">
    <a class="article-category-link" href="/categories/C/">C++</a><a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="开场白"><a class="markdownIt-Anchor" href="#开场白"></a> 开场白</h1>
<p><strong>QAQ</strong>开学了，心血来潮立了一个<strong>flag</strong>，挑战<strong>六周</strong>读完《<strong>C++ Primer</strong>》。</p>
<p>是中文版，毕竟英文啃不动一点。</p>
<p><strong>Emmmmm…</strong></p>
<p>三分钟热度的我究竟能否完成呢？</p>
<p><strong>拭目以待。</strong></p>
<p><strong>ο(=•ω＜=)ρ⌒☆</strong></p>
<h1 id="week-1-潜龙勿用"><a class="markdownIt-Anchor" href="#week-1-潜龙勿用"></a> Week 1: 潜龙勿用</h1>
<h2 id="变量和基本类型"><a class="markdownIt-Anchor" href="#变量和基本类型"></a> 变量和基本类型</h2>
<p>包括<strong>算数类型(arithmetic type)<strong>和</strong>空类型(void)</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>布尔类型</td>
<td>未定义</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8位</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符</td>
<td>16位</td>
</tr>
<tr>
<td>char16_t</td>
<td>Unicode字符</td>
<td>16位</td>
</tr>
<tr>
<td>char32_t</td>
<td>Unicode字符</td>
<td>32位</td>
</tr>
<tr>
<td>short</td>
<td>整型</td>
<td>16位</td>
</tr>
<tr>
<td>int</td>
<td>长整型</td>
<td>16位</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>32位</td>
</tr>
<tr>
<td>long long</td>
<td>长整型</td>
<td>64位</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody>
</table>
<h3 id="类型转换易错点"><a class="markdownIt-Anchor" href="#类型转换易错点"></a> 类型转换易错点</h3>
<p>当出现 <code>int</code> 和 <code>unsigned int</code> 做算术运算时，<code>int</code> 型会转化为无符号型，此时若该值为负数，则体现为这个负数加上无符号数的模。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">cout &lt;&lt; u + i &lt;&lt; endl;			<span class="comment">//若int占32位，输出4294967264</span></span><br></pre></td></tr></table></figure>
<p>当出现<code>unsigned int</code>减去一个值时，无论该值是否为无符号型，结果均为非负。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u1 = <span class="number">42</span> , u2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; u1 - u2 &lt;&lt; endl;		<span class="comment">//正确：输出32</span></span><br><span class="line">cout &lt;&lt; u2 - u1 &lt;&lt; endl;		<span class="comment">//正确：但输出为取模后的值</span></span><br></pre></td></tr></table></figure>
<h3 id="转义序列"><a class="markdownIt-Anchor" href="#转义序列"></a> 转义序列</h3>
<table>
<thead>
<tr>
<th>换行符</th>
<th>\n</th>
<th>横向制表符</th>
<th>\t</th>
<th>报警/响铃符</th>
<th>\a</th>
</tr>
</thead>
<tbody>
<tr>
<td>纵向制表符</td>
<td>\v</td>
<td>退格符</td>
<td>\b</td>
<td>双引号</td>
<td>\ &quot;</td>
</tr>
<tr>
<td>反斜线</td>
<td>\ \</td>
<td>问号</td>
<td>?</td>
<td>单引号</td>
<td>\ ‘’</td>
</tr>
<tr>
<td>回车符</td>
<td>\r</td>
<td>进纸符</td>
<td>\f</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="泛化转义序列"><a class="markdownIt-Anchor" href="#泛化转义序列"></a> 泛化转义序列</h4>
<p><strong>( 单 ’ \ ’ 后接八进制数字，’ \x ’ 后接十六进制数字 )</strong></p>
<table>
<thead>
<tr>
<th>\7 响铃</th>
<th>\12 换行符</th>
<th>\40 空格</th>
</tr>
</thead>
<tbody>
<tr>
<td>\0 空字符</td>
<td>\115 字符M</td>
<td>\x4d 字符M</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Tip:</strong> 反斜线跟着的八进制数字若超出3个，则只有前3个数字与\构成转义序列；而\x会用到之后的所有数字。</p>
</blockquote>
<h3 id="指定字面值类型"><a class="markdownIt-Anchor" href="#指定字面值类型"></a> 指定字面值类型</h3>
<p>通过添加前缀和后缀，可以改变整型、浮点型、和字符型的字面值的默认类型。</p>
<p><strong>字符和字符型字面值</strong></p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>Unicode 16 字符</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>Unicode 32 字符</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8 (仅用于字符串字面常量)</td>
<td>char</td>
</tr>
</tbody>
</table>
<p><strong>整型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u or U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l or L</td>
<td>long</td>
</tr>
<tr>
<td>ll or LL</td>
<td>long long</td>
</tr>
</tbody>
</table>
<p><strong>浮点型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>f or F</td>
<td>float</td>
</tr>
<tr>
<td>l or L</td>
<td>long double</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="string">L&#x27;a&#x27;</span>				<span class="comment">//宽字符型字面值</span></span><br><span class="line"><span class="string">u8&quot;hi!&quot;</span>				<span class="comment">//utf-8字符串字面值</span></span><br><span class="line"><span class="number">42ULL</span>				<span class="comment">//无符号整型字面值</span></span><br><span class="line"><span class="number">1E-3</span>F				<span class="comment">//单精度浮点型字面值</span></span><br><span class="line"><span class="number">3.14159L</span>			<span class="comment">//扩展精度浮点型字面值</span></span><br></pre></td></tr></table></figure>
<p><code>true</code>和<code>false</code>是布尔类型的字面值；<code>nullptr</code>是指针字面值。</p>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<p><strong>对int的四种初始化方式：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> a &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>默认初始化</strong>：定义变量时没有指定初值</p>
<p>对于内置类型的变量未被初始化，值由位置决定。函数体之外的变量<strong>被初始化0</strong>，而内部将<strong>不被初始化</strong>，容易引发错误。</p>
<h3 id="声明和定义"><a class="markdownIt-Anchor" href="#声明和定义"></a> 声明和定义</h3>
<p>因为C++支持<strong>分离式编译</strong>(separate compilation)机制，将声明和定义区分开来。</p>
<p><strong>声明</strong>(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义</strong>(definition)负责创建与名字关联的实体。</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字<code>extern</code>，而且不要显示地初始化变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;			<span class="comment">//声明i而非定义i</span></span><br><span class="line"><span class="type">int</span> j;					<span class="comment">//声明并定义j</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip:</strong> 在函数体外给有extern标记的变量初始化，会被当成<strong>定义</strong>；而在函数体内，将引发<strong>错误</strong>。</p>
</blockquote>
<h4 id="标志符定义易错点"><a class="markdownIt-Anchor" href="#标志符定义易错点"></a> 标志符定义易错点</h4>
<p>用户自定义的标识符不能出现连续的下画线，也不能以下画线紧连大写字母开头；此外，定义在函数体外的标识符不能以下画线开头。</p>
<h4 id="变量命名规范"><a class="markdownIt-Anchor" href="#变量命名规范"></a> 变量命名规范</h4>
<ul>
<li>变量名一般用小写字母</li>
<li>用户自定义的类名一般以大写字母开头，如<code>Sales_item</code></li>
<li>多个单词组成的标识符要用下画线或大写区分，如<code>student_loan</code>或<code>studentLoan</code></li>
</ul>
<h3 id="复合类型compound-type"><a class="markdownIt-Anchor" href="#复合类型compound-type"></a> 复合类型(compound type)</h3>
<p>一条声明语句由一个<strong>基本数据类型(base type)<strong>和紧随其后的一个</strong>声明符(declarator)列表</strong>组成。</p>
<h4 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h4>
<blockquote>
<p><strong>Tip:</strong> C++11中新增了“右值引用(rvalue reference)”，我们通常所说的“引用(reference)”是&quot;左值引用(lvalue reference)&quot;。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp; refVal = ival;		<span class="comment">//refVal指向ival</span></span><br><span class="line"><span class="type">int</span> &amp; refVal2;				<span class="comment">//错误，引用必须初始化</span></span><br></pre></td></tr></table></figure>
<p>定义引用时，程序把引用和它的初始值<strong>绑定</strong>(bind)在一起，而非拷贝。引用无法重新绑定到另一个对象，因此必须初始化。</p>
<p><strong>引用即别名</strong>。因为引用本身不是一个对象，所以不能定义引用的引用。</p>
<blockquote>
<p><strong>Tip:</strong> 引用不能与字面值或某个计算结果绑定，且其类型必须与绑定对象<strong>严格匹配</strong>。</p>
</blockquote>
<h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4>
<p>与引用类似，指针也实现了对其他对象的间接访问，不同之处在于：</p>
<ul>
<li>指针本身是一个对象，允许对指针赋值和拷贝，且在其生命周期内可以先后指向几个不同的对象。</li>
<li>无须在定义时赋初值。</li>
</ul>
<p>指针类型要和其所指向的对象<strong>严格匹配</strong>。</p>
<h5 id="空指针null-pointer"><a class="markdownIt-Anchor" href="#空指针null-pointer"></a> 空指针(null pointer)</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成空指针的方法</span></span><br><span class="line"><span class="type">int</span> * p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> * p2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//需要先 #include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="type">int</span> * p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><code>nullptr</code>是一种特殊类型的字面值，可被转化成任意其他的指针类型。(最推荐)</p>
<p>过去的程序中用一个名为<code>NULL</code>的<strong>预处理变量(preprocessor variable)<strong>来给指针赋值，这个变量在头文件<code>cstdlib</code>中定义，它的值就是</strong>0</strong>。</p>
<blockquote>
<p>不能把int变量直接赋给指针，会引发错误。</p>
</blockquote>
<h5 id="void-指针"><a class="markdownIt-Anchor" href="#void-指针"></a> void* 指针</h5>
<p><code>void*</code>是一种特殊的指针类型，可用于存放任意对象的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span> , * pd = &amp; obj;</span><br><span class="line">						<span class="comment">//正确，void*能存放任意对象的地址</span></span><br><span class="line"><span class="type">void</span> * pv = &amp; obj;		<span class="comment">//obj可以是任意类型的对象</span></span><br><span class="line">pv = pd;				<span class="comment">//pv可以存放任意类型的指针</span></span><br></pre></td></tr></table></figure>
<h5 id="指向指针的引用"><a class="markdownIt-Anchor" href="#指向指针的引用"></a> 指向指针的引用</h5>
<p>引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;					<span class="comment">//p是一个int型指针</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p;			<span class="comment">//r是一个对指针p的引用</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip:</strong> 对于一条比较复杂的指针或引用的声明语句时，<strong>从右向左</strong>读来了解它的真实含义。</p>
</blockquote>
<h3 id="const限定符"><a class="markdownIt-Anchor" href="#const限定符"></a> const限定符</h3>
<p><code>const</code>对象一旦创建后其值就不能再改变，故<code>const</code>对象必须初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="built_in">get_size</span>();	<span class="comment">//正确：运行时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">42</span>;			<span class="comment">//正确：编译时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k;				<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip:</strong> 默认情况下,const对象只在文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
</blockquote>
<p>多个文件共享<code>const</code>对象的方法：</p>
<p>在声明和定义前都添加<code>extern</code>关键字，且只定义一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">//file_1.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;	<span class="comment">//与file_1.cc是同一个</span></span><br></pre></td></tr></table></figure>
<h4 id="const的引用"><a class="markdownIt-Anchor" href="#const的引用"></a> const的引用</h4>
<p>也简称”<strong>常量引用</strong>“。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;	<span class="comment">//正确</span></span><br><span class="line">r1 = <span class="number">42</span>;		<span class="comment">//错误：r1是对常量的引用</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;	<span class="comment">//错误：试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure>
<h5 id="特例"><a class="markdownIt-Anchor" href="#特例"></a> 特例</h5>
<p>允许为一个常量引用绑定非常量的对象、字面值、表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;			<span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;			<span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;		<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r1 * <span class="number">2</span>;			<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h5 id="对const的引用可能引用一个并非const的对象"><a class="markdownIt-Anchor" href="#对const的引用可能引用一个并非const的对象"></a> 对const的引用可能引用一个并非const的对象</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;				</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;		<span class="comment">//引用r1绑定对象i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;	<span class="comment">//r2也绑定对象i，但是不允许通过r2修改i的值</span></span><br><span class="line">r1 = <span class="number">0</span>;				<span class="comment">//正确</span></span><br><span class="line">r2 = <span class="number">0</span>;				<span class="comment">//错误，r2是一个常量引用</span></span><br></pre></td></tr></table></figure>
<h4 id="指向常量的指针pointer-to-const"><a class="markdownIt-Anchor" href="#指向常量的指针pointer-to-const"></a> 指向常量的指针(pointer to const)</h4>
<p>存放常量对象的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> * ptr = &amp;pi;			<span class="comment">//错误，ptr是一个普通指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> * cptr = &amp;pi;	<span class="comment">//正确</span></span><br><span class="line">* cptr = <span class="number">42</span>;				<span class="comment">//错误，不能改变其所指对象的值</span></span><br></pre></td></tr></table></figure>
<p>允许一个指向常量的指针指向一个非常量对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval;			<span class="comment">//正确，但不能通过cptr改变dval的值</span></span><br></pre></td></tr></table></figure>
<h4 id="常量指针const-pointer"><a class="markdownIt-Anchor" href="#常量指针const-pointer"></a> 常量指针(const pointer)</h4>
<p>允许把指针本身定义为常量，且必须初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNub = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> curErr = &amp; errNumb;</span><br><span class="line"><span class="comment">//curErr将一直指向errNumb</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> * <span class="type">const</span> pip = &amp; pi;</span><br><span class="line"><span class="comment">//pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>明白pip含义的过程</strong>：</p>
<p>从右向左读，const意味着pip本身是一个常量对象，对象的类型由声明符的其余部分决定。下一个符号是 * ，意思是pip是一个常量指针。最后确定pip指向的对象是一个双精度浮点型常量。</p>
</blockquote>
<h4 id="顶层const"><a class="markdownIt-Anchor" href="#顶层const"></a> 顶层const</h4>
<p><strong>指针本身是不是常量</strong>以及<strong>指针所指的是不是常量</strong>是两个独立的问题。</p>
<p>用名词<strong>顶层const</strong>(top-level const)表示指针本身是个常量，而用名词<strong>底层const</strong>(low-level const)表示指针所指的对象是个常量。</p>
<p>更一般的，<strong>顶层const</strong>可以表示任意的对象是常量。</p>
<h4 id="常量表达式const-expression和constexpr"><a class="markdownIt-Anchor" href="#常量表达式const-expression和constexpr"></a> 常量表达式(const expression)和constexpr</h4>
<p>值不会改变并在编译过程就能得到计算结果的表达式。用常量表达式初始化的<code>const</code>对象也是常量表达式。</p>
<p>C++11新标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否为常量表达式。声明为<code>constexpr</code>的变量一定是一个常量，而其必须用常量表达式初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;			<span class="comment">//20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;	<span class="comment">//mf + 1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>();		<span class="comment">//只有当size是一个constexpr函数时</span></span><br><span class="line">								<span class="comment">//才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>字面值类型</strong></p>
<p>声明constexpr时能用的类型一般都比较简单，统称为<strong>字面值类型(literal type)</strong>，包括算术类型、引用和指针。其中，引用和指针定义的constexpr的初始值会受到严格限制。(详情略)</p>
</blockquote>
<p>如果在<code>constexpr</code>声明中定义一个指针，限定符<code>constexpr</code>只对指针有效，而与其所指对象无关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p = <span class="literal">nullptr</span>;		<span class="comment">//p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> * q = <span class="literal">nullptr</span>;	<span class="comment">//q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<p><strong>p</strong>和<strong>q</strong>的类型相差甚远，其中的关键在于<code>constexpr</code>把它所定义的对象置为了<strong>顶层const</strong>(而往常指针的顶层<code>const</code>在右边)，其作用与其他常量指针类似，既可以指向常量也可以指向一个非常量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> * np = <span class="literal">nullptr</span>;	<span class="comment">//np是一个指向整数的常量指针，其值为空</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">42</span>;			<span class="comment">//i的类型是整型常量</span></span><br><span class="line"><span class="comment">//i和j都必须定义在函数体外(这样才有固定的地址作为常量表达式)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> * p = &amp; i;	<span class="comment">//p是常量指针，指向整型常量i</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p1 = &amp;j;			<span class="comment">//p1是常量指针，指向整数j</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用不是对象，因此”常量引用“的定义思路与”“指向常量的指针”类似，而与“常量指针”不同。</p>
</blockquote>
<h3 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h3>
<p><strong>类型别名</strong>(type alias)是一个名字，它是某种类型的同义词。</p>
<p>有两种方法可以定义类型别名：</p>
<p>使用关键字<code>typedef</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;		<span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base , *p;	<span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>
<p>使用<strong>别名声明(alias declaration)</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;		<span class="comment">//SI是Sales_item的同义词</span></span><br><span class="line"><span class="comment">//把等号左侧的名字规定成等号右侧类型的别名</span></span><br></pre></td></tr></table></figure>
<p>类型别名与类型的名字等价。</p>
<h4 id="指针-常量和类型别名"><a class="markdownIt-Anchor" href="#指针-常量和类型别名"></a> 指针、常量和类型别名</h4>
<p>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>;	<span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps;		<span class="comment">//ps是一个指针，它的对象是指向char的常量指针</span></span><br><span class="line"><span class="comment">//const pstring是指向char的常量指针，而非指向常量字符的指针</span></span><br></pre></td></tr></table></figure>
<h3 id="auto类型说明符"><a class="markdownIt-Anchor" href="#auto类型说明符"></a> auto类型说明符</h3>
<p><code>auto</code>让编译器通过初始值来推算变量的类型，所以必须有初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由val1和val2相加的结果可以推断出item的类型</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2;	<span class="comment">//item初始化为val1和val2相加的结果</span></span><br></pre></td></tr></table></figure>
<p>因为一条声明语句只能有一个基本数据类型，所以所有变量的初始数据类型都必须一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span> , *p = &amp;i		<span class="comment">//正确：i是整数、p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span> , pi = <span class="number">3.14</span>;	<span class="comment">//错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure>
<h4 id="复合类型-常量和auto"><a class="markdownIt-Anchor" href="#复合类型-常量和auto"></a> 复合类型、常量和auto</h4>
<p>使用引用初始化时，真实使用的是引用对象的值。</p>
<p><code>auto</code>一般会忽略顶层<code>const</code>，同时底层<code>const</code>则会保留下来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span> , &amp; r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i , &amp; cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;	<span class="comment">//b是一个整数(ci的顶层const特性被忽略掉了)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;	<span class="comment">//c是一个整数(cr是ci的别名，ci本身是一个顶层const)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;	<span class="comment">//d是一个整型指针(整数的地址就是指向整数的指针)</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;	<span class="comment">//e是一个指向整数常量的指针(对常量对象取地址是一种底层const)</span></span><br></pre></td></tr></table></figure>
<p>如果希望推断出的<code>auto</code>类型是一个顶层<code>const</code>，需要明确指出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;	<span class="comment">//ci的推演类型是int，f是const int</span></span><br></pre></td></tr></table></figure>
<p>还可以将引用的类型设为<code>auto</code>，此时原来的初始化规则仍然适用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;			<span class="comment">//g是一个整型常量引用，绑定到ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;			<span class="comment">//错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;		<span class="comment">//正确：可以为常量引用绑定字面值</span></span><br><span class="line"><span class="comment">//设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在一条语句中定义多个变量，符号 &amp; 和 * 只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> k = ci , &amp; l = i;		<span class="comment">//k是整数，l是整形引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci , *p = &amp;ci;	<span class="comment">//m是对整型常量的引用，p是指向整型常量的指针</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i , *p2 = &amp;ci;	<span class="comment">//错误：i的类型是int而&amp;ci的类型是const int</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="decltype类型指示符"><a class="markdownIt-Anchor" href="#decltype类型指示符"></a> decltype类型指示符</h3>
<p><code>auto</code>通过初始值来推算变量的类型。当希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量时，采用<code>decltype</code>，它的作用是选择并返回操作数的数据类型。</p>
<p>在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( <span class="built_in">f</span>() ) sum = x;</span><br><span class="line"><span class="comment">//sum的类型就是函数f的返回类型(并不实际调用)</span></span><br></pre></td></tr></table></figure>
<p>与<code>auto</code>不同，如果<code>decltype</code>处理的是变量，则返回该变量的类型(包括顶层<code>const</code>和引用在内)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span> , &amp; cj = ci;</span><br><span class="line"><span class="keyword">decltype</span> (ci) x = <span class="number">0</span>;	<span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span> (cj) y = x;	<span class="comment">//y的类型是const int &amp;，y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span> (cj) z;		<span class="comment">//错误：z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="decltype和引用"><a class="markdownIt-Anchor" href="#decltype和引用"></a> decltype和引用</h4>
<p>如果<code>decltype</code>使用的表达式内容是解引用操作，则<code>decltype</code>得到的是引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//decltype的结果可以是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span> , * p = &amp; i , &amp; r = i;</span><br><span class="line"><span class="keyword">decltype</span> ( r + <span class="number">0</span> ) b;	<span class="comment">//正确，加法的结果是int，因此b是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span> (*p) c;		<span class="comment">//错误，c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>可以通过给变量名加上括号，让<code>decltype</code>的结果强制变为引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//decltype的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span> ((i)) d;		<span class="comment">//错误，d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span> (i) e;			<span class="comment">//正确，e是一个未初始化的int</span></span><br></pre></td></tr></table></figure>
<h3 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h3>
<p>头文件通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量。</p>
<p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应该与类的名字一样。</p>
<h4 id="头文件保护符header-guard"><a class="markdownIt-Anchor" href="#头文件保护符header-guard"></a> 头文件保护符(header guard)</h4>
<p>头文件保护符依赖于预处理变量。预处理变量有两个状态：已定义和未定义。</p>
<p><strong>#define</strong>指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：<strong>#ifdef</strong>当且仅当“变量已定义”时为真，<strong>#ifndef</strong>当且仅当”变量未定义“时为真。一旦检查结果为真，则执行后续操作直至遇到 <strong>#endif</strong>指令为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line">  	std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="字符串-向量和数组"><a class="markdownIt-Anchor" href="#字符串-向量和数组"></a> 字符串、向量和数组</h2>
<h3 id="命名空间的using声明"><a class="markdownIt-Anchor" href="#命名空间的using声明"></a> 命名空间的using声明</h3>
<p>使用<code>using</code>声明就无须专门的前缀(形如命名空间 : : )也能使用所需的名字，<code>using</code>声明具有以下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> :: name;</span><br></pre></td></tr></table></figure>
<p>每个<code>using</code>声明引入命名空间中的一个成员。</p>
<blockquote>
<p><strong>Tip:</strong> 头文件不应该使用using声明，因为头文件的内容会拷贝到所有引用它的文件中去，可能引发名字冲突。</p>
</blockquote>
<h3 id="标准库类型string"><a class="markdownIt-Anchor" href="#标准库类型string"></a> 标准库类型string</h3>
<p>标准库类型<code>string</code>表示可变长的字符序列，使用<code>string</code>类型必须首先包含<code>string</code>头文件。作为标准库的一部分，<code>string</code>定义在命名空间<code>std</code>中。以下讨论均包含下述代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std :: string;</span><br></pre></td></tr></table></figure>
<h4 id="定义和初始化"><a class="markdownIt-Anchor" href="#定义和初始化"></a> 定义和初始化</h4>
<table>
<thead>
<tr>
<th></th>
<th>初始化string对象的方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s1;</td>
<td>默认初始化，s1是一个空串</td>
</tr>
<tr>
<td>string s2 (s1);</td>
<td>s2是s1的副本</td>
</tr>
<tr>
<td>string s2 = s1;</td>
<td>等价于s2(s1)，s2是s1的副本</td>
</tr>
<tr>
<td>string s3 (“value”);</td>
<td>s3是字面值&quot;value&quot;的副本，除了字面值最后的空字符外</td>
</tr>
<tr>
<td>string s3 = “value”;</td>
<td>等价于s3(“value”)，s3是字面值&quot;value&quot;的副本</td>
</tr>
<tr>
<td>string s4 ( n , ‘c’ );</td>
<td>把s4初始化为连续n个字符c组成的串</td>
</tr>
</tbody>
</table>
<blockquote>
<p>使用等号’=‘初始化一个变量的过程叫<strong>拷贝初始化</strong>，不使用等号’='则叫<strong>直接初始化</strong></p>
</blockquote>
<h4 id="能执行的操作"><a class="markdownIt-Anchor" href="#能执行的操作"></a> 能执行的操作</h4>
<table>
<thead>
<tr>
<th></th>
<th>string的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>os &lt;&lt; s;</td>
<td>将s写到输出流os当中，返回os</td>
</tr>
<tr>
<td>is &gt;&gt; s;</td>
<td>从is中读取字符串赋给s，字符串以空白分割，返回is</td>
</tr>
<tr>
<td>getline ( is , s );</td>
<td>从is中读取一行赋给s，返回is</td>
</tr>
<tr>
<td>s.empty();</td>
<td>s为空返回true，否则返回false</td>
</tr>
<tr>
<td>s.size();</td>
<td>返回s中字符的个数</td>
</tr>
<tr>
<td>s[n];</td>
<td>返回s中第n个字符的引用，位置n从0开始</td>
</tr>
<tr>
<td>s1 + s2;</td>
<td>返回s1和s2连接后的结果</td>
</tr>
<tr>
<td>s1 = s2;</td>
<td>用s2的副本代替s1中原来的字符</td>
</tr>
<tr>
<td>s1 == s2;   s1 != s2;</td>
<td>如果s1和s2中所含的字符完全一样，则它们相等；该判断对大小写敏感</td>
</tr>
<tr>
<td>&lt; , &lt;= , &gt; , &gt;=</td>
<td>利用字典序比较；该判断对大小写敏感</td>
</tr>
</tbody>
</table>
<h5 id="读写未知数量的string对象"><a class="markdownIt-Anchor" href="#读写未知数量的string对象"></a> 读写未知数量的string对象</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> ( cin &gt;&gt; word )&#123;		<span class="comment">//反复读取，直至到达文件末尾</span></span><br><span class="line">	cout &lt;&lt; word &lt;&lt; endl;	<span class="comment">//逐个输出单词，每个单词后面紧跟一个换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当遇见<strong>文件结束标记</strong>或<strong>非法输入</strong>时，循环结束。</p>
<h5 id="使用getline读取一整行"><a class="markdownIt-Anchor" href="#使用getline读取一整行"></a> 使用getline读取一整行</h5>
<p><code>getline</code>函数的参数是一个输入流和一个<code>string</code>对象，函数从给定的输入流中读入内容，直到读入<strong>换行符</strong>，然后把所读的内容存到<code>string</code>对象中去(注意<strong>不存换行符</strong>)。如果一开始就是换行符，则存入的即是空<code>string</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="comment">//每次读入一整行，直至到达文件末尾。</span></span><br><span class="line"><span class="keyword">while</span> ( <span class="built_in">get</span>( cin , line ) )&#123;</span><br><span class="line">	cout &lt;&lt; line &lt;&lt; endl;	<span class="comment">//line不包含换行符，手动加上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和输入运算符相同，<code>getline</code>也会返回它的流参数(可作为判断条件)。</p>
<h5 id="stringsize_type类型"><a class="markdownIt-Anchor" href="#stringsize_type类型"></a> string::size_type类型</h5>
<p><code>size()</code>函数返回一个<code>string::size_type</code>类型的值。它是一个无符号类型的值，而且能足够存放下任何<code>string</code>对象的大小。</p>
<p>假设<strong>n</strong>是一个具有负值的<code>int</code>，则表达式<code>s.size() &lt; n</code>的判断结果较大可能为<strong>true</strong>(不排除false可能)，因为负值<strong>n</strong>会自动地转换成一个比较大的无符号值。</p>
<blockquote>
<p><strong>Tip:</strong> 如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。</p>
</blockquote>
<h5 id="字面值和string对象相加"><a class="markdownIt-Anchor" href="#字面值和string对象相加"></a> 字面值和string对象相加</h5>
<p>两个<code>string</code>对象可以相加得到一个新的<code>string</code>对象，而当字面值和<code>string</code>对象相加时，会自动将字符串字面值类型转换为<code>string</code>类型，但有如下要求：</p>
<p>当把<code>string</code>对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符 ‘<strong>+</strong>’ 的两侧的运算对象至少有一个是<code>string</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">&quot;, &quot;</span>;				<span class="comment">//正确</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span>;			<span class="comment">//错误，都不是string</span></span><br><span class="line">string s6 = s1 + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span>;	<span class="comment">//正确</span></span><br><span class="line">string s7 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span> + s2;	<span class="comment">//错误，不能把字面值直接相加</span></span><br></pre></td></tr></table></figure>
<p><strong>s6</strong>的初始化工作原理和连续输入输出是一样的，可以用如下形式分组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s6 = ( s1 + <span class="string">&quot;, &quot;</span> ) + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="comment">//s1 + &quot;, &quot;的结果是一个string对象，</span></span><br><span class="line"><span class="comment">//同时作为第二个加法运算符的左侧运算对象</span></span><br></pre></td></tr></table></figure>
<p>同理，<strong>s7</strong>的初始化是非法的，按其语义就成了如下分组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s7 = ( <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span> ) + s2;</span><br></pre></td></tr></table></figure>
<p>括号内的子表达式试图将两个字符串字面值加在一起，这是编译器做不到的。</p>
<blockquote>
<p>C++中的字符串字面值并不是标准库类型string的对象。</p>
</blockquote>
<h4 id="处理string对象中的字符"><a class="markdownIt-Anchor" href="#处理string对象中的字符"></a> 处理string对象中的字符</h4>
<p>首先我们要知道目标字符的特性。在<strong>cctype</strong>头文件中定义了一组标准库函数处理这部分工作：</p>
<table>
<thead>
<tr>
<th></th>
<th>cctype头文件中的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalnum ( c )</td>
<td>当c是字母或数字时为真</td>
</tr>
<tr>
<td>isalpha ( c )</td>
<td>当c是字母时为真</td>
</tr>
<tr>
<td>iscntrl ( c )</td>
<td>当c是控制字符时为真</td>
</tr>
<tr>
<td>isdigit ( c )</td>
<td>当c是数字时为真</td>
</tr>
<tr>
<td>isgraph ( c )</td>
<td>当c不是空格但可打印时为真</td>
</tr>
<tr>
<td>islower ( c )</td>
<td>当c是小写字母时为真</td>
</tr>
<tr>
<td>isprint ( c )</td>
<td>当c是可打印字符时为真(空格或可视字符)</td>
</tr>
<tr>
<td>ispunct ( c )</td>
<td>当c是标点符号时为真(不是控制字符、可打印空白、数字、字母)</td>
</tr>
<tr>
<td>isspace ( c )</td>
<td>当c是空白时为真(空格、制表符、回车、换行、进纸)</td>
</tr>
<tr>
<td>isupper ( c )</td>
<td>当c时大写字母时为真</td>
</tr>
<tr>
<td>isxdigit ( c )</td>
<td>当c时十六进制数字时为真</td>
</tr>
<tr>
<td>tolower ( c )</td>
<td>如果c是大写字母则返回对应小写字母；否则原样返回c</td>
</tr>
<tr>
<td>toupper ( c )</td>
<td>如果c是小写字母则返回对应大写字母；否则原样返回c</td>
</tr>
</tbody>
</table>
<blockquote>
<p>cctype头文件和ctype.h头文件的内容是一样的，但cctype中定义的名字从属于命名空间std。</p>
</blockquote>
<h5 id="基于范围的for语句"><a class="markdownIt-Anchor" href="#基于范围的for语句"></a> 基于范围的for语句</h5>
<p>如果想处理每个字符，可以使用C++11新标准提供的<strong>范围for</strong>(range for)语句，这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( declaration : expression )</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>其中，<code>expression</code>部分是一个对象，用于表示一个序列。<code>declaration</code>部分负责定义一个变量，该变量用于访问序列中的基础元素。每次迭代，<code>declaration</code>部分的变量会被初始化为<code>expression</code>部分的下一个元素值。</p>
<p>一个<code>string</code>对象表示一个字符的序列，因此<code>string</code>对象可以作为范围<code>for</code>语句中的<code>expression</code>部分。</p>
<p>例如，统计<code>string</code>对象中标点符号的个数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span> <span class="params">( <span class="string">&quot;Hello world!!!&quot;</span> )</span></span>;</span><br><span class="line"><span class="comment">//punct_cnt的类型和s.size的返回类型一样</span></span><br><span class="line"><span class="keyword">decltype</span>( s.<span class="built_in">size</span>() ) punct_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> c : s )</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">ispunct</span>(c) )</span><br><span class="line">        ++punct_cnt;</span><br></pre></td></tr></table></figure>
<p>如果想改变<code>string</code>对象中字符的值，必须把循环变量定义成引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把字符串改成大写</span></span><br><span class="line"><span class="function">string <span class="title">s</span> <span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; c : s )&#123;</span><br><span class="line">	c = <span class="built_in">toupper</span>(c);</span><br><span class="line">&#125;	<span class="comment">//c是一个引用，因此赋值语句将改变s中字符的值</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只处理部分参数时，使用下标运算符’[]'，接受的输入参数是 <strong>string::size_type</strong> 类型的值(若是带符号类型的值会自动转换)，返回该位置上字符的引用。</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> 避免使用下标访问空string</p>
</blockquote>
<h3 id="标准库类型vector"><a class="markdownIt-Anchor" href="#标准库类型vector"></a> 标准库类型vector</h3>
<p>标准库类型<code>vector</code>表示对象的集合，其中所有对象的类型都相同。</p>
<p>需要包含的头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std :: vector</span><br></pre></td></tr></table></figure>
<p><code>vector</code>是一个类模板。</p>
<p>模板本身不是类或函数，相反可以看作为编译器生成类或函数而编写的一份说明。编译器根据模板创建类或函数的过程成为<strong>实例化(instantiation)</strong>，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p>
<p>以<code>vector</code>为例，提供的额外信息是<code>vector</code>内所存放对象的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;				<span class="comment">//保存int类型的对象</span></span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;	<span class="comment">//保存Sales_vec类型的对象</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; file;	<span class="comment">//保存vector对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于引用不是对象，不存在包含引用的vector</p>
</blockquote>
<blockquote>
<p>在早期的C++版本中如果vector的元素还是vector(或其他模板类型)，必须在外层vector的右尖括号和其元素类型之间添加一个空格，如写成<code>vector&lt;vector&lt;int&gt; &gt;</code></p>
</blockquote>
<h4 id="定义和初始化vector对象"><a class="markdownIt-Anchor" href="#定义和初始化vector对象"></a> 定义和初始化vector对象</h4>
<table>
<thead>
<tr>
<th></th>
<th>初始化vector对象的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector &lt; T &gt; v1</td>
<td>v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</td>
</tr>
<tr>
<td>vector &lt; T &gt; v2 (v1)</td>
<td>v2中包含有v1所有元素的副本</td>
</tr>
<tr>
<td>vector &lt; T &gt; v2 = v1</td>
<td>等价于v2(v1)，v2中包含有v1所有元素的副本</td>
</tr>
<tr>
<td>vector &lt; T &gt; v3 ( n , val)</td>
<td>v3包含了n个重复的元素，每个元素的值都是val</td>
</tr>
<tr>
<td>vector &lt; T &gt; v4 (n)</td>
<td>v4包含了n个重复地执行了值初始化的对象</td>
</tr>
<tr>
<td>vector &lt; T &gt; v5 { a, b, c… }</td>
<td>v5包含了初始值个数的元素，每个元素被赋予相应的初始值</td>
</tr>
<tr>
<td>vector &lt; T &gt; v5 = { a, b, c… }</td>
<td>等价于v5{ a, b, c… }</td>
</tr>
</tbody>
</table>
<blockquote>
<p>列表初始化只能使用花括号，不能使用圆括号。</p>
</blockquote>
<h5 id="值初始化"><a class="markdownIt-Anchor" href="#值初始化"></a> 值初始化</h5>
<p>只提供<code>vector</code>对象容纳的元素数量而略去初始值，此时库会创建一个<strong>值初始化的</strong>(value-initialized)元素初值，并把它赋给容器中所有元素。这个初值由<code>vector</code>对象中的元素类型决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;			<span class="comment">//10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>;		<span class="comment">//10个元素，每个都是空string对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果vector对象中的元素类型不支持默认初始化，则必须提供初始值。</p>
</blockquote>
<h4 id="能执行的操作-2"><a class="markdownIt-Anchor" href="#能执行的操作-2"></a> 能执行的操作</h4>
<table>
<thead>
<tr>
<th></th>
<th>vector支持的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.empty()</td>
<td>如果v不含有任何元素，返回真；否则返回假</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回v中元素的个数</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td>向v的尾端添加一个值为t的元素</td>
</tr>
<tr>
<td>v[n]</td>
<td>返回v中第n个位置上元素的引用</td>
</tr>
<tr>
<td>v1 = v2</td>
<td>用v2中元素的拷贝替换v1中的元素</td>
</tr>
<tr>
<td>v1 = { a, b, c… }</td>
<td>用列表中元素的拷贝替换v1中的元素</td>
</tr>
<tr>
<td>v1 == v2 , v1 != v2</td>
<td>v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值相同</td>
</tr>
<tr>
<td>&lt; , &lt;= , &gt; , &gt;=</td>
<td>以字典顺序进行比较</td>
</tr>
</tbody>
</table>
<blockquote>
<p>size()返回值的类型是由vector定义的size_type类型。</p>
<p>要使用size_type，需首先指定它是由哪种类型定义的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; :: size_type		<span class="comment">//正确</span></span><br><span class="line">vector :: size_type				<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>不能使用<strong>下标形式</strong>添加元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;		<span class="comment">//空vector对象</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix = <span class="number">0</span> ; ix !=<span class="number">10</span> ; ++ix )</span><br><span class="line"> ivec[ix] = ix;		<span class="comment">//严重错误，ivec不包含任何元素</span></span><br></pre></td></tr></table></figure>
<p>正确的方法是使用push_back：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix = <span class="number">0</span> ; ix !=<span class="number">10</span> ; ++ix )</span><br><span class="line"> ivec.<span class="built_in">push_back</span>( ix );		<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> 当使用下标访问一个不存在的元素(越界)时将引发错误，所谓的<strong>缓冲区溢出</strong>(buffer overflow)指的就是这类错误。</p>
</blockquote>
<h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3>
<p>所有标准库容器都可以使用<strong>迭代器(iterator)</strong>，但只有少数几种才支持下标运算符。迭代器类似于指针类型，提供了对对象的间接访问。</p>
<p>迭代器有有效和无效之分，有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其它所有情况都属于无效。</p>
<h4 id="使用迭代器"><a class="markdownIt-Anchor" href="#使用迭代器"></a> 使用迭代器</h4>
<p>与指针不同的是，获取迭代器不是使用取地址符，且拥有迭代器的类型同时拥有返回迭代器的成员。<strong>begin</strong>成员负责返回指向第一个元素(或第一个字符)的迭代器，<strong>end</strong>成员负责返回指向容器(或<code>string</code>对象)“<strong>尾元素的下一位置</strong>(one past the end)”的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由编译器决定b和e的类型；</span></span><br><span class="line"><span class="comment">//b表示第一个元素，e表示v尾元素的下一位置</span></span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>() , e = v.<span class="built_in">end</span>();	<span class="comment">//b和e的类型相同</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>end成员返回的迭代器常被称为<strong>尾后迭代器(off-the-end iterator)<strong>或简称</strong>尾迭代器(end iterator)</strong>。特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。</p>
</blockquote>
<h4 id="迭代器运算符"><a class="markdownIt-Anchor" href="#迭代器运算符"></a> 迭代器运算符</h4>
<table>
<thead>
<tr>
<th></th>
<th>标准容器迭代器的运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>返回迭代器iter所指元素的引用</td>
</tr>
<tr>
<td>iter-&gt;mem</td>
<td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>令iter指示容器中的下一个元素</td>
</tr>
<tr>
<td>–iter</td>
<td>令iter指示容器中的上一个元素</td>
</tr>
<tr>
<td>iter1 == iter2 , iter1 != iter2</td>
<td>判断两个迭代器是否相等(不相等)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。</p>
</blockquote>
<blockquote>
<p>试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> C++程序员在for循环中更愿意使用 <strong>!=</strong> 而非 <strong>&lt;</strong> ，更愿意使用迭代器而非下标，因为这种编程风格在标准库提供的所有容器上都有效。</p>
</blockquote>
<h4 id="迭代器类型"><a class="markdownIt-Anchor" href="#迭代器类型"></a> 迭代器类型</h4>
<p>就像不知道<code>string</code>和<code>vector</code>的<code>size_type</code>成员到底是什么类型一样，一般来说我们也不知道(其实也无须知道)迭代器的精确类型。</p>
<p>实际上，那些拥有迭代器的标准库类型使用<strong>iterator</strong>和<strong>const_iterator</strong>来表示迭代器的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;			<span class="comment">//it能读写vector&lt;int&gt;中的元素</span></span><br><span class="line">string::iterator it2;				<span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;	<span class="comment">//it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4;			<span class="comment">//it4只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>
<p>如果<code>vector</code>对象或<code>string</code>对象是一个常量，只能使用<code>const_iterator</code>；如果<code>vector</code>对象或<code>string</code>对象不是常量，那么既可以使用<code>iterator</code>也能使用<code>const_iterator</code>。</p>
<blockquote>
<p>begin和end返回的具体类型由对象是否是常量决定：如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator。</p>
</blockquote>
<p>为了便于专门得到<code>const_iterator</code>类型的返回值，C++11新标准引入了两个新函数，分别是<strong>cbegin</strong>和<strong>cend</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();	<span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<h4 id="解引用和成员访问操作"><a class="markdownIt-Anchor" href="#解引用和成员访问操作"></a> 解引用和成员访问操作</h4>
<p>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就可能希望进一步访问它的成员。但是必须注意加圆括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*it).<span class="built_in">empty</span>();		<span class="comment">//解引用it，然后调用结果对象的empty成员</span></span><br><span class="line">*it.<span class="built_in">empty</span>();		<span class="comment">//错误，试图访问it的名为empty的成员，但it是个迭代器，没有empty成员</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用箭头运算符 <strong>-&gt;</strong> 简化上述表达式，箭头运算符把解引用和成员访问两个操作结合在一起，即<code>it-&gt;mem</code>和<code>(*it).mem</code>表达的意思相同。</p>
<blockquote>
<p><strong>Tip:</strong> 任何往容器中添加元素的操作，都可能使其相应的迭代器失效。故但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p>
</blockquote>
<h4 id="迭代器运算"><a class="markdownIt-Anchor" href="#迭代器运算"></a> 迭代器运算</h4>
<p>迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都有支持递增运算的迭代器。类似的，也能用 <strong>==</strong> 和 <strong>!=</strong> 对任意标准库类型的两个有效迭代器进行比较。</p>
<p><code>string</code>和<code>vector</code>的迭代器提供了更多额外的运算符，使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称为<strong>迭代器运算</strong>(iterator arithmetic)，其细节由下表列出：</p>
<table>
<thead>
<tr>
<th></th>
<th>vector和string迭代器支持的运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n</td>
<td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一个位置。</td>
</tr>
<tr>
<td>iter - n</td>
<td>迭代器减去一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。</td>
</tr>
<tr>
<td>iter1 += n</td>
<td>迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1。</td>
</tr>
<tr>
<td>iter1 -= n</td>
<td>迭代器减法的复合赋值语句，将iter1减n的结果赋给iter1。</td>
</tr>
<tr>
<td>iter1 - iter2</td>
<td>两个迭代器相减的结果是它们的<strong>距离</strong>，参与运算的两个迭代器必须来自同一个容器。</td>
</tr>
<tr>
<td>&gt; 、 &gt;= 、 &lt; 、 &lt;=</td>
<td>迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>上述<strong>距离</strong>的类型名为difference_type的带符号整数，string和vector都定义了difference_type。</p>
</blockquote>
<h5 id="使用迭代器完成二分搜索"><a class="markdownIt-Anchor" href="#使用迭代器完成二分搜索"></a> 使用迭代器完成二分搜索</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//text必须是有序的</span></span><br><span class="line"><span class="comment">//beg和end表示我们搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>() , end = text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span>() + ( end - begin ) / <span class="number">2</span>;	<span class="comment">//初始状态下的中间点</span></span><br><span class="line"><span class="comment">//当还有元素尚未检查并且我们还没有找到sought时执行循环</span></span><br><span class="line"><span class="keyword">while</span> ( mid != end &amp;&amp; *mid != sought ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sought &lt; *mid )		<span class="comment">//我们要找的元素在前半部分？</span></span><br><span class="line">        end = mid;				<span class="comment">//忽略mid后半部分</span></span><br><span class="line">    <span class="keyword">else</span>						<span class="comment">//我们要找的元素在后半部分</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;			<span class="comment">//在mid之后寻找</span></span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;	<span class="comment">//新的中间点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环过程终止时，<code>mid</code>或者等于<code>end</code>或者等于要找的元素。如果<code>mid</code>等于<code>end</code>，说明<code>text</code>中没有我们要找的元素。</p>
<h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3>
<h4 id="定义和初始化内置数组"><a class="markdownIt-Anchor" href="#定义和初始化内置数组"></a> 定义和初始化内置数组</h4>
<p>数组是一种<strong>复合类型</strong>。数组的声明形如 <strong>a[d]</strong> ，其中<strong>a</strong>是数组的名字，<strong>d</strong>是数组的维度。维度说明了数组中元素的个数，因此必须大于0。数组元素的个数也属于数组类型的一部分，编译的时候维度应该是<strong>已知</strong>的。也就是说，维度必须是一个<strong>常量表达式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>;				<span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>;		<span class="comment">//常量表达式</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];					<span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *parr[sz];					<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line">string bad[cnt];				<span class="comment">//错误，cnt不是常量表达式</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()];		<span class="comment">//当get_siz是constexpr时正确；否则错误</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，数组的元素被默认初始化。</p>
<blockquote>
<p>定义数组的时候必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型。另外与vector一样，数组的元素应为对象，因此不存在引用的数组。</p>
</blockquote>
<h5 id="字符数组的特殊性"><a class="markdownIt-Anchor" href="#字符数组的特殊性"></a> 字符数组的特殊性</h5>
<p>字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式进行初始化时，要注意字符串字面值的结尾处还有一个空字符，这个空字符也会被字符数组中去：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123; <span class="string">&#x27;C&#x27;</span> , <span class="string">&#x27;+&#x27;</span> , <span class="string">&#x27;+&#x27;</span> &#125;;		<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="type">char</span> a2[] = &#123; <span class="string">&#x27;C&#x27;</span> , <span class="string">&#x27;+&#x27;</span> , <span class="string">&#x27;+&#x27;</span> , <span class="string">&#x27;\0&#x27;</span> &#125;;	<span class="comment">//列表初始化，含有显示的空字符</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span>;						<span class="comment">//自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[] = <span class="string">&quot;Daniel&quot;</span>;				<span class="comment">//错误，没有空间存放空字符</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> 按理来讲，数组a4的定义是错误的，但<strong>Luv</strong>实测竟然是可行的(不会报错)，且使用sizeof(a4)得到的值是7，可能是编译器原因。</p>
</blockquote>
<h5 id="不允许拷贝和赋值"><a class="markdownIt-Anchor" href="#不允许拷贝和赋值"></a> 不允许拷贝和赋值</h5>
<p>不能将数组的内容拷贝给其他数组做初始值，也不能用数组为其他数组赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> &#125;;		<span class="comment">//含有3个整数的数组</span></span><br><span class="line"><span class="type">int</span> a2[] = a;					<span class="comment">//错误，不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a;							<span class="comment">//错误，不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有些编译器支持数组的赋值，这就是所谓的<strong>编译器扩展(compiler extension)</strong>。但最好避免使用这些非标准特性。</p>
</blockquote>
<h5 id="理解复杂的数组声明"><a class="markdownIt-Anchor" href="#理解复杂的数组声明"></a> 理解复杂的数组声明</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];					<span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ? */</span>;		<span class="comment">//错误，不存在引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray) [<span class="number">10</span>] = &amp;arr;		<span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef) [<span class="number">10</span>] = arr;		<span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<h4 id="访问数组元素"><a class="markdownIt-Anchor" href="#访问数组元素"></a> 访问数组元素</h4>
<p>在使用数组下标时，通常将其定义为<strong>size_t</strong>类型。<strong>size_t</strong>是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在<strong>cstddef</strong>头文件中定义了<strong>size_t</strong>类型，这个文件是C标准库<strong>stddef.h</strong>头文件的C++语言版本。</p>
<h4 id="数组和指针"><a class="markdownIt-Anchor" href="#数组和指针"></a> 数组和指针</h4>
<p>使用数组时编译器一般会把它转换成指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string nums[] = &#123; <span class="string">&quot;one&quot;</span> , <span class="string">&quot;two&quot;</span> , <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line">string *p = nums;		<span class="comment">//等价于 p = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>
<p>当使用数组作为<strong>auto</strong>变量的初始值时，推断得到的类型是指针而非数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;	<span class="comment">//ia是一个含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;		<span class="comment">//ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line">ia2 = <span class="number">42</span>;			<span class="comment">//错误，ia2是一个指针，不能用int值给指针赋值</span></span><br></pre></td></tr></table></figure>
<p>但是，当使用<strong>decltype</strong>关键字时，上述转换不会发生，<code>decltype(ia)</code>返回的类型时由<strong>10</strong>个整数构成的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ia3是一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">ia3 = p;			<span class="comment">//错误，不能用整形指针给数组赋值</span></span><br><span class="line">ia3[<span class="number">4</span>] = i;			<span class="comment">//正确，把i的值赋给ia3的一个元素</span></span><br></pre></td></tr></table></figure>
<h5 id="指针也是迭代器"><a class="markdownIt-Anchor" href="#指针也是迭代器"></a> 指针也是迭代器</h5>
<p><code>vector</code>和<code>string</code>的迭代器支持的运算，数组的指针全都支持。可以通过数组名字或者数组中首元素的地址都能得到指向首元素的指针；不过获取<strong>尾后指针</strong>就要用到数组的另外一个特殊性质了：设法获取数组尾元素之后的那个并不存在的元素的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;			<span class="comment">//p指向arr的第一个元素</span></span><br><span class="line"><span class="type">int</span> *e = &amp;arr[<span class="number">10</span>];		<span class="comment">//e指向arr尾元素的下一位置的指针</span></span><br></pre></td></tr></table></figure>
<p>利用上面的指针输出<code>arr</code>的全部元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> *b = arr ; b != e ; ++b )&#123;</span><br><span class="line">    cout &lt;&lt; *b &lt;&lt; endl;		<span class="comment">//输出arr元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="标准库函数begin和end"><a class="markdownIt-Anchor" href="#标准库函数begin和end"></a> 标准库函数begin和end</h5>
<p>尽管能通过以上方法获得尾后指针，但这种用法极易出错。</p>
<p>C++11新标准引入了两个名为<strong>begin</strong>和<strong>end</strong>函数，功能与容器中的同名成员类似。不过数组并不是类类型，因此正确的使用形式是将数组作为它们的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">begin</span>(ia);		<span class="comment">//指向ia首元素的指针</span></span><br><span class="line"><span class="type">int</span> *last = <span class="built_in">end</span>(ia);		<span class="comment">//指向arr尾元素的下一位置的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>begin</strong>函数返回指向<code>ia</code>首元素的指针，<strong>end</strong>函数返回指向<code>ia</code>尾元素下一位置的指针，这两个函数定义在<strong>iterator</strong>头文件中。</p>
<h5 id="指针运算"><a class="markdownIt-Anchor" href="#指针运算"></a> 指针运算</h5>
<p>和迭代器一样，两个指针相减的结果是它们之间的<strong>距离</strong>。参与运算的两个指针必须指向同一个数组当中的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="built_in">end</span>(arr) - <span class="built_in">begin</span>(arr);	<span class="comment">//n的值就是arr中元素的数量</span></span><br></pre></td></tr></table></figure>
<p>两个指针相减的结果的类型是一种名为<strong>ptrdiff_t</strong>的标准库类型，和<strong>size_t</strong>一样，<strong>ptrdiff_t</strong>也是定义在<code>cstddef</code>头文件中的机器相关的类型。因为差值可能为负数，所以<strong>ptrdiff_t</strong>是一种带符号类型。</p>
<blockquote>
<p><strong>Tip:</strong> 数组使用的下标运算符 <strong>[]</strong> 是“<strong>内置</strong>”的，与<code>vector</code>和<code>string</code>不同，所用的索引值可以为负值，例如 <code>p[-2] = *(p-2)</code>，当该指针<strong>p</strong>指向的是数组元素(或尾元素下一位置)时均为合法的。</p>
</blockquote>
<h4 id="c风格字符串"><a class="markdownIt-Anchor" href="#c风格字符串"></a> C风格字符串</h4>
<blockquote>
<p><strong>Tip</strong>: 尽管 C++ 支持C风格字符串，但在 C++ 程序中最好不要使用它们。这是因为C风格字符串不仅使用起来极不方便，而且极易引发程序漏洞，是诸多安全问题的根本问题。</p>
</blockquote>
<p>字符串字面值是一种通用结构的示例，这种结构即是C++由C继承而来的<strong>C风格字符串(C-style character string)</strong>。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以<strong>空字符结束(null terminated)</strong>。</p>
<h5 id="c标准库stirng函数"><a class="markdownIt-Anchor" href="#c标准库stirng函数"></a> C标准库Stirng函数</h5>
<p>以下为C语言标准库提供的一组函数，定义在<strong>cstring</strong>头文件中，是C语言头文件<strong>string.h</strong>的C++版本。</p>
<table>
<thead>
<tr>
<th></th>
<th>C风格字符串的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>strlen ( p )</td>
<td>返回p的长度，空字符不计算在内</td>
</tr>
<tr>
<td>strcmp ( p1 , p2 )</td>
<td>比较p1和p2的相等性，如果p1==p2返回0；如果p1&gt;p2返回一个正值；如果p1&lt;p2返回一个负值</td>
</tr>
<tr>
<td>strcat ( p1 , p2 )</td>
<td>将p2附加到p1之后，返回p1</td>
</tr>
<tr>
<td>strcpy ( p1 , p2 )</td>
<td>将p2拷贝给p1，返回p1</td>
</tr>
</tbody>
</table>
<p>传入此类函数的指针必须指向以空字符结束的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[] = &#123; <span class="string">&#x27;C&#x27;</span> , <span class="string">&#x27;+&#x27;</span> , <span class="string">&#x27;+&#x27;</span> &#125;;	<span class="comment">//不以空字符结束</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; endl;			<span class="comment">//严重错误，ca没有以空字符结束</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当想使用strcmp和strcat函数时，需要预先估计用于存放结果的数组所需的空间大小，这导致这类代码充满了风险而且经常导致严重的安全泄漏。</p>
</blockquote>
<h5 id="比较字符串"><a class="markdownIt-Anchor" href="#比较字符串"></a> 比较字符串</h5>
<p>把关系运算符和相等性运算符用在C风格字符串上，实际比较的是指针而非字符串本身：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> ca1[] = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ca2[] = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( ca1 &lt; ca2 )		<span class="comment">//未定义：试图比较两个无关的地址</span></span><br></pre></td></tr></table></figure>
<p>要想比较两个C风格字符串必须调用<strong>strcmp</strong>函数。</p>
<h4 id="与旧代码的接口"><a class="markdownIt-Anchor" href="#与旧代码的接口"></a> 与旧代码的接口</h4>
<p>很多 C++ 程序在标准库出现之前就已经写成了，它们肯定没用到<code>string</code>和<code>vector</code>类型。而且，有一些 C++ 程序实际上是与C语言或其他语言的接口程序，当然也无法使用 C++ 标准库。因此，现代的 C++ 程序不得不与那些充满了数组和C风格字符串的代码衔接。</p>
<p>为了使这一工作简单易行，C++专门提供了一组功能。</p>
<h5 id="混用string对象和c风格字符串"><a class="markdownIt-Anchor" href="#混用string对象和c风格字符串"></a> 混用string对象和C风格字符串</h5>
<p>前面介绍过可以用字符串字面值来初始化<code>string</code>对象。</p>
<p>任何出现字符串字面值的地方都可以用以空字符结尾的字符数组来替代：</p>
<ul>
<li>允许使用以空字符结束的字符数组来初始化<code>string</code>对象或为<code>string</code>对象赋值。</li>
<li>在<code>string</code>对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象(不能两个运算对象都是)；在<code>string</code>对象的复合运算中，允许使用以空字符结束的字符数组作为右侧的运算对象。</li>
</ul>
<p>但是上述性质不能反过来使用，例如不能用<code>string</code>对象直接初始化指向字符的指针。为了完成该功能，<code>string</code>专门提供了一个名为<strong>c_str</strong>的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = s;		<span class="comment">//错误，不能用string对象初始化char*</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>();	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><code>c_str</code>函数的返回值是一个C风格字符串，即一个指针，该指针指向一个以空字符结束的字符数组，数组所存数据与<code>string</code>对象一样。结果指针的类型为<strong>const char</strong>*，从而确保我们不会改变字符数组的内容。</p>
<blockquote>
<p><strong>Tip:</strong> 当s值变化时c_str返回的数组可能<strong>失效</strong>，所以如果想一直使用其返回的数组，最好使用strcpy函数将该数组重新拷贝一份。</p>
</blockquote>
<h5 id="用数组初始化vector对象"><a class="markdownIt-Anchor" href="#用数组初始化vector对象"></a> 用数组初始化vector对象</h5>
<p>允许使用数组初始化<code>vector</code>对象，只需指明要拷贝区域的首元素地址和尾后地址即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr [] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//ivec有6个元素，分别是int_arr中对应元素的副本</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span> <span class="params">( begin(int_arr) , end(int_arr) )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，使用标准库函数<code>begin</code>和<code>end</code>来分别计算<code>int_arr</code>的首指针和尾后指针。</p>
<p>也可以只拷贝部分元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝3个元素：int_arr[1]、int_arr[2]、int_arr[3]</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subVec</span> <span class="params">( int_arr + <span class="number">1</span> , int_arr + <span class="number">4</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4>
<h5 id="初始化-2"><a class="markdownIt-Anchor" href="#初始化-2"></a> 初始化</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;			<span class="comment">//三个元素，每个元素都是大小为4的数组</span></span><br><span class="line">    &#123; <span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> &#125;,		<span class="comment">//第1行的初始值</span></span><br><span class="line">    &#123; <span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> , <span class="number">7</span> &#125;,		<span class="comment">//第2行的初始值</span></span><br><span class="line">    &#123; <span class="number">8</span> , <span class="number">9</span> , <span class="number">10</span> , <span class="number">11</span> &#125;,	<span class="comment">//第3行的初始值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内嵌的花括号不是必须的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有标识每行的花括号，与之前的初始化语句是等价的</span></span><br><span class="line"><span class="type">int</span> ia [<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure>
<p>未列出的元素执行默认初始化:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式地初始化每行的首元素</span></span><br><span class="line"><span class="type">int</span> ia [<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123; <span class="number">0</span> &#125; , &#123; <span class="number">4</span> &#125; , &#123; <span class="number">8</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用范围for语句处理多维数组"><a class="markdownIt-Anchor" href="#使用范围for语句处理多维数组"></a> 使用范围for语句处理多维数组</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> rowCnt = <span class="number">3</span> , colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> ia[rowCnt][colCnt];			<span class="comment">//12个未初始化的元素</span></span><br><span class="line"><span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;row : ia )			<span class="comment">//对于外层数组的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> &amp;col : row ) &#123;	<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">        col = cnt;				<span class="comment">//将下一个值赋给该元素</span></span><br><span class="line">        ++cnt;					<span class="comment">//将 cnt 加 1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用范围<code>for</code>语句把管理数组索引的任务交给了系统来完成。因为要改变元素的值，所以得把控制变量<code>row</code>和<code>col</code>声明成引用类型。</p>
<p>但实际还有更深层的原因，举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia )	<span class="comment">//对于外层数组的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> col : row )		<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">        cout &lt;&lt; col &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>这个循环中并没有任何读写操作，还是将外层循环的控制变量声明成了引用类型，这是为了<strong>避免</strong>数组被自动转换成指针。假设采取如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> row : ia )</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> col : row )</span><br></pre></td></tr></table></figure>
<p>程序将无法通过编译。因为编译器会在初始化<code>row</code>时自动将这些数组形式的元素转换成指向该数组内首元素的指针，这样得到的<code>row</code>的类型就是<strong>int</strong>*，此时内层循环就不合法了。</p>
<blockquote>
<p><strong>Tip:</strong> 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</p>
</blockquote>
<h5 id="指针和多维数组"><a class="markdownIt-Anchor" href="#指针和多维数组"></a> 指针和多维数组</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> p = ia ; p != ia + <span class="number">3</span> ; ++p ) &#123;</span><br><span class="line">    <span class="comment">//q指向4个整数数组的首元素，也就是说，q指向一个整数</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> q = *p ; q != *p + <span class="number">4</span> ; ++q )</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用标准库函数begin和end实现相同功能。</p>
</blockquote>
<h5 id="类型别名简化多维数组的指针"><a class="markdownIt-Anchor" href="#类型别名简化多维数组的指针"></a> 类型别名简化多维数组的指针</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">4</span>];	<span class="comment">//新标准下类型别名的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int_array[<span class="number">4</span>];	<span class="comment">//等价的typedef声明</span></span><br><span class="line"><span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="keyword">for</span> ( int_array *p = <span class="built_in">begin</span>(ia) ; p != <span class="built_in">end</span>(ia) ; ++p ) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> *q = <span class="built_in">begin</span>(*p) ; q != <span class="built_in">end</span>(*p) ; ++q )</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序将“<strong>4个整数组成的数组</strong>”命名为<code>int_array</code>，用类型名<code>int_array</code>定义外层循环的控制变量让程序显得简洁明了。</p>
<h2 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h2>
<h3 id="命令行编译"><a class="markdownIt-Anchor" href="#命令行编译"></a> 命令行编译</h3>
<p>从命令行运行编译器：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ CC prog1.cc</span><br><span class="line">CC 是编译器程序名字</span><br><span class="line">$ 是系统提示符</span><br></pre></td></tr></table></figure>
<p>通过<code>echo</code>命令获得某个程序的返回值</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $?							//UNIX系统</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">%ERRORLEVEL%</span>					//Windows系统</span><br></pre></td></tr></table></figure>
<p>运行<strong>GNU</strong>编译器的g++命令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o prog1 prog1.cc</span><br><span class="line">-o prog1 为编译器参数</span><br></pre></td></tr></table></figure>
<h4 id="编译器检查出的错误"><a class="markdownIt-Anchor" href="#编译器检查出的错误"></a> 编译器检查出的错误</h4>
<table>
<thead>
<tr>
<th>语法错误</th>
<th>syntax error</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型错误</td>
<td>type error</td>
</tr>
<tr>
<td>声明错误</td>
<td>declaration error</td>
</tr>
</tbody>
</table>
<h3 id="iostream"><a class="markdownIt-Anchor" href="#iostream"></a> iostream</h3>
<p><code>iostream</code>包含<code>istream</code>和<code>ostream</code>。</p>
<p>“<strong>stream</strong>” —— <strong>流</strong></p>
<p><strong>istream: cin(标准输入)</strong></p>
<p><strong>ostream: cout(标准输出) , cerr , clog</strong></p>
<p><code>cerr</code>: <strong>标准错误</strong>；输出警告和错误消息。</p>
<p><code>clog</code>: 输出程序运行时一般性信息。</p>
<p><code>endl</code>: <strong>操纵符</strong>；结束当前行，并将缓冲区(buffer)的内容刷到设备中。</p>
<h4 id="读取数量不定的输入数据"><a class="markdownIt-Anchor" href="#读取数量不定的输入数据"></a> 读取数量不定的输入数据</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while( std::cin &gt;&gt; value )&#123;</span><br><span class="line">	sum += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>istream</code>对象作为条件可以检测流，通常情况有效，遇到<strong>文件结束符EOF</strong>或<strong>无效输入</strong>时，<code>istream</code>状态变为无效，使条件变为假。</p>
<blockquote>
<p><strong>从键盘输入文件结束符：</strong></p>
<p>Windows系统：敲Ctrl+Z，然后按Enter或Return键</p>
<p>UNIX或Mac OS X系统：敲Ctrl+D</p>
</blockquote>
<h2 id="相关名词解释"><a class="markdownIt-Anchor" href="#相关名词解释"></a> 相关名词解释</h2>
<h3 id="unicode字符-和-utf-8"><a class="markdownIt-Anchor" href="#unicode字符-和-utf-8"></a> Unicode字符 和 UTF-8</h3>
<blockquote>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jolin678/article/details/120143320">https://blog.csdn.net/jolin678/article/details/120143320</a></p>
</blockquote>
</blockquote>
<p>Unicode的学名是&quot;Universal Multiple-Octet Coded Character Set&quot;，简称为<strong>UCS</strong>，也叫统一码、万国码、单一码。</p>
<p>Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了<strong>统一并且唯一</strong>的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>
<p>虽然我们经常说unicode编码，但<strong>它其实不是一种常规意义上的编码，我认为叫作“编号”更准确</strong>，unicode给每个字符都定义了一个不会重复的编号，例如：</p>
<p><strong>“汉”对应的编号是0x6C49</strong>。</p>
<p>早期的Unicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。</p>
<blockquote>
<p>那么unicode既然不是一种编码，那编码是什么，我认为编码是一种和计算机通话的规则。例如上面的“汉”字的unicode编号是0x6C49，假设现在有1种编码叫MyUtf，MyUtf会按照它自己的规则把0x6C49的二进制进行一些变换，假设变换成了0x55AA，然后只要告诉计算机当前有个字符用MyUtf来编码的，编码后的值是0x55AA，那么计算机就自动会按照MyUtf的规则进行逆运算，得到0x6C49，并正确的显示一个“汉”字。同样地不管是UTF-8,UTF-16,UTF-32，只要是对UNICODE字符进行编码，那实际上就是对这个编号进行编码，由于编号是固定的，所以不管编码规则如何编号，只要计算机最后能知道你这个编号对应的是UNICODE编号的哪一个就行了，根据编号计算机就能正确的显示出对应的字符，这正是UNICODE标准的意义。</p>
</blockquote>
<p>“汉”字的Unicode编码是0x6C49，将0x6C49写成二进制是： 0110 1100 0100 1001。</p>
<p>采用UTF-8的编码规则编码后为：1110 0110 1011 0001 0100 1001，即0xE6B189。</p>
<p><strong>那么我们能说UTF-8是UNICODE吗？</strong></p>
<p><strong>当然不能了。</strong></p>
<p>UTF-8 是使用互联网上使用<strong>最广泛的 unicode 编码方式</strong>，目前已经占有整个互联网 92% 的份额。这里再强调下 UTF-8 只是 Unicode 的一种实现方式，<strong>UTF-8 是编码方式，而 Unicode 是字符集合</strong>。UTF-8它是可变长的编码方式，长度从 1 个字节到 4 个字节不等。它能够完全兼容 ASCII 码，我们知道 ASCII 码 是由 128 个字符组成的，而 <strong>Unicode 中的前 128 个字符和 ASCII 码都是对应的</strong>。</p>
<p>Visual Studio编程使用的默认编码是<strong>GB2312</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luvreadunion.com/2024/03/02/%E6%83%8A%E5%8F%9842%E5%A4%A9-C++-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8/" data-id="cmbxk3yft0003hg9q5rpt2f55" data-title="惊变42天: Week 1 潜龙勿用" class="article-share-link">分享</a>
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%83%8A%E5%8F%9842%E5%A4%A9-C/" rel="tag">惊变42天:C++</a></li></ul>


    </footer>
  </div>
  
    
  <nav id="article-nav" class="wow fadeInUp">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          <img data-src="/images/50172085.avif" data-sizes="auto" alt="我希望你快乐" class="lazyload">
        
        <a href="/2024/03/03/Luv%E7%9A%84%E9%9A%8F%E7%AC%94%EF%BC%9A%E6%88%91%E5%B8%8C%E6%9C%9B%E4%BD%A0%E5%BF%AB%E4%B9%90/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            我希望你快乐
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        <img data-src="/images/64304742.webp" data-sizes="auto" alt="鼓起勇气，告白" class="lazyload">
      
      <a href="/2024/02/26/%E9%BC%93%E8%B5%B7%E5%8B%87%E6%B0%94%EF%BC%8C%E5%91%8A%E7%99%BD/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          鼓起勇气，告白
        
      </h3>
    </div>
    
  </nav>


  
</article>






</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrap wow fadeInRight wrap-sticky">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%9C%BA%E7%99%BD"><span class="toc-number">1.</span> <span class="toc-text"> 开场白</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-1-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text"> Week 1: 潜龙勿用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 类型转换易错点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 转义序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">2.1.2.1.</span> <span class="toc-text"> 泛化转义序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E9%9D%A2%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 指定字面值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.5.</span> <span class="toc-text"> 声明和定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E7%AC%A6%E5%AE%9A%E4%B9%89%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-number">2.1.5.1.</span> <span class="toc-text"> 标志符定义易错点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.5.2.</span> <span class="toc-text"> 变量命名规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8Bcompound-type"><span class="toc-number">2.1.6.</span> <span class="toc-text"> 复合类型(compound type)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.6.1.</span> <span class="toc-text"> 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.1.6.2.</span> <span class="toc-text"> 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88null-pointer"><span class="toc-number">2.1.6.2.1.</span> <span class="toc-text"> 空指针(null pointer)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88"><span class="toc-number">2.1.6.2.2.</span> <span class="toc-text"> void* 指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.6.2.3.</span> <span class="toc-text"> 指向指针的引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">2.1.7.</span> <span class="toc-text"> const限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.7.1.</span> <span class="toc-text"> const的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E4%BE%8B"><span class="toc-number">2.1.7.1.1.</span> <span class="toc-text"> 特例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9const%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%AF%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%B9%B6%E9%9D%9Econst%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.7.1.2.</span> <span class="toc-text"> 对const的引用可能引用一个并非const的对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88pointer-to-const"><span class="toc-number">2.1.7.2.</span> <span class="toc-text"> 指向常量的指针(pointer to const)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88const-pointer"><span class="toc-number">2.1.7.3.</span> <span class="toc-text"> 常量指针(const pointer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const"><span class="toc-number">2.1.7.4.</span> <span class="toc-text"> 顶层const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8Fconst-expression%E5%92%8Cconstexpr"><span class="toc-number">2.1.7.5.</span> <span class="toc-text"> 常量表达式(const expression)和constexpr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.1.8.</span> <span class="toc-text"> 类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88-%E5%B8%B8%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.1.8.1.</span> <span class="toc-text"> 指针、常量和类型别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">2.1.9.</span> <span class="toc-text"> auto类型说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-%E5%B8%B8%E9%87%8F%E5%92%8Cauto"><span class="toc-number">2.1.9.1.</span> <span class="toc-text"> 复合类型、常量和auto</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">2.1.10.</span> <span class="toc-text"> decltype类型指示符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.10.1.</span> <span class="toc-text"> decltype和引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.11.</span> <span class="toc-text"> 头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E7%AC%A6header-guard"><span class="toc-number">2.1.11.1.</span> <span class="toc-text"> 头文件保护符(header guard)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text"> 字符串、向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 命名空间的using声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 标准库类型string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.2.1.</span> <span class="toc-text"> 定义和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.2.2.</span> <span class="toc-text"> 能执行的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%9C%AA%E7%9F%A5%E6%95%B0%E9%87%8F%E7%9A%84string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.2.2.1.</span> <span class="toc-text"> 读写未知数量的string对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8getline%E8%AF%BB%E5%8F%96%E4%B8%80%E6%95%B4%E8%A1%8C"><span class="toc-number">2.2.2.2.2.</span> <span class="toc-text"> 使用getline读取一整行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stringsize_type%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.2.3.</span> <span class="toc-text"> string::size_type类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8Cstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.2.2.2.4.</span> <span class="toc-text"> 字面值和string对象相加</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">2.2.2.3.</span> <span class="toc-text"> 处理string对象中的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.2.3.1.</span> <span class="toc-text"> 基于范围的for语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 标准库类型vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.3.1.</span> <span class="toc-text"> 定义和初始化vector对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.3.1.1.</span> <span class="toc-text"> 值初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C-2"><span class="toc-number">2.2.3.2.</span> <span class="toc-text"> 能执行的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.4.1.</span> <span class="toc-text"> 使用迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.4.2.</span> <span class="toc-text"> 迭代器运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.4.3.</span> <span class="toc-text"> 迭代器类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.4.</span> <span class="toc-text"> 解引用和成员访问操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.4.5.</span> <span class="toc-text"> 迭代器运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%8C%E6%88%90%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">2.2.4.5.1.</span> <span class="toc-text"> 使用迭代器完成二分搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.</span> <span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.1.</span> <span class="toc-text"> 定义和初始化内置数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">2.2.5.1.1.</span> <span class="toc-text"> 字符数组的特殊性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">2.2.5.1.2.</span> <span class="toc-text"> 不允许拷贝和赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.5.1.3.</span> <span class="toc-text"> 理解复杂的数组声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.5.2.</span> <span class="toc-text"> 访问数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.2.5.3.</span> <span class="toc-text"> 数组和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B9%9F%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.5.3.1.</span> <span class="toc-text"> 指针也是迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0begin%E5%92%8Cend"><span class="toc-number">2.2.5.3.2.</span> <span class="toc-text"> 标准库函数begin和end</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.5.3.3.</span> <span class="toc-text"> 指针运算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.5.4.</span> <span class="toc-text"> C风格字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#c%E6%A0%87%E5%87%86%E5%BA%93stirng%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.5.4.1.</span> <span class="toc-text"> C标准库Stirng函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.5.4.2.</span> <span class="toc-text"> 比较字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.5.5.</span> <span class="toc-text"> 与旧代码的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E7%94%A8string%E5%AF%B9%E8%B1%A1%E5%92%8Cc%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.5.5.1.</span> <span class="toc-text"> 混用string对象和C风格字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.5.5.2.</span> <span class="toc-text"> 用数组初始化vector对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.6.</span> <span class="toc-text"> 多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">2.2.5.6.1.</span> <span class="toc-text"> 初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.6.2.</span> <span class="toc-text"> 使用范围for语句处理多维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.6.3.</span> <span class="toc-text"> 指针和多维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.2.5.6.4.</span> <span class="toc-text"> 类型别名简化多维数组的指针</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">2.3.</span> <span class="toc-text"> 杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 命令行编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%A3%80%E6%9F%A5%E5%87%BA%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">2.3.1.1.</span> <span class="toc-text"> 编译器检查出的错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iostream"><span class="toc-number">2.3.2.</span> <span class="toc-text"> iostream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E9%87%8F%E4%B8%8D%E5%AE%9A%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.2.1.</span> <span class="toc-text"> 读取数量不定的输入数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">2.4.</span> <span class="toc-text"> 相关名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unicode%E5%AD%97%E7%AC%A6-%E5%92%8C-utf-8"><span class="toc-number">2.4.1.</span> <span class="toc-text"> Unicode字符 和 UTF-8</span></a></li></ol></li></ol></li></ol></div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/lian.gif" data-sizes="auto" alt="Luv" class="lazyload">
  <div class="sidebar-author-name">Luv</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">15</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">10</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">20</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>
</div>
    
    
      <div class="sidebar-btn-wrapper" style="position:static">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  </div>

  
</aside>

          
        </div>
        <footer id="footer" class="wow fadeInUp">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="outer">
    <div id="footer-info" class="inner">
      
      <div>
        <span class="icon-copyright"></span>
        2020-2025
        <span class="footer-info-sep"></span>
        Luv
      </div>
      
        <div>
          基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
          Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
        </div>
      
      
        <div>
          <span class="icon-brush"></span>
          106.3k
          &nbsp;|&nbsp;
          <span class="icon-coffee"></span>
          06:41
        </div>
      
      
        <div>
          <span class="icon-eye"></span>
          <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
          &nbsp;|&nbsp;
          <span class="icon-user"></span>
          <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
        </div>
      
    </div>
  </div>
</footer>

        <div class="sidebar-top">
          <img src="/images/taichi.png" height="50" width="50" />
          <div class="arrow-up"></div>
        </div>
        <div id="mask"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%9C%BA%E7%99%BD"><span class="toc-number">1.</span> <span class="toc-text"> 开场白</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-1-%E6%BD%9C%E9%BE%99%E5%8B%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text"> Week 1: 潜龙勿用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 类型转换易错点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 转义序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">2.1.2.1.</span> <span class="toc-text"> 泛化转义序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E9%9D%A2%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 指定字面值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.5.</span> <span class="toc-text"> 声明和定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E7%AC%A6%E5%AE%9A%E4%B9%89%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-number">2.1.5.1.</span> <span class="toc-text"> 标志符定义易错点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.5.2.</span> <span class="toc-text"> 变量命名规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8Bcompound-type"><span class="toc-number">2.1.6.</span> <span class="toc-text"> 复合类型(compound type)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.6.1.</span> <span class="toc-text"> 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.1.6.2.</span> <span class="toc-text"> 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88null-pointer"><span class="toc-number">2.1.6.2.1.</span> <span class="toc-text"> 空指针(null pointer)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88"><span class="toc-number">2.1.6.2.2.</span> <span class="toc-text"> void* 指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.6.2.3.</span> <span class="toc-text"> 指向指针的引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">2.1.7.</span> <span class="toc-text"> const限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.7.1.</span> <span class="toc-text"> const的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E4%BE%8B"><span class="toc-number">2.1.7.1.1.</span> <span class="toc-text"> 特例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9const%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%AF%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%B9%B6%E9%9D%9Econst%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.7.1.2.</span> <span class="toc-text"> 对const的引用可能引用一个并非const的对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88pointer-to-const"><span class="toc-number">2.1.7.2.</span> <span class="toc-text"> 指向常量的指针(pointer to const)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88const-pointer"><span class="toc-number">2.1.7.3.</span> <span class="toc-text"> 常量指针(const pointer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const"><span class="toc-number">2.1.7.4.</span> <span class="toc-text"> 顶层const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8Fconst-expression%E5%92%8Cconstexpr"><span class="toc-number">2.1.7.5.</span> <span class="toc-text"> 常量表达式(const expression)和constexpr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.1.8.</span> <span class="toc-text"> 类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88-%E5%B8%B8%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.1.8.1.</span> <span class="toc-text"> 指针、常量和类型别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">2.1.9.</span> <span class="toc-text"> auto类型说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-%E5%B8%B8%E9%87%8F%E5%92%8Cauto"><span class="toc-number">2.1.9.1.</span> <span class="toc-text"> 复合类型、常量和auto</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">2.1.10.</span> <span class="toc-text"> decltype类型指示符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.10.1.</span> <span class="toc-text"> decltype和引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.11.</span> <span class="toc-text"> 头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E7%AC%A6header-guard"><span class="toc-number">2.1.11.1.</span> <span class="toc-text"> 头文件保护符(header guard)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text"> 字符串、向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 命名空间的using声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 标准库类型string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.2.1.</span> <span class="toc-text"> 定义和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.2.2.</span> <span class="toc-text"> 能执行的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%9C%AA%E7%9F%A5%E6%95%B0%E9%87%8F%E7%9A%84string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.2.2.1.</span> <span class="toc-text"> 读写未知数量的string对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8getline%E8%AF%BB%E5%8F%96%E4%B8%80%E6%95%B4%E8%A1%8C"><span class="toc-number">2.2.2.2.2.</span> <span class="toc-text"> 使用getline读取一整行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stringsize_type%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.2.3.</span> <span class="toc-text"> string::size_type类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8Cstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.2.2.2.4.</span> <span class="toc-text"> 字面值和string对象相加</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">2.2.2.3.</span> <span class="toc-text"> 处理string对象中的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.2.3.1.</span> <span class="toc-text"> 基于范围的for语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 标准库类型vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.3.1.</span> <span class="toc-text"> 定义和初始化vector对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.3.1.1.</span> <span class="toc-text"> 值初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C-2"><span class="toc-number">2.2.3.2.</span> <span class="toc-text"> 能执行的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.4.1.</span> <span class="toc-text"> 使用迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.4.2.</span> <span class="toc-text"> 迭代器运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.4.3.</span> <span class="toc-text"> 迭代器类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.4.</span> <span class="toc-text"> 解引用和成员访问操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.4.5.</span> <span class="toc-text"> 迭代器运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%8C%E6%88%90%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">2.2.4.5.1.</span> <span class="toc-text"> 使用迭代器完成二分搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.</span> <span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.1.</span> <span class="toc-text"> 定义和初始化内置数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">2.2.5.1.1.</span> <span class="toc-text"> 字符数组的特殊性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">2.2.5.1.2.</span> <span class="toc-text"> 不允许拷贝和赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.5.1.3.</span> <span class="toc-text"> 理解复杂的数组声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.5.2.</span> <span class="toc-text"> 访问数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.2.5.3.</span> <span class="toc-text"> 数组和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B9%9F%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.5.3.1.</span> <span class="toc-text"> 指针也是迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0begin%E5%92%8Cend"><span class="toc-number">2.2.5.3.2.</span> <span class="toc-text"> 标准库函数begin和end</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.5.3.3.</span> <span class="toc-text"> 指针运算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.5.4.</span> <span class="toc-text"> C风格字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#c%E6%A0%87%E5%87%86%E5%BA%93stirng%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.5.4.1.</span> <span class="toc-text"> C标准库Stirng函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.5.4.2.</span> <span class="toc-text"> 比较字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.5.5.</span> <span class="toc-text"> 与旧代码的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E7%94%A8string%E5%AF%B9%E8%B1%A1%E5%92%8Cc%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.5.5.1.</span> <span class="toc-text"> 混用string对象和C风格字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.5.5.2.</span> <span class="toc-text"> 用数组初始化vector对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.6.</span> <span class="toc-text"> 多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">2.2.5.6.1.</span> <span class="toc-text"> 初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.6.2.</span> <span class="toc-text"> 使用范围for语句处理多维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.5.6.3.</span> <span class="toc-text"> 指针和多维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.2.5.6.4.</span> <span class="toc-text"> 类型别名简化多维数组的指针</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">2.3.</span> <span class="toc-text"> 杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 命令行编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%A3%80%E6%9F%A5%E5%87%BA%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">2.3.1.1.</span> <span class="toc-text"> 编译器检查出的错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iostream"><span class="toc-number">2.3.2.</span> <span class="toc-text"> iostream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E9%87%8F%E4%B8%8D%E5%AE%9A%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.2.1.</span> <span class="toc-text"> 读取数量不定的输入数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">2.4.</span> <span class="toc-text"> 相关名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unicode%E5%AD%97%E7%AC%A6-%E5%92%8C-utf-8"><span class="toc-number">2.4.1.</span> <span class="toc-text"> Unicode字符 和 UTF-8</span></a></li></ol></li></ol></li></ol></div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/lian.gif" data-sizes="auto" alt="Luv" class="lazyload">
  <div class="sidebar-author-name">Luv</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">15</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">10</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">20</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    <div class="site-search">
      <div class="reimu-popup popup">
        <div class="reimu-search">
          <span class="reimu-search-input-icon"></span>
          <div class="reimu-search-input" id="reimu-search-input"></div>
        </div>
        <div class="reimu-results">
          <div id="reimu-stats"></div>
          <div id="reimu-hits"></div>
          <div id="reimu-pagination" class="reimu-pagination"></div>
        </div>
        <span class="popup-btn-close"></span>
      </div>
    </div>
    
<script src="https://npm.webcache.cn/jquery@3.7.1/dist/jquery.min.js"></script>


<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script>



  
<script src="https://npm.webcache.cn/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script>




  
<script src="https://npm.webcache.cn/mermaid@9.4.3/dist/mermaid.min.js"></script>

  <script>
    if (window.mermaid) {
      // https://github.com/mermaid-js/mermaid/issues/1945
      const elementCode = '.mermaid'
      const saveOriginalData = () => {
        return new Promise((resolve, reject) => {
          try {
            var els = document.querySelectorAll(elementCode),
                count = els.length;
            els.forEach(element => {
              if (element.getAttribute('data-original-code') == null){
                element.setAttribute('data-original-code', element.innerHTML)
              }
              count--
              if(count == 0){
                resolve()
              }
            });
          } catch (error) {
          reject(error) 
          }
        })
      }
      const resetProcessed = () => {
        return new Promise((resolve, reject) => {
          try {
            var els = document.querySelectorAll(elementCode),
                count = els.length;
            els.forEach(element => {
              if(element.getAttribute('data-original-code') != null){
                element.removeAttribute('data-processed')
                element.innerHTML = element.getAttribute('data-original-code')
              }
              count--
              if(count == 0){
                resolve()
              }
            });
          } catch (error) {
          reject(error) 
          }
        })
      } 
      const loadMermaid = (theme) => {
        window.mermaid.initialize({theme})
        window.mermaid.init({theme}, document.querySelectorAll(elementCode))
      }
      document.body.addEventListener('dark-theme-set', () => {
        saveOriginalData()
        .then(resetProcessed())
        .then(loadMermaid('dark'))
        .catch(console.error)
      })
      document.body.addEventListener('light-theme-set', () => {
        saveOriginalData()
        .then(resetProcessed())
        .then(loadMermaid('default'))
        .catch(console.error)
      })
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>















  
<script src="https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js"></script>

  
<script src="https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js"></script>

  
<script src="/js/algolia_search.js"></script>

  <script>
    var CONFIG = {
      root: '/',
      algolia: {
        applicationID: "37ZQYZE607",
        apiKey: "dfdbcdcf987c68afcf35a63def2936e2",
        indexName: "Luv",
        hits: {
          "per_page": parseInt("10")
        },
        labels: {
          "input_placeholder": "搜索.....",
          "hits_empty": "未发现与 「${query}」相关内容",
          "hits_stats": "找到${hits}条结果（用时 ${time} ms）"
        }
      }
    };
  </script>



  
<script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script>

  <script>
    firework(JSON.parse('{"excludeElements":["a"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>







<script src="/js/script.js"></script>



  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '0.1.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  

  <!-- hexo injector body_end start -->
<script src="/js/insert_highlight.js" data-pjax></script>
<!-- hexo injector body_end end --></body>
  </html>

